{"/":{"title":"Algorithmes et Programmation","content":"\n\n## Leçons\n\n### Théorie\n#### [01 - Variables](cours/01-variables.md)\n#### [02 - Tableaux](cours/02-tableaux.md)\n#### [03 - Matrices](cours/03-matrices.md)\n#### [04 - String](cours/04-strings.md)\n#### [05 - Alternatives](cours/05-alternatives.md)\n#### [06 - Boucles](cours/06-boucles.md)\n#### [07 - Fonctions](cours/07-fonctions.md)\n#### [08 - Récursivité](cours/08-récursivité.md)\n#### [09 - Classes](cours/09-classes.md)\n\n### Processing\n#### [10 - Géométrie](cours/10-géométrie.md)\n#### [11 - Transformations](cours/11-transformations.md)\n\n\n## Tutoriels\n### [Structurer une solution processing](tutoriels/structurer-une-solution.md)\n### [Débugger (WIP)](tutoriels/debugger.md)\n### [Jeu : Space Invaders simplifié (WIP)](tutoriels/space-invaders)\n\n","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/cours/01-variables":{"title":"01 - Variables","content":"\n## Définition\n\nUne variable est un **_conteneur_** défini par\n\n-   Son **type** : le type de données qu'elle pourra contenir\n-   Son **nom** : le nom à utiliser pour récupérer la valeur qu'elle contient\n\n## Types\n\nLes types de variables dits **primitifs** sont les types inhérents au langage (ici, Java), on retrouve notamment\n\n| Type      | Valeurs                                                 |\n|:--------- |:------------------------------------------------------- |\n| `boolean` | `true` ou `false`                                       |\n| `char`    | Caractère, toujours écrit entre `''`, par exemple `'a'` |\n| `short`   | Petit nombre entier entre `-128` et `127`               |\n| `int`     | Grand nombre entier entre `-2147483648` à `2147483647`  |\n| `long`    | Très grand nombre entier                                |\n| `float`   | Nombre décimal, par exemple `3.14`                      |\n| `double`  | Nombre décimal plus précis                              |\n\nNote : On peut forcer un nombre décimal à être évalué comme un `float` ou un `double` en écrivant respectivement f ou d à la fin du nombre, par exemple `3.14f` ou `3.14d`\n\n## Déclaration\n\nDéclarer une variable permet de créer une nouvelle variable qui sera désormais utilisable dans la suite du code. Pour déclarer une variable, il faut impérativement indiquer son type et son nom :\n\n```java\nint i;\n```\n\nDans ce cas-ci, la variable `i` existe maintenant en processing, mais ne contient encore aucune valeur. On peut également déclarer une nouvelle variable **et** lui donner une valeur initiale :\n\n```java\nint i = 5;\n```\n\n### Erreurs\n\n-   Lorsque l'on veut utiliser une variable qui n'existe pas, qui n'a pas été déclarée, processing affichera une erreur du type `The variable \"j\" does not exist`\n-  Lorsque l'on déclare une variable avec le même nom qu'une autre variable, processing renverra une erreur du type `Duplicate local variable i`\n\n## Assignation\n\nL'assignation consiste à définir la (nouvelle) valeur d'une variable déclarée :\n\n```java\nint i; // Déclaration\ni = 5; // Assignation\n```\n  \n\nL'assignation est donc une ligne de code du type :\n\n\\\u003cnom\\_variable\\\u003e **=** \\\u003cvaleur\\\u003e ;\n  \nLe symbole **=** est **toujours** l'opérateur qui permet d'assigner une valeur à une variable. La comparaison de deux valeurs se fait avec le symbole **\\=\\=**.\n\nOn peut mettre à droite d'une assignation tout ce qui sera _évalué_ par Processing au **même type** que la variable à laquelle on va assigner cette valeur.\n\n### Exemples\n\n```java\n// Déclarations\n\nint i;\nint j;\n\n// Assignations\n\ni = 5; // i va contenir 5\nj = 5 * 2; // j va contenir 5 * 2 -\u003e évalué à 10\ni = j; // i va contenir j -\u003e évalué à 10\ni = j * 2; // i va contenir j * 2 -\u003e évalué à 10 * 2 -\u003e évalué à 20\n```\n\n### Erreurs\n\n- Lorsque l'on veut assigner à une variable une valeur d'un type incompatible, par exemple `int i = 3.14;`, processing affichera une erreur du type `Type mismatch, \"float\" does not match with \"int\"`\n\n## Evaluation\n\nL'**évaluation** est l'interprétation, par Processing, d'un morceau de code, une **expression**, pour en déduire une **valeur.** Une expression peut être \n\n-   Une valeur (par exemple `1`, `'a'`, `true`, etc.)\n-   Une variable\n-   Un appel de fonction : le type de la valeur sera le type de retour de cette fonction\n-   Un calcul impliquant des valeurs, variables ou appels de fonction : processing respectera alors l'ordre des opérateurs/parenthèses\n\nUne expression peut donc être utilisée\n\n-   Pour une assignation\n\n```java\nint i = 5;\ni = 5 * 2;\ni = i + 1;\n```\n\n-   Dans un appel de fonction\n\n```java\nprintln(i); // On affiche ce que contient la variable i\n```\n\n### Exercices\n\n1. Que sera-t-il affiché dans la console lorsqu'on exécute le code suivant ?\n\n```java\nint i = 1;\nint j = 2;\nprintln(i);\nprintln(i + j);\ni = i + j;\nj = 2 * i;\nj = 2 * j;\nprintln(i);\nprintln(j);\n```\n\n\u003cdetails class=\"solution\"\u003e \n\u003csummary\u003eSolution\u003c/summary\u003e\n\u003cdiv class=\"highlight\"\u003e\n\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\n\u003cspan class=\"line\"\u003e3\u003c/span\u003e\n\u003cspan class=\"line\"\u003e3\u003c/span\u003e\n\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\t\t\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/details\u003e\n","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/cours/02-tableaux":{"title":"02 - Tableaux","content":"\n## Définition\n\nUn **tableau** est une collection ordonnée de variables du même type. On accède a une variable du tableau grâce au nom du tableau et à la position de la variable dans celui-ci.\n\nUn tableau est un type de données au même titre que le sont `int`, `float`, etc. Il s'agit cependant d'un type dit *référentiel* et non primitif, car la variable de type tableau contient en réalité une référence vers un une suite de blocs en mémoire contenant les variables du tableau.\n\n### Stockage en mémoire\n\nLorsqu'un programme processing s'exécute, il possède sa propre mémoire dans laquelle seront stockées toutes les variables et tout ce qu'il se déroule dans le programme (appels de fonction, etc.). Cette mémoire se compose de deux parties :\n\n- La mémoire dite statique, le *stack*, qui contient notamment les variables (locales) de type primitif et des **références** vers des données stockées dans le *heap*\n- La mémoire dite dynamique, le *heap*, qui contient notamment des tableaux et des [objets](cours/09-classes.md)\n\n\u003cimg src=\"/stic/images/stack_heap_dm.svg\" class=\"svg-dark-mode\"/\u003e\n\u003cimg src=\"/stic/images/stack_heap_lm.svg\" class=\"svg-light-mode\"/\u003e\n\n\u003e ⚠️ Le stockage en mémoire est en réalité plus complexe, l'important ici est de comprendre la différence entre une valeur et une référence. Pour plus de détails sur la gestion de la mémoire lors de l'exécution d'un programme Java, Google est votre ami.\n\n## Déclaration\n\nOn déclare un tableau comme on déclare une [variable](cours/01-variables.md), à ceci près qu'il faut rajouter l'opérateur `[]` pour indiquer qu'il s'agit d'un tableau. On peut ajouter cet opérateur soit après le **type** de données du tableau, soit après son nom. Il s'agit de déclarations équivalentes.\n\n```java\nint[] integers;\n```\n\nou\n\n```java\nint integers[];\n```\n\nOn déclare ici une variable appelée `integers` qui est un tableau de nombres entiers.\n\n## Création\n\nIl existe deux façons de créer un tableau :\n\n1. On peut créer un tableau vide en indiquant sa taille, le nombre d'éléments qu'il contient.\n\n```java\nint[] integers = new int[6];\n```\n\n2. On peut créer un tableau en indiquant directement les valeurs qu'il contient entre `{}`. La taille du tableau sera donc le nombre d'éléments qu'on définit.\n\n```java\nint[] integers = new int[] { 1, 2, 4, 8, 16, 32 };\n```\n\nDans les deux cas, l'utilisation du mot clé `new` est obligatoire. Ce mot clé indique qu'on crée une nouvelle **référence** et est responsable de l'allocation en mémoire.\n\n## Manipulation\n\nUne fois un tableau déclaré et créé, on peut accéder à sa taille et aux différents éléments qu'il contient.\n\n### Taille du tableau\n\nLa taille d'un tableau **est déterminée à sa création et ne peut pas être changée**, on peut la récupérer grâce au champ spécial `length` du tableau, de la façon suivante :\n\n```java\nint[] integers = new int[] { 1, 2, 3 };\nprintln(integers.length); // Affiche 3\n```\n\n### Élements du tableau\n\nPour accéder à un élément particulier du tableau, il faut utiliser l'opérateur de tableau et l'indice de l'élément après le nom du tableau, par exemple `integers[1]`.\n\n\u003e ⚠️ En informatique, on commence à compter à partir de 0. Le premier élément aura donc l'indice 0, le deuxième l'indice 1, ainsi de suite.\n\nLorsque l'on accède à un élément du tableau, on récupère une variable (celle stockée dans le heap), et on peut donc s'en servir comme tel ; c'est-à-dire lui assigner une valeur, ou l'évaluer dans des expressions.\n\n```java\nint[] integers = new int[] { 1, 2, 3 };\n\n// Evalue la variable à l'indice 0 dans le tableau et affiche 1\nprintln(integers[0]); \n\n// Assigne la valeur 0 à la variable à l'indice 1 dans le tableau\nintegers[1] = 0; \n\n// Evalue la variable à l'indice 1 dans le tableau et affiche 0\nprintln(integers[0]);\n\n// Evalue la variable à l'indice 2 dans le tableau et affiche 3\nprintln(integers[2]); \n```\n\n### Parcourir le tableau\n\nPour parcourir un tableau, c'est-à-dire pour *itérer* sur chacun de ces éléments, il faudra utiliser une boucle dont les explications sont disponibles dans la leçon [06 - Boucles](cours/06-boucles.md).\n\n### Erreurs\n\n- Lorsque l'on essaie d'accéder à un élément dont l'indice est supérieur à la taille du tableau, c'est-à-dire à une position **hors** du tableau, l'exécution du code provoquera une erreur du type `ArrayIndexOutOfBoundsException` avec l'indice auquel on a voulu accéder.","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/cours/03-matrices":{"title":"03 - Matrices","content":"\n## Définition\n\nUn [tableau](cours/02-tableaux.md) étant un type de données, il est tout à fait possible de définir un tableau *de tableaux*, c'est-à-dire un tableau dont tous les éléments sont des références vers des tableaux d'un (même) type de données. On peut ainsi avoir un tableau de tableaux d'entiers (2 dimensions), un tableau de tableaux de tableaux de booléens (3 dimensions), etc. Tous les tableaux d'une même dimension auront la même taille, puisque la taille d'un tableau est statique et définie à sa création.\n\n\u003cimg src=\"/stic/images/matrix_dm.svg\" class=\"svg-dark-mode\"/\u003e\n\u003cimg src=\"/stic/images/matrix_lm.svg\" class=\"svg-light-mode\"/\u003e\n\nUne matrice est un tableau de tableaux : un tableau à deux dimensions, comme dans Excel, par exemple. On parlera ainsi de **lignes** pour la première dimension et de **colonnes** pour la deuxième dimension.\n\n## Déclaration\n\nPour déclarer une matrice, il faut simplement déclarer un tableau dont le type d'éléments est lui-même tableau, c'est-à-dire en rajoutant `[]` après le type d'éléments de ce tableau. Par exemple, un tableau de tableaux d'entiers sera noté `int[][]`. \n\n```java\nint[][] t1; // Tableau de tableaux d'entiers\nfloat[][] t2; // Tableau de tableaux de float\nboolean[][] t3; // Tableau de tableaux de booléens\n```\n\n## Création\n\nComme pour un tableau \"classique\", à 1 dimension, une matrice peut être créée de deux façons :\n\n1. On peut créer une matrice vide en indiquant la taille du tableau (le nombre de lignes), et la taille des tableaux se trouvant dans ce tableau principal (le nombre de colonnes) dans l'opérateur `[]` (un par dimension).\n\n```java\n// Tableau contenant 3 tableaux de 10 éléments chacun\nint[][] integers = new int[3][10]; \n```\n\nOn peut donc ainsi créer des tableaux de dimension complètement arbitraire :\n\n```java\nint[][][][][] whyNot = new int[3][6][9][6][3];\n```\n\n2. On peut créer une matrice en indiquant directement les valeurs qu'elle contient entre `{}`. Les accolades délimitent **un** tableau, et pour définir le contenu de la deuxième dimension, le contenu de chaque ligne, il faut aussi utiliser `{}`. Les tailles des tableaux seront alors déterminées automatiquement.\n\n```java\nint[][] integers = new int[][] { \n  { 1, 2, 3 }, // Première ligne\n  { 4, 5, 6 }, // Deuxième ligne\n  { 7, 8, 9 }  // Troisième ligne\n};\n```\n\n## Manipulation\n\nUne matrice étant un tableau, on la manipule de la même façon. La différence est que chaque variable de la première dimension est elle-même un tableau, et qu'on peut donc directement chaîner l'adressage `[]` pour accéder aux éléments de ce tableau.\n\n### Taille de la matrice\n\nPour la taille de la matrice, on parlera plus simplement de son nombre de lignes et de colonnes qui sont, respectivement, la taille du tableau de la première dimension et la taille des tableaux de la deuxième dimension. On peut récupérer cette information comme on le ferait pour un tableau quelconque.\n\n```java\nint[] m = new int[] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint nbLines = m.length;\nint nbColumns = m[0].length; // m[0] = première ligne\n```\n\n### Élements de la matrice\n\nOn accède aux **lignes** d'une matrice de la même façon qu'un tableau, avec l'opérateur `[]`, et aux éléments d'une ligne en réutilisant l'opérateur `[]` sur la ligne récupérée.\n\n// TODO schéma\n\n```java\nint[] m = new int[] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint[] firstLine = m[0];\nint[] secondLine = m[1];\nint firstElementOfFirstLine = firstLine[0];\nint lastElementOfThirdLine = m[2][2];\n\nprintln(m[1][1]); // Affiche 5\nm[1][1] = 10;\nprintln(m[1][1]); // Affiche 10\n```\n\n### Parcourir une matrice\n\nPour parcourir une matrice, c'est-à-dire pour *itérer* sur chacun de ces éléments, il faudra utiliser des boucles imbriquées dont les explications sont disponibles dans la leçon [06 - Boucles](cours/06-boucles.md).","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/cours/04-strings":{"title":"04 - Strings","content":"\n## Définition\n Un **string** est un type de données particulier permettant de contenir une chaîne de caractères, du texte. Il ne s'agit pas d'un type primitif comme `int`, `float`, etc. mais d'une [classe](cours/09-classes/md) `String` existante dans le langage Java de base.\n\nComme toute variable, on déclare un string en indiquant son type, `String`, et le nom de la variable. En Java, une chaîne de caractères est délimitée par des guillemets. Ainsi, toute valeur entre `\" \"` sera évaluée par processing comme étant du type `String`.\n\n```java\nString s = \"Hello, world!\";\nprintln(s); // Affiche Hello, world!\n```\n\n## Manipulation\n\n### Concaténation\n\nLa **concaténation** est une opération qui permet de combiner deux chaînes de caractères via l'opérateur `+`. Les deux chaînes de caractères seront alors mises \"bout à bout\" pour n'en former qu'une.\n\n```java\nString s1 = \"Hello \";\nString s2 = \"World\";\nString s3 = s1 + s2;\nprintln(s); // Affiche Hello World\n```\n\nComme toute opération simple, on peut l'utiliser plusieurs fois dans une même expression, ce qui permet de construire facilement des chaînes de caractères en combinant des variables de type `String` et des valeurs directement.\n\n```java\nString s1 = \"Hello\";\nString s2 = \"World\";\nprintln(s1 + \" \" + s2 + \"!\");\n```\n\n#### Concaténation avec un autre type\n\nOn peut concaténer une chaîne de caractères avec une valeur d'un autre type, cette valeur sera alors convertie automatiquement par processing en une chaîne de caractères correspondant à son contenu.\n\n```java\nString s = \"Number \";\nint i = 5;\nprintln(s + i); // Affiche Number 5\n```\n\n","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/cours/05-alternatives":{"title":"05 - Alternatives","content":"\n## TODO","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/cours/06-boucles":{"title":"06 - Boucles","content":"\n## TODO","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/cours/07-fonctions":{"title":"07 - Fonctions","content":"\n## Définition\n\n## Signature\n\n## Appel\n","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/cours/08-r%C3%A9cursivit%C3%A9":{"title":"08 - Récursivité","content":"\n## TODO","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/cours/09-classes":{"title":"09 - Classes","content":"\n## TODO","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/cours/10-g%C3%A9om%C3%A9trie":{"title":"10 - Géométrie","content":"\n## TODO","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/cours/11-transformations":{"title":"11 - Transformations","content":"\n## TODO","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/tutoriels/debugger":{"title":"Débugger (et pas déboguer)","content":"\nTODO","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/tutoriels/space-invaders/_index.md":{"title":"Space Invaders simplifié","content":"\n## [Consignes](tutoriels/space-invaders/consignes.md)","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/tutoriels/space-invaders/consignes":{"title":"Space Invaders simplifié","content":"\n## Introduction\n\nSpace Invaders est un jeu d’arcade créé en 1978. Il s’agit du tout premier jeu \"shooter' fixe. Dans ce jeu, le joueur incarne un vaisseau qui se déplace latéralement et tente de repousser une vague d’envahisseurs à l’aide d’un canon laser. Les aliens se rapprochent lentement mais sûrement du vaisseau et tirent également des lasers vers le vaisseau. Les lasers se déplacent verticalement et disparaissent quand ils touchent un ennemi ou atteignent le bord de l’écran de jeu. Il y a des obstacles entre le vaisseau et les envahisseurs qui sont progressivement détruits par les lasers.\n\n![[tutoriels/space-invaders/images/SpaceInvadersOriginal2.png]]\n\n## Version minimale\n\n### Vie et fin de jeu \nDans cette version, les aliens sont inoffensifs et le joueur ne perd jamais. Quand une vague d’aliens est entièrement détruite, une nouvelle vague arrive. \n\n### Ennemis\n\nUne vague d’aliens a les dimensions suivantes : 5 lignes de 10 aliens. Ils ne se déplacent pas et ne tirent pas. \n\n### Destruction\n\nAu contact d’un laser, l’alien touché et le laser sont détruits immédiatement. Si un laser atteint le haut de l’écran sans avoir touché un alien, il disparaît. \n\n### Contrôles\n\nLes mouvements latéraux du vaisseau sont contrôlés par les touches `FLÈCHE-GAUCHE` et `FLÈCHE-DROITE`. La touche `ESPACE` permet de tirer des lasers. \n\n### Dimensions\n\nVous pouvez utiliser les dimensions suivantes : \n- Les dimensions de la fenêtre sont de 1000x800 pixels\n- Les aliens et le vaisseau sont des rectangles de 50x50 pixels\n- Les lasers sont des rectangles de 5x30 pixels \n\n### Démonstration\n\u003cp align=\"center\"\u003e\n\u003ciframe src=\"https://openprocessing.org/sketch/1592175/embed/?plusEmbedHash=YTc3Mzc1ODI5ODMzYzhkMTdkYzAyM2U4Yjk1MDc4YWJiZTEyMzc2ZjVmZTRmMTQ4NTQ1MGY5NDdmN2VlNTdlNGMwMWI1ZDNjMzc2NjkyZGEyMThiMWIxZGNmODYyZjEyNmM3ODE3YWUyMjZmMDEyMGVhN2NiYTgwYWNkN2U3Y2RrdGg2VWk4NXkxVWNWVitBZitsbXozUTdOVFQ5UERTd0c2dmpZM0VybXloKzFUMUxDb1dvTU9JWWpBWnlEUVdoSlFscFl5SW1TWXRyeWN2ZWhWVEVBUT09\u0026plusEmbedTitle=true\" width=\"600\" height=\"500\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\n\n## Version améliorée\n\n### Fin de jeu\n\nLes aliens se rapprochent lentement mais sûrement du vaisseau. Si le joueur ne parvient pas à détruire l’entièreté de la vague avant que les aliens atteignent le bas de l’écran, le jeu est perdu. \n\n### Gestion des couleurs\n\nChaque alien peut, aléatoirement, avoir une des couleurs suivantes : `color(240, 20, 20)`, `color(200, 20, 200)`, `color(20, 200, 20)`, `color(20, 100, 250)`, `color(240, 200, 0)`. \n\n### Gestion de la difficulté\n\nLorsque la vague d’aliens est détruite, un nouvelle vague arrive. Chaque vague d’aliens est plus résistante que la précédente : à chaque nouvelle vague, il faut un coup de laser en plus pour détruire un alien. A la deuxième vague, il faudra donc toucher un alien 2 fois pour le détruire, 3 fois pour la troisième vague, et ainsi de suite. \n\n### Gestion de la transparence\n\nSi vous gérez également la difficulté des vagues, le taux d’opacité d’un alien diminue en fonction du nombre de lasers qui l’ont déjà touché, pour un minimum de 50%. Par exemple, à la vague 3, un alien sera initialement visible à 100%, à 75% après le premier coup et à 50% après le deuxième ; il sera détruit après le troisième coup.\n\n### Démonstration\n\n\u003cp align=\"center\"\u003e\n\u003ciframe src=\"https://openprocessing.org/sketch/1592193/embed/?plusEmbedHash=YmI5ZWNkMzIwYzFiZGNhODBkOGM0NzYyN2ZmMTAyNjBiYzc5OGQ4OTk0OTY2YmJmNTUwMjRlOWZmOWU4MmNiMzQ5ODhmOTg5M2E1MTA0ZjU3OWFkMzRjZThjZTliZmU5NDBiNjcyZmIyNmVhNWQ5YmZmOTkyOWRhM2NjOTI0NzFzSkRWU29QRzRzOTZYOXArekUvTmk3OFhNWWRRRjFCbXVwNkUrZ2ZSNmp4UHlwOUlpaE55WUt5NEc0Y1VubWhNM1JlWWJhVnhaQ3N0RmJQL0xyeXJTUT09\u0026plusEmbedTitle=true\" width=\"600\" height=\"500\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e","lastmodified":"2022-06-11T15:27:46.010421411Z","tags":null},"/tutoriels/structurer-une-solution":{"title":"Structurer une solution processing","content":"\n## Vue d'ensemble\nUne solution processing contiendra\n\n-   La déclaration de variables globales (visibles dans tous les blocs)\n-   Le `setup`\n-   Le `draw`\n-   Les fonctions de réaction aux inputs pertinantes (`mousePressed`, `keyPressed`, etc.)\n-   Des fonctions globales, utilitaires\n-   Des classes\n\nIl est plus facile d'écrire une classe dans un onglet spécifique pour cette classe, et, si le code devient trop long, de regrouper en différents onglets (~ bloc logique) les différentes fonctions.\n\n## Etat et données\n\nL'_état_ du code est l'ensemble des informations (~ variables) qui permettent, à tout moment, de représenter le dessin et de le faire évoluer.\n\n### Constantes\n\nLes variables **constantes** sont des valeurs qui ne changeront pas lors de l'exécution du code, mais qui seront amenées à être utilisées régulièrement. On préfère ainsi voir apparaître ce genre de valeurs dans des variables constantes, pour pouvoir facilement les changer sans devoir reparcourir tout le code. \n\nLorsque ces variables sont bien nommées, elles peuvent également améliorer la lisibilité du code :\n\n```java\nint WON = 1;\nint PLAYING = 0;\nint LOST = -1;\n\nint status = PLAYING;\n\n// ... Some code\n\nif (status == WON) {\n  // Do something if we won\n} else if (status == LOST) {\n  // Do something else if we lost\n} else {\n  // Continue playing\n}\n```\n\n### Déterminer les informations nécessaires\n\nLes autres variables sont déterminées par ce dont nous avons besoin pour avoir le comportement voulu. Par exemple, si on veut dessiner une balle qui rebondit sur les bords de l'écran, il faudra connaître les informations qui permettent de dessiner cette balle : ses coordonnées, sa taille, sa couleur, etc. Ce qu'on peut voir comme une seule information doit parfois être stockée en plusieurs variables.\n\n\u003e ⚠️ Il est **difficile** de réussir à déterminer toutes les variables dont on a besoin dès le début. C'est seulement en avançant dans la solution et dans les fonctionnalités implémentées qu'on se rend compte qu'il manque des informations.\n\n### Evolution des données\n\nLes variables non constantes sont amenées à changer lors de l'exécution du code. On peut distinguer deux types d'évolution :\n- L'évolution naturelle (dans le `draw`)\n- L'évolution forcée en réaction aux entrées clavier/souris de l'utilisateur\n\n## Initialisation `setup`\n\nTout dessin processing doit définir la fonction `setup` dans laquelle il convient d'initialiser l'état, les valeurs initiales des données. On peut aussi y configurer certains paramètres globaux du dessin (largeur des lignes, etc.)\n\n```java\nvoid setup() {\n  size(800, 600);\n\n  // Some global drawing parameters\n\n  // Data initialization\n\t\n}\n```\n\n## Boucle principale `draw`\n\nLa \"boucle principale\" est une boucle implicite qui permet de passer à l'étape suivante du code. En processing, cette boucle principale est la fonction `draw`, et une étape est une *frame* du dessin. C'est donc de cette fonction que partira la majorité de la logique du code : la représentation, le dessin, et l'évolution naturelle des données. L'ordre des différentes mises à jour de données et des dessins dépendra du comportement voulu\n\n```java\nvoid draw() {\n  background(0); // Hide previous frame if needed\n\n  // Update state\n\n  // Draw state\n\n}\n```\n\n## Réactions aux entrées\n\nLes différentes entrées possibles en processing sont accessibles via des fonctions qui seront appelées quand l'évènement correspondant survient, entre deux appels de `draw`. Il ne faut définir chaque fonction qu'une seule fois\n\n\u003e ⚠️ Les réactions aux entrées ne fonctionnent que pour les dessins animés, c'est-à-dire les dessins pour lesquels on a défini le `draw`\n\n### Clavier\n\nPour une entrée clavier, il y aura toujours deux événèments :\n- `void keyPressed()` quand on appuie sur la touche du clavier\n- `void keyReleased()` quand on relâche la touche\n\nAttention, maintenir une touche du clavier enfoncée peut provoquer plusieurs appels consécutifs à `keyPressed` mais ce comportement et la fréquence à laquelle l'évènement est produit dépendent du système d'exploitation. Par conséquent, utiliser `keyPressed` pour bouger des parties du dessin (comme un personnage) causera des mouvements saccadés, moins fluides que si l'évolution des coordonnées était réalisée dans le `draw`. \n\n### Souris\n\nPour une entrée souris, il y aura toujours les évènements :\n- `void mousePressed()` quand on appuie sur la touche de la souris\n- `void mouseReleased()` quand on relâche la touche\n- `void mouseClicked()` quand on a appuyé et relâché une touche\n\n## Fonctions\n\nEcrire des fonctions permet de ne définir qu'une seule fois un bloc de code qui sera amené à être utilisé plusieurs fois. On peut également écrire des fonctions simplement pour améliorer la lisibilité (à condition de bien nommer les fonctions) ou pour alléger un long bloc de code.\n\n```java\nint x1 = 0; int y1 = 0;\nint x2 = 10; int y2 = 20;\n\nvoid setup() {\n  size(500, 500);\n\n  fill(int(random(256)));\n  ellipse(x1, y1, 20, 20);\n\t\n  fill(int(random(256)));\n  ellipse(x2, y2, 20, 20);\n}\n```\n\nDevient\n\n```java\nint x1 = 0; int y1 = 0;\nint x2 = 10; int y2 = 20;\n\nvoid setup() {\n  size(500, 500);\n  drawCircleWithRandomColor(x1, y1);\n  drawCircleWithRandomColor(x2, y2);\n}\n\nvoid drawCircleWithRandomColor(float x, float y) {\n  fill(int(random(256)));\n  ellipse(x, y, 20, 20);\n}\n```\n\n## Classes\n\nLes classes permettent de définir des concepts complexes et d'y regrouper les différentes informations (= attributs) et comportements (= méthodes) de ces concepts. Elles permettent, comme les fonctions, d'améliorer la structure et la lisibilité du code. \n\nIl n'est pas nécessaire de faire des classes (ou des fonctions), mais il est parfois plus facile de concevoir directement la solution en orienté objet (\"je vais faire des objets Balle\"). Bien souvent, lorsque l'on détermine les informations nécessaires, elles-mêmes sont déduites des concepts qui peuvent directement être traduits en classes.\n\n```java\nclass CircleWithRandomColor {\n  int x, y;\n  int diameter;\n  int c;\n\n  CircleWithRandomColor(int x, int y, int diameter) {\n    this.x = x;\n    this.y = y;\n    this.diameter = diameter;\n    this.c = int(random(256));\t  \n  }\n\n  void display() {\n    ellipseMode(DIAMETER);\n    fill(c);\n    ellipse(x, y, diameter, diameter);\n  }\n}\n```\n\n## Conseils généraux\n- Aller à l'essentiel, d'abord faire fonctionner ce qu'on veut puis seulement essayer d'améliorer ou de simplifier\n- Isoler des fonctionnalités pour seulement ensuite les intégrer au code principal\n- Avancer petit à petit, ne pas essayer de tout faire en une fois\n- [Débugger](tutoriels/debugger.md), via le debugger de processing ou en affichant en console ce qu'il se passe, les valeurs, etc.\n\n## Exemple\n\nCi-dessous un tutoriel processing (disponible ici) montrant comment réaliser le dessin d'une balle qui part du centre de l'écran vers une direction aléatoire, et rebondit sur les bords\n\n// TODO","lastmodified":"2022-06-11T15:27:46.014421439Z","tags":null}}