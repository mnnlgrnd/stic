{"/":{"title":"Algorithmes et Programmation","content":"\n## Leçons\n\n### Théorie\n#### [01 - Variables et littéraux](cours/01-variables-litteraux.md) \n#### [02 - Expressions](cours/02-expressions.md)\n#### [03 - Tableaux et matrices](cours/03-tableaux-matrices.md)\n#### [04 - Alternatives](cours/04-alternatives.md)\n#### [05 - Boucles](cours/05-boucles.md)\n#### [06 - Fonctions](cours/06-fonctions.md)\n#### [07 - Blocs et contextes](cours/07-blocs-contextes.md)\n#### [08 - Récursivité](cours/08-recursivite.md)\n#### [09 - Classes](cours/09-classes.md)\n#### [10 - Strings](cours/10-strings.md)\n\n### Processing\n#### [11 - Bases de processing](cours/11-bases-processing.md)\n#### [12 - Dessins et géométrie](cours/12-dessins-geometrie.md)\n#### [13 - IntList et FloatList](cours/13-intlist-floatlist.md)\n#### [14 - Images et pixels](cours/14-images-pixels.md)\n#### [15 - Tables](cours/15-tables.md)\n\n\n\n## Tutoriels\n### [Structurer une solution processing](tutoriels/structurer-une-solution.md)\n### [Débugger](tutoriels/debugger.md)\n### [Jeu : Space Invaders simplifié](tutoriels/space-invaders.md)\n\n","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/01-variables-litteraux":{"title":"01 - Variables et littéraux","content":"\n## Variables\n\n### Définition\n\nUne variable est un **_conteneur_** défini par\n\n-   Son **type** : le type de données qu'elle pourra contenir\n-   Son **nom** : le nom à utiliser pour récupérer la valeur qu'elle contient\n\n### Types\n\nLes types de variables dits **primitifs** sont les types inhérents au langage (ici, Java), on retrouve notamment\n\n| Type      | Valeurs                                                 |\n|:--------- |:------------------------------------------------------- |\n| `boolean` | `true` ou `false`                                       |\n| `char`    | Caractère, toujours écrit entre `''`, par exemple `'a'` |\n| `short`   | Petit nombre entier entre `-128` et `127`               |\n| `int`     | Grand nombre entier entre `-2147483648` à `2147483647`  |\n| `long`    | Très grand nombre entier                                |\n| `float`   | Nombre décimal, par exemple `3.14`                      |\n| `double`  | Nombre décimal plus précis                              |\n\n### Déclaration\n\nDéclarer une variable permet de créer une nouvelle variable qui sera désormais utilisable dans la suite du code. Pour déclarer une variable, il faut impérativement indiquer son type et son nom :\n\n```java\nint i;\n```\n\nDans ce cas-ci, la variable `i` existe maintenant en processing, mais ne contient encore aucune valeur. On peut également déclarer une nouvelle variable **et** lui donner une valeur initiale :\n\n```java\nint i = 5;\n```\n\n#### Erreurs\n\n-   Lorsque l'on veut utiliser une variable qui n'existe pas, qui n'a pas été déclarée, processing affichera une erreur du type `The variable \"j\" does not exist`\n-  Lorsque l'on déclare une variable avec le même nom qu'une autre variable, processing renverra une erreur du type `Duplicate local variable i`\n\n### Assignation\n\nL'assignation consiste à définir la (nouvelle) valeur d'une variable déclarée :\n\n```java\nint i; // Déclaration\ni = 5; // Assignation\n```\n  \n\nL'assignation est donc une ligne de code du type :\n\n\\\u003cnom\\_variable\\\u003e **=** \\\u003cvaleur\\\u003e ;\n  \nLe symbole **=** est **toujours** l'opérateur qui permet d'assigner une valeur à une variable. La comparaison de deux valeurs se fait avec le symbole **\\=\\=**.\n\nOn peut mettre à droite d'une assignation tout ce qui sera _évalué_ par Processing au **même type** que la variable à laquelle on va assigner cette valeur.\n\n#### Exemples\n\n```java\n// Déclarations\n\nint i;\nint j;\n\n// Assignations\n\ni = 5; // i va contenir 5\nj = 5 * 2; // j va contenir 5 * 2 -\u003e évalué à 10\ni = j; // i va contenir j -\u003e évalué à 10\ni = j * 2; // i va contenir j * 2 -\u003e évalué à 10 * 2 -\u003e évalué à 20\n```\n\n#### Erreurs\n\n- Lorsque l'on veut assigner à une variable une valeur d'un type incompatible, par exemple `int i = 3.14;`, on aura une erreur du type `Type mismatch, \"float\" does not match with \"int\"`\n\n### Evaluation\n\nL'**évaluation** est l'interprétation, par Processing, d'un morceau de code, une **[expression](cours/02-expressions.md)**, pour en déduire une **valeur.** Une expression peut être \n\n-   Une valeur (par exemple `1`, `'a'`, `true`, etc.)\n-   Une variable\n-   Un appel de fonction : le type de la valeur sera le type de retour de cette fonction, par exemple `float f = random(0, 1)`, on assigne à la variable `f` un nombre aléatoire entre 0 et 1 que nous retourne la fonction `random`\n-   Un calcul impliquant des valeurs, variables ou appels de fonction : processing respectera alors l'ordre des opérateurs/parenthèses\n\nUne expression peut donc être utilisée\n\n-   Pour une assignation\n\n```java\nint i = 5;\ni = 5 * 2;\ni = i + 1;\n```\n\n-   Dans un appel de fonction\n\n```java\nprintln(i); // On affiche ce que contient la variable i\n```\n\n### Constantes\n\nSi la valeur contenue dans une variable n'est pas amenée à évoluer pendant l'exécution du programme, mais qu'elle restera toujours la même, on peut imposer cette contrainte en déclarant explicitement une variable *constante*. Pour ce faire, il faut utiliser le mot clé `final` avant le type de la variable.\n\n```java\nfinal int CONSTANT = 1;\n```\n\nPour facilement différencier les variables constantes, qui sont donc des variables auxquelles on ne pourra assigner qu'une seule fois une valeur, il est conseillé de mettre leur nom entièrement en majuscule.\n\nSi, par inadvertance, on essaie malgré tout d'assigner une nouvelle valeur à une variable constante, on aura une erreur du type `Final local variable \u003cname\u003e may already have been assigned`.\n\n## Littéraux\n\n### Définition\n\nA la différence d'une variable, un *littéral* qualifie une valeur constante utilisée directement dans du code. \n\n### Type\n\nTout comme une variable, un littéral a un type, mais celui est en général implicite et inféré directement par le langage. On retrouve différents littéraux :\n- `true` et `false`, les littéraux de type booléen\n- Les littéraux de nombres entiers comme `1`, `23094`, etc.\n- Les littéraux de nombres à virgule, comme `3.14`, `-23.45`, etc. On peut forcer le type d'un littéral de nombre à être `float` ou `double`  en utilisant `f` ou `d` après le littéral :\n\t- `1f` est de type `float`\n\t- `3.14d` est de type `double`\n- Les littéraux de type caractère (`char`) comme `'a'`, `'+'`, etc. ; n'importe quel caractère entre deux `'`\n- Les littéraux de chaînes de caractères (strings), vu dans la leçon [09 - Strings](cours/10-strings.md)\n\n### Assignation à une variable\n\nLorsque l'on utilise un littéral dans une assignation pour stocker sa valeur dans une variable, il faut donc que ce type *corresponde* à celui de la variable. \n\n\u003e **Correspondance n'est ici pas équivalence**. \n\nLe littéral `10` est de type entier, mais peut tout à fait être stocké dans une variable de type `float` puisque float peut contenir des nombres de plus grande précision. Le contraire n'est pas vrai ; par exemple, le littéral `3.14` contient un nombre à virgule qui ne peut pas être stocké dans une variable entière (`int`,  `long`) car la précision du littéral est plus grande que celle du type de la variable. Il faut alors convertir explicitement le littéral en entier via la fonction de conversion `int`, par exemple `int(3.14)`, qui ne conservera que la partie entière du nombre.","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/02-expressions":{"title":"02 - Expressions","content":"\n\n## Définition\n\nEn Java, une **expression** est une écriture possédant une ***valeur*** et un ***type*** et dans laquelle on peut retrouver :\n- Des littéraux\n- Des noms de variables\n- Des opérateurs\n- Des appels de [fonctions](cours/06-fonctions.md)\n\nLa ***valeur*** d'une expression est calculée en tenant compte des valeurs contenues dans les variables apparaissant dans l'expression et des valeurs retournées par les appels de fonction. Le ***type*** de l'expression est le type de cette valeur, du résultat.\n\nLes opérateurs possibles dans une expression dépendent de son type. Comme dans des expressions mathématiques classiques, la priorité des opérateurs est respectée pour obtenir le résultat final, et on peut utiliser des parenthèses \n\n## Expressions booléennes\n\nLes expressions booléennes sont des expressions dont le type est `boolean`, c'est-à-dire des expressions dans la valeur est `true` ou `false`. \n\n### Opérateurs \n\nLes opérateurs possibles dans les expressions booléennes sont donc les opérateurs logiques de base ainsi que les opérateurs de comparaison entre nombres.\n\nLes opérateurs logiques sont, dans l'ordre des priorités :\n\n- `!`, la négation \n- `\u0026\u0026`, le ET logique\n- `||` , le OU logique\n\n```java\nprintln(true); // Affiche true\nprintln(!true); // Affiche false\nprintln(true || false); // Affiche true\nprintln(true \u0026\u0026 false); // Affiche false\n\nprintln(true || false \u0026\u0026 false); // Affiche true car on fait d'abord le \u0026\u0026\n                                 // Ca équivaut donc à true || false -\u003e true\nprintln((true || false) \u0026\u0026 false); // Affiche false car on respecte les parenthèses\n                                   // Ca équivaut donc à true \u0026\u0026 false -\u003e false\n``` \n\nLes opérateurs de comparaison ont tous le même ordre d'importance, et sont :\n\n- `==` , l'égalité\n- `!=` , la différence\n- `\u003e` , strictement plus grand\n- `\u003e=`, plus grand ou égal\n- `\u003c`, strictement plus petit\n- `\u003c=`, plus petit ou égal\n\n```java\nprintln(1 == 1); // Affiche true\nprintln(1 != 1); // Affiche false\nprintln(2 \u003e 1); // Affiche true\nprintln(1 \u003e= 2); // Affiche false\nprintln(1 \u003c 2); // Affiche true\nprintln(2 \u003c= 1); // Affiche false\n```\n\n## Expressions mathématiques\n\nLes expressions mathématiques sont des expressions dont le résultat est de type numérique (entier ou flottant). Les opérateurs sont donc les opérateurs classiques en mathématiques, dans l'ordre des priorités :\n\n- `*` et `/` pour la multiplication et la division\n- `+` et `-` pour l'addition et la soustraction\n\n```java\nprintln(1 + 1); // Affiche 2\nprintln(3 * 3); // Affiche 9\nprintln(2 + 2 * 2); // Affiche 6\n```\n\n### Entiers et flottants\n\nIl faut bien faire attention aux types des valeurs que l'on utilise dans une expression car ce sont eux qui déterminent le type du résultat. \n\nLorsqu'une expression ne contient que des valeurs entières, le résultat sera lui-même entier, et ce même si la vraie expression mathématique correspondante ne l'est pas. Ainsi, l'expression `1 / 2` ne contient que des entiers, et le résultat sera donc le résultat de la *division entière* de 1 par 2, qui vaut donc `0`. \n\nDe façon plus générale, si une expression ne contient que des valeurs du même type, ce sera aussi le type de l'expression. Si par contre l'expression contient des valeurs de différents types, l'expression prendra le type ayant la plus grande précision (voir [01 - Variables et littéraux](cours/01-variables-litteraux.md)).\n\nAinsi, si une expression contient des valeurs de type `int` et des valeurs de type `float`, donc flottantes, l'expression sera de type `float`. Par exemple, le résultat de `1.0 / 2` est flottant, et il s'agit donc de la division normale dont le résultat `0.5`.\n\n```java\nint m = 1 / 2; // 0\nfloat n = 1.0 / 2; // 0.5\n```\n\n### Modulo\n\nOn peut également utiliser l'opérateur `%` pour le \"modulo\", le reste de la division entière. \n\n```java\nprintln(1 % 4); // Affiche 1\nprintln(10 % 4); // Affiche 2\nprintln(12 % 4); // Affiche 0\n```\n\nL'utilisation du modulo permet de transformer une suite continue en un cycle de valeurs allant de 0 à la valeur du modulo - 1 :\n\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/modulo_dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/modulo_lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n### Sucres syntaxiques\n(A prononcer avec l'accent québecois car c'est la seule bonne raison de traduire un terme anglais)\n\nLes sucres syntaxiques, ou *syntactic sugars*, sont des facilités, des raccourcis de code qu'un langage met à disposition des utilisateurs.\n\n#### Raccourcis mathématiques\n\nPour les opérations mathématiques, Java propose des raccourcis pour les calculs de la forme *x = x \\\u003copérateur\\\u003e \\\u003cexpression\\\u003e*. C'est-à-dire quand on assigne à une variable le résultat d'une opération simple entre cette variable et une autre expression. On peut éviter de répéter la variable *x* en utilisant le sucre syntaxique correspondant *x \\\u003copérateur\\\u003e= \\\u003cexpression\\\u003e*. Ceci est valable pour les 4 opérateurs mathématiques standards `+`, `-`, `*` et `/`.\n\n```java\nint i = 0;\n\ni = i + 5; // Forme normale\ni += 5; // Sucre syntaxique \n\ni = i * (45 / 3); // Forme normale\ni *= 45 / 3; // Sucre syntaxique\n```\n\n#### Incrémentation et décrémentation\n\nDe plus, lorsque le calcul est de type *x = x + 1* ou *x = x - 1*, on peut davantage simplifier la ligne de code en utilisant les opérateurs d'incrémentation `++` et de décrémentation `--`.\n\n```java\nint i = 0;\n\ni = i + 1; // Forme normale\ni++; // Incrémentation\n\ni = i - 1; // Forme normale\ni--; // Décrémentation\n```\n\n##### 🕵‍♀ Comme expression\n\nLes opérateurs `++` et `--` peuvent s'utiliser avant ou après la variable à incrémenter/décrémentér. Dans les deux cas, la valeur de la variable sera mise à jour avec le résultat de l'addition/soustraction avec 1.\n\nLa différence réside dans le fait qu'il s'agit d'une expression ; on peut donc utiliser l'incrémentation/décrémentation comme expression pour une assignation : `int y = x++`. Dans ce cas, l'ordre dans lequel Java va effecter le calcul et l'évaluation de la valeur à assigner à la deuxième variable dépend du placement de l'opérateur `++` ou `--` :\n\n- Si l'opérateur se situe *après* la variable `x` , alors Java va d'abord évaluer la valeur actuelle de cette variable. Cette valeur sera assignée à la variable `y`, puis le calcul incrémental/décrémental sera effectué et la valeur de `x` changée\n\n```java\nint x = 0;\nint y = x++;\nprintln(x); // Affiche 1\nprintln(y); // Affiche 0\n```\n\n- Si l'opération se situe *avant* la variable `x`, c'est l'inverse. C'est d'abord l'incrémentation/décrémentation qui est faite, puis cette nouvelle valeur de `x` sera assignée à `y`.\n\n```java\nint x = 0;\nint y = ++x;\nprintln(x); // Affiche 1\nprintln(y); // Affiche 1\n```","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/03-tableaux-matrices":{"title":"03 - Tableaux et matrices","content":"\n## Tableaux\n\n### Définition\n\nUn **tableau** est une collection ordonnée de variables du même type. On accède a une variable du tableau grâce au nom du tableau et à la position de la variable dans celui-ci.\n\nUn tableau est un type de données au même titre que le sont `int`, `float`, etc. Il s'agit cependant d'un type dit *référentiel* et non primitif, car la variable de type tableau contient en réalité une référence vers un une suite de blocs en mémoire contenant les variables du tableau.\n\n### Stockage en mémoire\n\nLorsqu'un programme processing s'exécute, il possède sa propre mémoire dans laquelle seront stockées toutes les variables et tout ce qu'il se déroule dans le programme (appels de fonction, etc.). Cette mémoire se compose de deux parties :\n\n- La mémoire dite statique, le *stack*, qui contient notamment les variables (locales) de type primitif et des **références** vers des données stockées dans le *heap*\n- La mémoire dite dynamique, le *heap*, qui contient notamment des tableaux et des [objets](cours/09-classes.md)\n\n\u003cimg src=\"/stic/images/stack_heap_dm.svg\" class=\"svg-dark-mode\"/\u003e\n\u003cimg src=\"/stic/images/stack_heap_lm.svg\" class=\"svg-light-mode\"/\u003e\n\n\u003e ⚠ Le stockage en mémoire est en réalité plus complexe, l'important ici est de comprendre la différence entre une valeur et une référence. Pour plus de détails sur la gestion de la mémoire lors de l'exécution d'un programme Java, Google est votre ami.\n\n## Déclaration\n\nOn déclare un tableau comme on déclare une [variable](cours/01-variables-litteraux.md), à ceci près qu'il faut rajouter l'opérateur `[]` pour indiquer qu'il s'agit d'un tableau. On peut ajouter cet opérateur soit après le **type** de données du tableau, soit après son nom. Il s'agit de déclarations équivalentes.\n\n```java\nint[] integers;\n```\n\nou\n\n```java\nint integers[];\n```\n\nOn déclare ici une variable appelée `integers` qui est un tableau de nombres entiers.\n\n## Création\n\nIl existe deux façons de créer un tableau :\n\n1. On peut créer un tableau vide en indiquant sa taille, le nombre d'éléments qu'il contient.\n\n```java\nint[] integers = new int[6];\n```\n\n2. On peut créer un tableau en indiquant directement les valeurs qu'il contient entre `{}`. La taille du tableau sera donc le nombre d'éléments qu'on définit.\n\n```java\nint[] integers = new int[] { 1, 2, 4, 8, 16, 32 };\n```\n\nDans les deux cas, l'utilisation du mot clé `new` est obligatoire. Ce mot clé indique qu'on crée une nouvelle **référence** et est responsable de l'allocation en mémoire.\n\n## Manipulation\n\nUne fois un tableau déclaré et créé, on peut accéder à sa taille et aux différents éléments qu'il contient.\n\n### Taille du tableau\n\nLa taille d'un tableau **est déterminée à sa création et ne peut pas être changée**, on peut la récupérer grâce au champ spécial `length` du tableau, de la façon suivante :\n\n```java\nint[] integers = new int[] { 1, 2, 3 };\nprintln(integers.length); // Affiche 3\n```\n\n### Élements du tableau\n\nPour accéder à un élément particulier du tableau, il faut utiliser l'opérateur de tableau et l'indice de l'élément après le nom du tableau, par exemple `integers[1]`.\n\n\u003e ⚠ En informatique, on commence à compter à partir de 0. Le premier élément aura donc l'indice 0, le deuxième l'indice 1, ainsi de suite.\n\nLorsque l'on accède à un élément du tableau, on récupère une variable (celle stockée dans le heap), et on peut donc s'en servir comme tel ; c'est-à-dire lui assigner une valeur, ou l'évaluer dans des expressions.\n\n```java\nint[] integers = new int[] { 1, 2, 3 };\n\n// Evalue la variable à l'indice 0 dans le tableau et affiche 1\nprintln(integers[0]); \n\n// Assigne la valeur 0 à la variable à l'indice 1 dans le tableau\nintegers[1] = 0; \n\n// Evalue la variable à l'indice 1 dans le tableau et affiche 0\nprintln(integers[0]);\n\n// Evalue la variable à l'indice 2 dans le tableau et affiche 3\nprintln(integers[2]); \n```\n\n### Parcourir le tableau\n\nPour parcourir un tableau, c'est-à-dire pour *itérer* sur chacun de ces éléments, il faudra utiliser une boucle dont les explications sont disponibles dans la leçon [06 - Boucles](cours/05-boucles.md).\n\n### Erreurs\n\n- Lorsque l'on essaie d'accéder à un élément dont l'indice est supérieur à la taille du tableau, c'est-à-dire à une position **hors** du tableau, l'exécution du code provoquera une erreur du type `ArrayIndexOutOfBoundsException` avec l'indice auquel on a voulu accéder.\n\n\n## Matrices\n\n### Tableau de tableaux\n\nUn tableau étant un type de données, il est tout à fait possible de définir un tableau *de tableaux*, c'est-à-dire un tableau dont tous les éléments sont des références vers des tableaux d'un (même) type de données. On peut ainsi avoir un tableau de tableaux d'entiers (2 dimensions), un tableau de tableaux de tableaux de booléens (3 dimensions), etc. Tous les tableaux d'une même dimension auront la même taille, puisque la taille d'un tableau est statique et définie à sa création.\n\n\u003cimg src=\"/stic/images/matrix_dm.svg\" class=\"svg-dark-mode\"/\u003e\n\u003cimg src=\"/stic/images/matrix_lm.svg\" class=\"svg-light-mode\"/\u003e\n\nUne matrice est un tableau de tableaux : un tableau à deux dimensions, comme dans Excel, par exemple. On parlera ainsi de **lignes** pour la première dimension et de **colonnes** pour la deuxième dimension.\n\n### Déclaration\n\nPour déclarer une matrice, il faut simplement déclarer un tableau dont le type d'éléments est lui-même tableau, c'est-à-dire en rajoutant `[]` après le type d'éléments de ce tableau. Par exemple, un tableau de tableaux d'entiers sera noté `int[][]`. \n\n```java\nint[][] t1; // Tableau de tableaux d'entiers\nfloat[][] t2; // Tableau de tableaux de float\nboolean[][] t3; // Tableau de tableaux de booléens\n```\n\n### Création\n\nComme pour un tableau \"classique\", à une seule dimension, une matrice peut être créée de deux façons :\n\n1. On peut créer une matrice vide en indiquant la taille du tableau (le nombre de lignes), et la taille des tableaux se trouvant dans ce tableau principal (le nombre de colonnes) dans l'opérateur `[]`, un par dimension.\n\n```java\n// Tableau contenant 3 tableaux de 10 éléments chacun\nint[][] integers = new int[3][10]; \n```\n\nOn peut donc ainsi créer des tableaux de dimension complètement arbitraire :\n\n```java\nint[][][][][] whyNot = new int[3][6][9][6][3];\n```\n\n2. On peut créer une matrice en indiquant directement les valeurs qu'elle contient entre `{}`. Les accolades délimitent **un** tableau, et pour définir le contenu de la deuxième dimension, le contenu de chaque ligne, il faut aussi utiliser `{}`. Les tailles des tableaux seront alors déterminées automatiquement.\n\n```java\nint[][] integers = new int[][] { \n  { 1, 2, 3 }, // Première ligne\n  { 4, 5, 6 }, // Deuxième ligne\n  { 7, 8, 9 }  // Troisième ligne\n};\n```\n\n### Taille de la matrice\n\nPour la taille de la matrice, on parlera plus simplement de son nombre de lignes et de colonnes, qui sont, respectivement, la taille du tableau de la première dimension et la taille des tableaux de la deuxième dimension. On peut récupérer ces informations comme on le ferait pour un tableau quelconque.\n\n```java\nint[][] m = new int[][] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint nbLines = m.length;\nint nbColumns = m[0].length; // m[0] = première ligne\n```\n\n### Élements de la matrice\n\nOn accède aux **lignes** d'une matrice de la même façon qu'on manipule un tableau, avec l'opérateur `[]`, et aux éléments d'une ligne en réutilisant l'opérateur `[]` sur la ligne récupérée, puisqu'il s'agit également d'un tableau.\n\n```java\nint[][] m = new int[][] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint[] firstLine = m[0];\nint[] secondLine = m[1];\nint firstElementOfFirstLine = firstLine[0];\nint lastElementOfThirdLine = m[2][2];\n\nprintln(m[1][1]); // Affiche 5\nm[1][1] = 10;\nprintln(m[1][1]); // Affiche 10\n```\n\nOn parlera en général de coordonnées *i* et *j* des éléments dans la matrice :\n- i est l'indice de la ligne, à utiliser dans les premiers `[]`\n- j est l'indice de la colonne, à utiliser dans les deuxièmes `[]` (les crochets qui s'appliquent donc sur la ligne, le tableau, récupérée par les premiers crochets)\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/matrix_ix_dm.svg\" class=\"svg-dark-mode w-50\"/\u003e\n\u003cimg src=\"/stic/images/matrix_ix_lm.svg\" class=\"svg-light-mode w-50\"/\u003e\n\u003c/p\u003e\n\n### Parcourir une matrice\n\nPour parcourir une matrice, c'est-à-dire pour *itérer* sur chacun de ses éléments, il faudra utiliser des boucles imbriquées dont les explications sont disponibles dans la leçon [05 - Boucles](cours/05-boucles.md).","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/04-alternatives":{"title":"04 - Alternatives","content":"\n## Définition\n\nUne alternative, ou branchement conditionnel, est un *bloc de code* dont l'exécution est **optionnelle** et dépend d'une certaine **condition**, **une [expression](cours/02-expressions.md) booléenne** dans laquelle on retrouve en général des variables utilisées avant cette alternative.\n\n## Branchement `if` simple {id=\"branchementsimple\"}\n\nOn commence toujours une alternative par le mot clé `if` suivi de la condition entre parenthèses. Le code optionnel est le bloc de code compris entre les accolades `{}` venant après le `if`.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est à égal à 0\n  println(\"i est égal à 0\");\n}\n\nprintln(\"Après le if\");\n```\n\n## Branchement avec `else`\n\nLe mot clé `else` permet d'exécuter un bloc de code optionnel, différent, lorsque la condition du `if` le précédant n'est pas remplie. Il faut encore une fois mettre ce bloc de code entre accolades `{}`.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est à égal à 0\n  println(\"i est égal à 0\");\n} else {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i n'est pas égal à 0\n  println(\"i n'est pas égal à 0\");\n}\n\nprintln(\"Après le if/else\");\n```\n\n## Branchement multiple avec `else if`\n\nIl est possible de faire un branchement multiple avec différentes conditions, chacune ayant son propre bloc de code optionnel. Ce branchement multiple commence toujours par un `if`, et chaque branche conditionnelle supplémentaire est introduite via le mot clé `else if` suivi de la condition entre parenthèses.\n\nDès que la condition d'un des branchements est respectée, le bloc de code correspondant sera exécuté, et **on finit le branchement** ; on en sort et continue l'exécution du code suivant le branchement.\n\nDans le cas d'un branchement multiple, le branchement `else`, si présent, ne sera donc exécuté que lorsqu'aucune condition de tous les `if`/`else if` n'est remplie.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est à égal à 0\n  println(\"i est égal à 0\");\n} else if (i \u003e 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est strictement supérieur à 0\n  println(\"i est plus grand que 0\");\n} else {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i n'est ni égal, ni supérieur à 0\n  println(\"i n'est pas égal ni plus grand que 0\");\n}\n\nprintln(\"Après le if/else\");\n```\n\n\u003e ⚠ Enchaîner plusieurs branchements `if` n'est pas équivalent à un branche `if`/`else if`.  Dans le cas de `if` consécutifs, chaque branchement/condition sera évalué ; dans le cas d'un branchement multiple `if`/`else if`, l'évaluation des conditions s'arrête dès lors que la condition d'une des branches est respectée.\n\n## Branchements imbriqués\nOn parle d'*imbrication* lorsqu'on utilise un branchement conditionnel à l'intérieur d'un autre branchement conditionnel.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est à égal à 0\n  println(\"i est égal à 0\");\n} else if (i \u003e 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est strictement supérieur à 0\n  println(\"i est plus grand que 0\");\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n} else {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i n'est ni égal, ni supérieur à 0\n  println(\"i n'est pas égal ni plus grand que 0\");\n  if (i \u003c -5) {\n    println(\"i est plus petit que -5\");\n  }\n}\n\nprintln(\"Après le if/else\");\n```\n\n## Remarques\n\n### Blocs et indentation\nUn bloc de code est délimité par des accolades `{}`. Pour une meilleure lisibilité du code, il est important de penser à *indenter* chaque bloc, c'est à dire à le décaler (vers la droite) du bloc de code qui l'englobe. L'indentation est complètement optionnelle mais essentielle pour un code propre et lisible. \n\nOn peut ainsi facilement voir, dans le cas des branchements conditionnels, dans quelle branche se situe le bloc de code. Cela devient encore plus utile lorsqu'on a plusieurs `if` imbriqués.\n\n```java\nint i = int(random(-10, 10));\n\n// Peu lisible\nif (i \u003e 0) {\nprintln(\"i est plus grand que 0\");\nif (i \u003e 5) {\nprintln(\"i est plus grand que 5\");\n}\n}\n\n// Avec accolades\nif (i \u003e 0) {\n  println(\"i plus grand que 0\");\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n}\n```\n\n### Notation alternative\n\nLorsqu'un bloc de code conditionnel ne contient qu'une seule ligne de code *exécutable*, on peut se passer des accolades `{}`. \n\n```java\nint i = int(random(-10, 10));\n\n// Avec accolades\nif (i \u003e 0) {\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n}\n\n// Sans accolades\nif (i \u003e 0)\n  if (i \u003e 5)\n    println(\"i est plus grand que 5\");\n```\n\nComme on le voit ici, le `if` imbriqué et ce qu'il contient ne sont considérés que comme un seul bloc exécutable, et on peut donc se passer des accolades autour même s'il s'agit, visuellement, de plus qu'une seule ligne de code.\n\n\u003e ⚠ Pour éviter des problèmes, je conseille d'éviter cette notation et de toujours utiliser les accolades pour délimiter les blocs.\n\n\n","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/05-boucles":{"title":"05 - Boucles","content":"\n## Définition\n\nUne boucle est un *bloc de code* dont l'exécution est **optionnelle** et **répétée** tant que la **condition**, **une [expression](cours/02-expressions.md) booléenne**, est respectée. \n\nLa logique est similaire à celle d'un [branchement conditionnel simple](/cours/04-alternatives.md#branchementsimple), à la différence que dans un branchement conditionnel, on passe à la suite du code lorsqu'on finit l'exécution du bloc optionnel. Dans le cas d'une boucle, après une exécution du bloc optionnel, on revient à la condition qui est alors réévaluée pour éventuellement recommencer l'exécution du bloc de code.\n\n## Boucle `while`\n\nLa boucle de base est définie par l'utilisation du mot clé `while` suivi de la condition entre parenthèses et du bloc de code optionnel entre accolades `{}`. La structure est la même que pour le branchement simple `if`.\n\n```java\nint i = 0;\n\nwhile (i \u003c 5) {\n  println(i);\n  i += 1;\n}\n```\n\nLe code ci-dessus affichera donc successivement, dans la console :\n\n```bash\n0\n1\n2\n3\n4\n```\n\nPour qu'une boucle ait du sens, il faut que le code optionnel manipule et change la ou les variables impliquées dans la condition de cette boucle, sans quoi on pourrait créer des boucles \"infinies\" pour lesquells la condition est toujours vraie car indépendante du code de la boucle.\n\n```java\nint i = 0;\n\nwhile (i \u003c 5) { // i ne change pas et on ne sort jamais de la boucle\n  println(i);\n}\n```\n\n\n## Boucle `for`\n\n On utilise régulièrement des boucles pour répéter un certain nombre de fois un même bloc de code, et la condition de cette boucle ne représente donc que le nombre d'itérations voulues. Dans ce cas, il est parfois plus simple d'utiliser une autre boucle, la boucle `for`. Cette boucle se compose de trois parties :\n - L'initialisation d'une variable \"compteur\". Cette variable peut avoir déjà été déclarée dans le code, ou il peut s'agir d'une nouvelle variable déclarée uniquement dans le contexte de cette boucle\n - Une condition pour continuer à boucler. On veut en général que la variable compteur soit plus petite qu'une *borne* (le nombre de répétitions souhaitées).\n - Une itération, une assignation qui modifie la valeur de la variable compteur pour passer à l'étape suivante.\n\nLa boucle est donc de la forme *for (\\\u003cinitialisation\\\u003e; \\\u003ccondition\\\u003e; \\\u003cassignation\\\u003e) {  }*\n\n```java\n// Avec while\nint i = 0;\nwhile (i \u003c 5) {\n   println(i);\n   i++;\n}\n\n// La boucle for équivalente\nfor (int j = 0; j \u003c 5; j++) {\n  println(j);\n}\n```\n\n## Boucles imbriquées\n\nDe la même façon qu'on peut mettre des branchements conditionnels `if` dans d'autres branchements, et avoir donc des `if` imbriqués, on peut tout à fait mettre des boucles dans des boucles, des boucles dans des branchements conditionnels, des branchements conditionnels dans des boucles, etc.\n\n```java\nint i = 0;\nwhile (i \u003c 3) {\n  println(i);\n  int j = 0;\n  while (j \u003c 3) {\n    println(j);\n    j++;\n  }\n  i++;\n}\n```\n\nLe code ci-dessus affichera donc successivement, dans la console :\n\n```plain\n0\n0\n1\n2\n1\n0\n1\n2\n2\n0\n1\n2\n```\n\n## Parcourir des tableaux\nLes boucles sont particulièrement utiles lorsque l'on manipule des [tableaux](cours/03-tableaux-matrices). On peut utiliser une boucle pour parcourir tous les éléments du tableau et exécuter un bloc de code similaire pour chaque élément. Le plus simple est alors d'utiliser une boucle `for` qui itère sur chaque position dans le tableau, donc de `0`  à la taille du tableau - 1. Pour rappel, on peut obtenir la taille d'un tableau grâce au champ `length` de ce tableau.\n\n```java\nint[] t = new int[] { 1, 2, 3, 4, 5 };\n\nfor (int i = 0; i \u003c t.length; i++) {\n   println(t[i]);\n}\n```\n\nLe code ci-dessus parcoure ainsi tous les éléments du tableau et affiche leur valeur dans la console.\n\nEn définissant la borne supérieur comme étant la taille `length` du tableau, et non une valeur fixe (dans ce cas-ci on aurait pu mettre 5), le code fonctionnera peu importe la taille effective du tableau que l'on a créé avant la boucle, puisque la vraie taille sera toujours utilisée.\n\n## Parcourir des matrices\n\nGrâce aux boucles imbriquées, il est très facile de parcourir une matrice, un tableau de tableaux. On peut en effet itérer sur les lignes dans une boucle, et sur chaque colonne de cette ligne dans une boucle imbriquée, ou inversément (les colonnes puis les lignes par colonne).\n\nComme pour un tableau à une dimension, il est plus facile d'utiliser des boucles `for` que des boucles `while`. On choisit en général comme nom de variable compteur `i` pour la première dimension, les lignes, et `j` pour la deuxième, les colonnes. Ces noms sont tout à fait arbitraires et pourraient être changés, mais garder une certaine cohérence de nommage, comme utiliser le même nom pour les variables représentant des indices de ligne et pour celles représentant des indices de colonne, permet de naviguer plus aisément dans son propre code.\n\n```java\nint[][] m = new int[][] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint nbLines = m.length;\nfor (int i = 0; i \u003c nbLines; i++) {\n  // i va prendre successivement la position de chaque ligne\n  // On récupère le nombre de colonnes dans la ligne i\n  int nbColumns = m[i].length;\n  for (int j = 0; j \u003c nbColumns; j++) {\n  // On affiche la coordonnée (i,j) et la valeur de l'élément correspondant\n    println(i, j, m[i][j]);\n  }\n}\n```\n\nCe code affiche les coordonnées (ligne, colonne) de chaque élément de la matrice et la valeur de cet élément, en commençant par la première ligne et toutes ses colonnes, la deuxième ligne, etc. On verra donc, dans la console :\n\n```plain\n0 0 1\n0 1 2\n0 2 3\n1 0 4\n1 1 5\n1 2 6\n2 0 7\n2 1 8\n2 2 9\n```","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/06-fonctions":{"title":"06 - Fonctions","content":"\n## Définition\n\nUne fonction permet de définir un bloc de code **réutilisable** que l'on pourra **appeler** à n'importe quel moment dans le code.\n\n### Signature\n\nPour pouvoir appeler une fonction, il faut la déclarer en spécifiant :\n- Son **type** de retour (`int`, `float`, etc.) ou `void` si elle ne renvoie rien\n- Son **nom** ; à utiliser pour appeler la fonction\n- Ses **paramètres** ; leur type et leur nom\n\nEt le code de cette fonction entre accolades `{}` en respectant la syntaxe \n\n*\\\u003ctype\\\u003e \\\u003cnom\\\u003e(\\\u003ctype_p_1\\\u003e \\\u003cnom_p_1\\\u003e, ..., \\\u003ctype_p_n\\\u003e \\\u003cnom_p_n\\\u003e) { \n   // code\n}*\n\nUne fonction peut ne pas avoir de paramètres si on ne met rien dans les parenthèses, mais elles restent obligatoires.\n\nLe type de retour, le nom et le type des paramètres constituent ce qu'on appelle la **signature** d'une fonction. On ne peut pas créer deux fonctions ayant la même signature, le code affichera alors l'erreur `Duplicate method \u003csignature\u003e`.\n\n\u003eℹ L'ordre dans lequel les fonctions sont définies n'a pas d'importance\n\n## Appel et exécution\n\nUn **appel** à une fonction consiste à utiliser le nom de la fonction suivi de parenthèses avec, éventuellement, les valeurs à passer aux paramètres de cette fonction. \n\nIl faut obligatoirement appeler la fonction en respectant sa signature ; les valeurs passées doivent correspondre en nombre et en type aux paramètres définis dans la signature de la fonction qu'on appelle. Sinon, le code affichera une erreur du type `The function \"\u003cname\u003e\" expects parameters like: \u003csignature\u003e`.\n\nLorsque le programme arrive sur l'appel à la fonction, il exécutera le bloc de code de cette fonction dans un [contexte](cours/07-blocs-contextes) différent dans lequel ne seront disponibles que les variables globales et les paramètres de la fonction.\n\n```java\nvoid foo() {\n  println(\"foo\");\n}\n\nint bar(int i) {\n  return i * 2;\n}\n\nvoid setup() {\n  foo(); // Appelle la fonction foo, qui va afficher foo \n  println(bar(1)); // Affiche le résultat de l'appel à bar(1) : 2\n}\n```\n\nLorsque l'exécution du code est terminée, la ligne de code suivant celle de l'appel est la prochaine qui sera exécutée.\n\n\u003e ⚠ Pour qu'un code avec des fonctions et appels de fonction soit exécutable en processing, il est obligatoire de mettre les appels de fonction dans une des fonctions de processing (setup, draw, etc.) et pas dans le contexte global.\n\n## Retour de fonction\n\n### Fonctions avec retour\n\nUne fonction qui *retourne* ou *renvoie* une valeur doit avoir défini son type de retour, c'est-à-dire le type de la valeur qu'elle renvoie. Pour qu'une fonction retourne effectivement une valeur, il faut utiliser le mot clé `return` suivi d'une expression, dans la fonction. Cette expression sera renvoyée par l'appel à la fonction, et on pourra utiliser des appels à cette fonction dans d'autres expressions.\n\n```java\nint foo() {\n  return 1;\n}\n\nvoid setup() {\n  int i = foo() + 1;\n  println(i); // Affiche 2\n}\n```\n\nDans le code ci-dessus, on appelle la fonction `foo` qui renvoie une valeur de type `int`. On utilise un appel à cette fonction dans l'expression utilisée pour l'assignation à la variable `i`. L'appel à foo est évalué : le code est exécuté et la valeur renvoyée est 1 ; on effectue ensuite la somme de cette valeur et de 1, qui vaut 2, et on assigne ce résultat à la variable `i` qui va donc contenir 2.\n\nSi la fonction contient des branchements conditionnels, il est **obligatoire** que, peu importe la branche exécutée, on atteigne un `return`. En effet, il faut que la fonction renvoie **toujours** une valeur. Dans le cas contraire, le code affichera une erreur du type `This method must return a result of type x`.\n\n### Fonctions `void`\n\nUne fonction définie avec `void` comme \"type\" de retour est en réalité une fonction qui ne va rien retourner. Les appels à cette fonction ne peuvent donc pas être utilisés dans des expressions car ils ne peuvent pas être évalués. Les appels ne peuvent se faire que comme ligne exécutable simple :\n\n```java\nvoid foo() {\n  println(\"foo\");\n}\n\nvoid setup() {\n  foo();\n}\n```\n\n## Paramètres\n\nLes paramètres, ou arguments, d'une fonction, sont des variables utilisables dans le code de la fonction et pour lesquelles il faudra passer une valeur à chaque fois qu'on appelle la fonction. Le nom des paramètres est arbitraire mais une fonction est plus compréhensible lorsque ses paramètres sont nommés intelligemment.\n\n```java\nint square(int i) {\n  return i * i;\n}\n\nvoid setup() {\n  println(square(0)); // Affiche 0\n  println(square(1)); // Affiche 1\n  println(square(2)); // Affiche 4\n  println(square(3)); // Affiche 9\n}\n```\n\nOn définit une fonction `square` qui va nous permettre de calculer le carré d'un nombre. Ce nombre, *n'importe lequel*, on le représente par le paramètre `i`, de type entier. La fonction calcule ensuite le carré de cette variable, `i * i` et renvoie cette valeur. Nous n'avons besoin de valeurs pour ce paramètre que lorsque l'on appelle effectivement la fonction, comme on le fait plus loin : `println(square(2))` par exemple, affiche en console le résultat de l'appel à la fonction `square` où le paramètre `i` vaut 2. L'appel renverra donc le carré de 2 : 4.\n\n## Utilités\nUne fonction permet de ne définir qu'une seule fois un bout de code qui pourrait apparaître plusieurs fois : c'est ce qu'on appelle la *factorisation*. \n\nAvant factorisation :\n\n```java\nvoid setup() {\n  float a = random(0, 1);\n  if (a \u003c= 0.25) {\n    a = 0;\n  } else if (a \u003c= 0.75) {\n    a = 0.5;\n  } else {\n    a = 1;\n  }\n  println(a);\n  \n  float b = random(0, 1);\n  if (b \u003c= 0.25) {\n    b = 0;\n  } else if (b \u003c= 0.75) {\n    b = 0.5;\n  } else {\n    b = 1;\n  }\n  println(b);\n}\n```\n\nAprès factorisation :\n\n```java\nvoid setup() {\n  float a = roundToClosestHalf(random(0, 1));\n  println(a);\n\n  float b = roundToClosestHalf(random(0, 1));\n  println(b);\n}\n\nfloat roundToClosestHalf(float n) {\n  if (n \u003c= 0.25) {\n    n = 0;\n  } else if (n \u003c= 0.75) {\n    n = 0.5;\n  } else {\n    n = 1;\n  }\n  return n;\n}\n```\n\nL'utilisation de fonctions permet également d'améliorer la structure d'un programme, en définissant des fonctions aux responsabilités bien limitées et dont les noms, savamment choisis, peuvent améliorer la lisibilité du code. Comme on le voit plus haut, le nom donné à la fonction permet de comprendre facilement ce que le code fait.","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/07-blocs-contextes":{"title":"07 - Blocs et contextes","content":"\n## Blocs\n\nUn *bloc de code* est une série de lignes de code délimitée par des accolades `{}`. Ces blocs sont, comme vu précédemment, liés à des [branchements conditionnels](cours/04-alternatives), des [boucles](cours/05-boucles) ou des [fonctions](cours/06-fonctions.md). Chaque bloc a son propre *contexte*.\n\n## Contexte et portée\nLa *portée* d'une variable définit dans quel contexte celle-ci est visible par du code et donc utilisable. Chaque bloc a accès aux variables déclarées dans son propre contexte et à celles déclarées dans le contexte \"parent\" ou englobant.\n\n```java\nint i = 0;\nint j = 1;\n\nif (i == 0) {\n  // Début du contexte du if, on a accès aux variables i et j\n  int k = 2 * j; // La variable k est locale au contexte du if\n  println(k);\n}\n\n// A partir d'ici, k n'existe plus\n\n```\n\n\u003e ℹ Une indentation correcte du code permet de facilement voir les différents niveaux de contextes\n\n### Global\n\nLe contexte global est le contexte principal d'exécution du programme dans lequel on va retrouver des variables globales, des branchements, des boucles, des définitions de fonctions, etc.\n\n### Branchements et boucles\n\nLes contextes des branchements conditionnels et des boucles sont des \"sous\" contextes, des contextes englobés dans d'autres contextes. \n\nPour les boucles, chaque *itération* de la boucle est un contexte différent. Le contexte d'une itération prend fin quand on arrive au bout de l'exécution de cette itération.\n\n### Fonctions\n\nPour les fonctions, chaque *appel* de fonction est un contexte différent et **indépendant**, le contexte parent de l'appel de la fonction est le contexte global et non le bloc de code dans lequel se trouve l'appel à cette fonction. Les paramètres de la fonction sont également des variables locales à chaque appel de la fonction dont la valeur est celle qu'on a passée dans l'appel.\n\n```java\nint i = 1; // Variable globale\n\nif (i \u003e 0) {\n  int j = 1; // Variable locale\n  foo(j + i); // Appel de fonction\n}\n\nvoid foo(int k) {\n  int j = k; // Variable locale, le j dans le if n'est pas visible ici\n  println(i, j); // Affiche 1 2\n}\n```","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/08-recursivite":{"title":"08 - Récursivité","content":"\n## Définition\n\nOn dit de quelque chose qu'elle est *récursive* dès lors qu'elle s'utilise elle-même.\n\nUn exemple de récursivité assez connu est la mise en abîme, où on inclut dans une oeuvre l'oeuvre elle-même :\n\n![[cours/images/recursion.jpeg]]\n\n## Fonction récursive\n\nUne fonction est récursive si, dans le code de cette fonction, on retrouve un (ou plusieurs) appels à cette même fonction. Il s'agit alors de récursivité directe.\n\n```java\nvoid foo() {\n  if (random(0, 1) \u003e 0.5) {\n    println(\"Recursive call\");\n    foo();\n  }\n}\n```\n\nIl est également possible de faire de la récursivité en appelant indirectement une autre fonction qui elle-même, lors de son exécution, appelle la fonction de départ.\n\n```java\nvoid foo() {\n  if (random(0, 1) \u003e 0.5) {\n    println(\"Recursive call\");\n    bar();\n  }\n}\n\nvoid bar() {\n   foo();\n}\n```\n\n\n## Conditions d'arrêt\n\nQuand on définit une fonction récursive, il est impératif que cet appel récursif soit *conditionnel*. En effet, si l'appel récursif était toujours exécuté lors d'un appel à la fonction, on ne sortirait plus jamais du cycle d'appels. On parle alors de *conditions d'arrêt*, qui sont les situations dans lesquells il ne faut pas/plus faire d'appel récursif. \n\nCes conditions d'arrêt portent en général sur les paramètres de la fonction récursive, et chaque appel récursif doit inclure un changement dans la valeur de ces paramètres, de sorte que les conditions d'arrêt puissent avoir un résultat différent selon le contexte de l'appel.\n\n```java\nvoid foo() {\n  foo(); // Appel inconditionnel, foo() s'appelle sans cesse\n}\n\nvoid bar(int i) {\n  if (i \u003e 0) {\n    bar(i - 1); // Appel conditionnel avec évolution des paramètres\n  }\n}\n```\n\nIl pourrait aussi s'agir de variables globales, le principal étant que le *contexte* de chaque appel soit différent. S'il était similaire (les variables visibles par le contexte ont la même valeur) et que les conditions portent sur ces variables, on serait dans une situation de récursivité infinie, ce que l'ordinateur ne peut bien entendu pas gérer. Lorsque l'on crée une telle situation, souvent par erreur, le programme renverra une erreur du type `StackOverflowError`.\n\n## Stack d'appels\n\nComme vu précédemment, un appel de fonction s'exécute dans son propre contexte ; il en va de même pour les appels récursifs. Un appel récursif induit un nouveau contexte \"par-dessus\", masquant l'existant, celui de l'appel récursif précédant. Lorsque l'on arrive au bout de l'exécution du code d'un appel récursif, on revient au contexte précédant, ainsi de suite, jusqu'à sortir complètement de ce \"stack\", cet empilement d'appels récursifs et leur contexte. \n\nConsidérons la fonction récursive suivante.\n\n```java\nvoid foo(int i) {\n  println(i);\n  if (i \u003c 3) {\n    foo(i + 1);\n  }\n}\n```\n\nSi on appelle initialement la fonction en passant 0 en paramètre : `foo(0)`, l'exécution ressemblera à\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/recursion-dm.svg\" class=\"svg-dark-mode w-50\"/\u003e\n\u003cimg src=\"/stic/images/recursion-lm.svg\" class=\"svg-light-mode w-50\"/\u003e\n\u003c/p\u003e\n\nEt affichera en console\n\n```plain\n0\n1\n2\n3\n```\n\n## Construire une solution récursive\n\nSi on construit une solution récursive pour un certain problème, cela signifie qu'il faut parvenir, dans le code de la fonction, à résoudre une *petite* partie de ce problème de sorte qu'il reste un problème similaire mais plus petit, que l'on résoudra via l'appel récursif.\n\nPrenons par exemple un problème qui consiste à suivre une série de directions. La fonction récursive va extraire une partie du problème, la première direction à suivre, et la résoudre ; on suit la direction indiquée. Il reste maintenant toutes les autres directions à suivre, mais on peut, pour ce faire, appeler récursivement la fonction. La condition d'arrêt sera ici lorsqu'il n'y a plus de directions à suivre.\n\n```java\nvoid followDirections(int[] directions) { \n  if (directions.length \u003e 0) { \n    int firstDirection = directions[0]; \n    followDirection(firstDirection); \n\n    int[] remainingDirections = removeFirstElement(directions);\n    followDirections(remainingDirections);\n  }\n} \n\nvoid followDirection(int direction) { \n  // TODO \n  println(direction);\n} \n\nint[] removeFirstElement(int[] array) { \n  if (array.length \u003e 0) { \n    int[] newArray = new int[array.length - 1]; \n    for (int i = 1; i \u003c array.length; i++) { \n      newArray[i - 1] = array[i];\n    } \n    return newArray;\n  } else { \n    return new int[] {};\n  }\n}\n```","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/09-classes":{"title":"09 - Classes","content":"\n## Définition\n\nDans un langage *orienté objet* comme Java, on peut définir des *classes*. Une classe est un *prototype*, une maquette, représentant un concept souvent tiré du monde réel, et qui nous va permettre de plus facilement interagir avec ce concept.\n\nUn *objet* est une instance d'une classe, un cas concret correspondant au prototype défini.\n\nImaginons par exemple une classe `Human`, chaque personne serait alors une instance de cette classe, une *réalisation* de ce qui définit un humain.\n\n## Structure\n\n### Syntaxe\n\nPour définir une classe, il faut utiliser le mot clé `class` suivi du nom de la classe. C'est ce nom qui servira de *type* (au même titre que `int`, `float`, etc.) lorsque l'on déclarera une variable contenant une instance de cette classe. \n\nIl faut ensuite mettre tout ce qui constitue la classe entre accolades.\n\n\u003e ℹ En Java, on nomme habituellement une classe en commençant par une lettre majuscule, ce qui permet de la distinguer de simples variables, qui devraient commencer par une lettre minuscule.\n\n```java\nclass Human {\n\n  // Définition de la classe\n\n}\n```\n\nUne classe est généralement découpée en trois parties : les attributs, le constructeur et les méthodes.\n\n### Attributs\nLes *attributs* d'une classe sont des variables que l'on déclare dans cette classe et qui représentent des informations qu'auront toujours des instances de la classe. La valeur de ces variables changera bien entendu d'une instance à l'autre.\n\nPour notre classe `Human`, on aura par exemple un attribut `hungry` de type booléen, qui indique si une personne a faim.\n\n```java\nclass Human {\n\n  // Attributs\n  boolean hungry;\n\n}\n```\n\n### Constructeur\nLe *constructeur* est une sorte de fonction particulière qui permet d'instancier un nouvel objet de la classe. Cette \"fonction\" doit impérativement porter le même nom que la classe, et il ne faut pas définir un type de retour. On peut se dire que c'est parce que la valeur retournée par le constructeur sera toujours du type de la classe.\n\nLe constructeur d'une classe est donc responsable de l'initialisation d'un objet de cette classe, et c'est là qu'on initialise les différents attributs, soit avec une valeur fixe, soit avec une valeur passée en paramètre.\n\n\u003e ℹ On peut aussi initialiser les attributs quand on les déclare, comme pour des variables classiques\n\nIl est possible de définir plusieurs constructeurs tant que chaque constructeur a des paramètres différents ; on définit alors plusieurs façons différentes de créer un nouvel objet.\n\n```java\nclass Human {\n\n  // Attributs\n  boolean hungry;\n\n  // Constructeur par défaut\n  Human() {\n    hungry = false;\n  }\n\n  // Constructeur avec paramètre\n  Human(boolean tempHungry) {\n    hungry = tempHungry;\n  }\n\n}\n```\n\n\u003e ℹ Si on ne définit pas explicitement de constructeur, c'est comme si on avait défini un constructeur sans paramètre qui ne fait rien.\n\n### Instance `this`\nLes constructeurs paramétrés utilisent en général des paramètres correspondant aux différents attributs, et on aurait tendance à vouloir les nommer de la même façon que les attributs pour savoir facilement à quoi ils correspondent. En ce faisant, on perd cependant la visibilité sur l'attribut du même nom :\n\n```java\nclass Human {\n\n  // Attributs\n  boolean hungry;\n\n  // Constructeur par défaut\n  Human() {\n    hungry = false;\n  }\n\n  // Constructeur avec paramètre\n  Human(boolean hungry) {\n    // Le nom hungry visible est celui du paramètre !!\n    hungry = hungry; // Ne fait rien\n  }\n\n}\n```\n\nPour accéder explicitement à un attribut de la classe, on peut utiliser le mot clé `this`. Ce mot clé représente en quelque sorte l'instance de la classe sur laquelle on travaille, même si elle n'existe pas encore. Depuis ce `this`, on peut accéder à tous les attributs et aux méthodes avec la syntaxe this.\\\u003cattribut\\\u003e ou this.\\\u003cméthode\\\u003e. On peut ainsi utiliser la variable locale `hungry` pour mettre sa valeur dans l'attribut correspondant de l'instance `this.hungry` :\n\n```java\nclass Human {\n\n  // Attributs\n  boolean hungry;\n\n  // Constructeur par défaut\n  Human() {\n    hungry = false;\n  }\n\n  // Constructeur avec paramètre\n  Human(boolean hungry) {\n    this.hungry = hungry;\n  }\n\n}\n```\n\nL'utilisation du `this` n'est pas obligatoire lorsque le nom d'un attribut n'est pas caché par celui d'un paramètre, mais c'est parfois plus facile de l'utiliser pour rendre plus visible que la variable ou la fonction qu'on utilise est définie dans la classe ; qu'il s'agit donc d'un attribut ou d'une méthode.\n\n### Méthodes\n\nLes *méthodes* sont des [fonctions](cours/06-fonctions.md) internes à la classe qui représentent des comportements, des choses qu'il est sensé de faire pour le concept représenté par la classe. Lorsque l'on appelle une méthode d'une classe, comme on appelle une fonction, l'exécution se passe dans un contexte particulier propre à l'instance et dans lequel on a accès à tous les attributs de l'objet (`this`).\n\nToujours pour notre `Human`, on va définir une méthode `eat`, qui ne renvoie rien, donc `void`, et ne prend aucun paramètre. Cette fonction met à jour l'attribut `hungry` pour lui mettre la valeur `false`, car l'humain n'a plus faim après avoir mangé. \n\n```java\nclass Human {\n\n  // Attributs\n  boolean hungry;\n\n  // Constructeur par défaut\n  Human() {\n    hungry = false;\n  }\n\n  // Constructeur avec paramètre\n  Human(boolean hungry) {\n    this.hungry = hungry;\n  }\n\n  void eat() {\n    println(\"nom nom nom\");\n    hungry = false;\n  }\n\n}\n```\n\n## Objets\n### Déclaration\nLes *objets* sont des instances d'une classe, et on va les stocker comme on stockerait des valeurs entières, flottantes, etc. : dans des variables. Le *type* d'une variable contenant un objet sera le nom de la classe.\n\n```java\nHuman human; // Variable qui contiendra un objet de la classe Human\n```\n\n### Création\n\nLes objets, comme les [tableaux](cours/03-tableaux-matrices.md), sont des *références*, et pour créer des références, il faut utiliser le mot clé `new`, ici suivi de l'appel à un constructeur de la classe.\n\n```java\nHuman human = new Human(); // Constructeur vide\nHuman anotherHuman = new Human(true); // Constructeur explicite, cet humain a faim\n```\n\n### Manipulation\n\nPour manipuler ou interagir avec un objet, il faut utiliser le `.` après le nom de l'objet, comme si on \"entrait\" dans ce qu'il contient : ses attributs et ses méthodes. Après le `.`, on peut donc soit mettre le nom d'un attribut, pour en évaluer sa valeur ou le modifier, soit appeler une méthode de l'objet.\n\n```java\nHuman human = new Human();\nprintln(human.hungry); // Affiche si l'humain a faim -\u003e false par défaut\nhuman.hungry = true; // On met à jour l'attribut;\nprintln(human.hungry); // Affiche true\nhuman.eat(); // Appel de la méthode eat de notre humain\nprintln(human.hungry); // Affiche false\n```\n\n\u003e ℹ On préfère en général éviter d'interagir directement avec les attributs d'un objet, mais de passer plutôt par des méthodes, par exemple `human.setHungry(true)`\n\n### `null`\n\nSi on n'initialise pas une variable objet, la référence n'est pas définie et est alors `null`. Cela signifie que la variable ne contient rien. On peut également \"supprimer\" la valeur contenue dans une variable objet en lui assignant la valeur `null`.\n\n```java\nHuman human = new Human();\nhuman.eat(); // Affiche nom nom nom\nhuman = null; // Supprime l'humain référencé\n```\n\nLorsque l'on essaie d'interagir avec une variable objet, soit en accédant à un de ses attributs, soit en appelant une méthode, mais que la variable ne contient rien, donc `null`, on aura une erreur du type `NullPointerException`.\n\n## Listes d'objets\n\nSi l'on doit manipuler un grand nombre d'objets du même type, il y a deux solutions possibles :\n- Ce nombre est fixe, on peut alors utiliser un tableau ; par exemple `Human[] humans = new Human[10];`\n- Ce nombre est variable et est amené à changer (nouveaux éléments, éléments en moins) pendant l'exécution du code. Dans ce cas, on peut utiliser une `ArrayList`, qui représente donc une liste d'éléments de taille variable.\n\n### ArrayList\n\n#### Création\nPour déclarer une [`ArrayList`](https://processing.org/reference/ArrayList.html) d'un certain type d'objets, il faut spécifier ce type entre `\u003c\u003e` :\n\n```java\nArrayList\u003cHuman\u003e humans = new ArrayList\u003cHuman\u003e();\n```\n\nOn crée ici une liste initialement vide dans laquelle on pourra rajouter des objets.\n\n\u003e ℹ Vous remarquez l'utilisation du mot clé `new` pour la création de la liste ; ArrayList est une *classe* existante en Java.\n\n#### Manipulation\n\nLa manipulation de la liste se fait via l'appel à différentes méthodes sur cette liste :\n\n- `add(object)` qui prend en paramètre un objet du type d'éléments de la liste, et ajoute cet élément \"à la fin\" de la liste\n- `get(i)` qui prend en paramètre l'indice d'un élément, et renvoie l'élément se trouvant à cette place dans la liste\n- `remove(i)` qui prend en paramètre l'indice d'un élément et le supprime de la liste\n- `size()` qui renvoie le nombre d'éléments que contient la liste\n- `set(i, object)` qui prend en paramètre un indice et un objet et remplace l'élément à cet indice dans la liste par l'objet passé en paramètre\n\n```java\nArrayList\u003cHuman\u003e humans = new ArrayList\u003cHuman\u003e();\nhumans.add(new Human(true));\nhumans.add(new Human());\nhumans.add(new Human());\nprintln(humans.size()); // Affiche 3\nprintln(humans.get(0).hungry); // Affiche true\nhumans.get(0).eat();\nprintln(humans.get(0).hungry); // Affiche false\nhumans.remove(2);\nhumans.remove(1);\nprintln(humans.size()); // Affiche 1\nhumans.set(0, new Human(true));\nprintln(humans.get(0).hungry); // Affiche true\n```\n\n#### Erreurs\n\nComme pour les tableaux, si on essaie d'accéder à un élément hors du tableau, c'est-à-dire à une position plus grande que sa taille, on aura une erreur du type `IndexOutOfBoundsException`.\n\n## Utilité\n\n### Structure\n\nComme pour les fonctions, définir des classes permet souvent de mieux structurer le code et de lui donner plus de \"sens\" proche du réel. Une classe permet d'isoler du code spécifique à un concept précis, et de ne pas le perdre au milieu du reste.\n\n### Factorisation\n\nDéfinir une classe permet de simplifier le code lorsqu'on se sert de plusieurs instances d'un même concept car, que l'on utilise des classes ou non, ces concepts sont présents dans le code.\n\nImaginons par exemple qu'on ait besoin de définir 20 cercles pour les dessiner ; il nous faut leurs coordonnées (x, y) et leur couleur. Sans classe, il faudrait utiliser trois tableaux, un par information liée à un cercle.\n\n```java\nint[] circlesX;\nint[] circlesY;\ncolor[] circlesColor;\n\nvoid setup() {\n  circlesX = new int[20];\n  circlesY = new int[20];\n  circlesColor = new color[20];\n  \n  for (int i = 0; i \u003c 20; i++) {\n    circlesX[i] = int(random(0, 100));\n    circlesY[i] = int(random(0, 100));\n    circlesColor[i] = randomColor();\n  }\n}\n\ncolor randomColor() {\n return color(int(random(0, 256)), \n              int(random(0, 256)), \n              int(random(0, 256)));\n}\n```\n\nEn définissant une classe représentant ces cercles, on simplifie le code tout en le rendant plus lisible :\n\n```java\nclass Circle {\n  int x;\n  int y;\n  color c;\n\n  Circle(int x, int y, color c) {\n    this.x = x;\n    this.y = y;\n    this.c = c;\n  }\n}\n\nCircle[] circles;\n\nvoid setup() {\n  circles = new Circle[20];\n  for (int i = 0; i \u003c 20; i++) {\n    circles[i] = new Circle(int(random(0, 100)), \n                            int(random(0, 100)),\n                            randomColor());\n  }\n}\n\ncolor randomColor() {\n return color(int(random(0, 256)), \n              int(random(0, 256)), \n              int(random(0, 256)));\n}\n```\n\n\u003e ⚠ Un code plus simple ne veut pas nécessairement dire plus court. Le code est plus simple car il ne faut plus interagir qu'avec un seul tableau, le tableau d'objets, plutôt qu'avec autant de tableaux qu'on aurait d'attributs dans ces objets.","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/10-strings":{"title":"10 - Strings","content":"\n## Définition\n Un **string** est un type de données particulier permettant de contenir une chaîne de caractères, du texte. Il ne s'agit pas d'un type primitif comme `int`, `float`, etc. mais d'une [classe](cours/09-classes.md) `String` existante dans le langage Java de base.\n\nComme toute variable, on déclare un string en indiquant son type, `String`, et le nom de la variable. En Java, une chaîne de caractères est délimitée par des guillemets. Ainsi, toute valeur entre `\" \"` sera évaluée par processing comme étant du type `String`.\n\n```java\nString s = \"Hello World!\";\nprintln(s); // Affiche Hello World!\n```\n\n### Objets et littéraux\n\nBien que `String` soit une classe, Java permet d'utiliser des littéraux de type `String` : des chaînes de caractères entre guillements `\"`. Ces littéraux sont stockés différemment que les objets en mémoire, de façon centrale, de sorte qu'une même chaîne de caractères utilisée plusieurs fois soit un seul littéral en mémoire.\n\n```java\nprintln(\"abc\" == \"abc\"); // Affiche true\nprintln(\"abc\" == \"bcd\"); // Affiche false\n```\n\nIl est par contre possible de créer explicitement un objet de type `String` via le constructeur en utilisant un littéral en paramètre. Il s'agit alors d'un objet à part entière qui sera stocké dans la mémoire heap, et deux objets `String` qui contiennent la même chaîne de caractères seront différents.\n\n```java\nString s1 = \"Hello\";\nString s2 = new String(\"Hello\");\nprintln(s1 == \"Hello\"); // Affiche true\nprintln(s2 == \"Hello\"); // Affiche false\n```\n\n\n## Manipulation\n\n### Concaténation\n\nLa **concaténation** est une opération qui permet de combiner deux chaînes de caractères via l'opérateur `+`. Les deux chaînes de caractères seront alors mises \"bout à bout\" pour n'en former qu'une.\n\n```java\nString s1 = \"Hello \";\nString s2 = \"World\";\nString s3 = s1 + s2;\nprintln(s); // Affiche Hello World\n```\n\nComme toute opération simple, on peut l'utiliser plusieurs fois dans une même expression, ce qui permet de construire facilement des chaînes de caractères en combinant des variables de type `String`  et des littéraux.\n\n```java\nString s1 = \"Hello\";\nString s2 = \"World\";\nprintln(s1 + \" \" + s2 + \"!\");\n```\n\n#### Concaténation avec un autre type\n\nOn peut concaténer une chaîne de caractères avec une valeur d'un autre type, cette valeur sera alors convertie automatiquement par processing en une chaîne de caractères correspondant à son contenu.\n\n```java\nString s = \"Number \";\nint i = 5;\nprintln(s + i); // Affiche Number 5\n```\n\n\n### Comparaison\n\nComme on peut avoir des objets ou des littéraux `String`, et que les comparaisons classiques avec `==` et `!=` ne se comporteront pas forcément de la façon à laquelle on s'attend, comme expliqué plus haut, il est préférable de se servir des méthodes `compareTo` et `equals`.\n\n#### `compareTo`\n\nLa méthode `compareTo` disponible sur un `String` permet de comparer la chaîne de caractères de ce `String` avec celle passée en paramètre. La méthode renvoie un nombre entier :\n- Positif si le premier `String` est \"plus grand\" que le second, dans l'ordre croissant\n- Négatif si le premier `String` est \"plus petit\" que le second, dans l'ordre croissant\n- 0 si les deux `String` contiennent la même chaîne de caractères.\n\n```java\nString abc = \"abc\";\nString bcd = \"bcd\";\nprintln(abc.compareTo(bcd)); // Affiche -1\nprintln(bcd.compareTo(abc)); // Affiche 1\nprintln(abc.compareTo(\"abc\")); // Affiche 0\n```\n\n#### `equals`\n\nLa méthode `equals` disponible sur un `String` permet de savoir si ce `String` contient la même chaîne de caractères qu'un autre `String`, utilisé en paramètre. Cette méthode renvoie donc le booléen `true` si les deux `String` contiennent la même chaîne de caractères, ou `false` dans le cas contraire.\n\n```java\nString abc = \"abc\";\nString bcd = \"bcd\";\nprintln(abc.equals(bcd)); // Affiche false\nprintln(abc.equals(\"abc\")); // Affiche true\n```\n\n### Méthodes utiles\n\n#### `length`\n\nOn peut récupérer la taille d'une chaîne de caractères en appelant la fonction `length` sur cette chaîne de caractères.\n\n```java\nString s1 = \"Hello\";\nString s2 = \":D\";\nprintln(s1.length()); // Affiche 5\nprintln(s2.length()); // Affiche 2\n```\n\n#### `split`\n\nLa méthode `split` permet de scinder une chaîne de caractères sur base d'un séparateur, une chaîne de caractères à passer en paramètre. Le `split` renvoie un tableau de `String` correspondant aux différentes parties de la chaîne initiale qui étaient séparées par le séparateur. Par exemple, utiliser `split(\" \")` permet de couper une phrase sur les espaces et de récupérer un tableau de mots.\n\n```java\nString s = \"Hello World!\";\nString[] parts = s.split(\" \");\nprintln(parts.length); // Affiche 2\nprintln(parts[0]); // Affiche Hello\nprintln(parts[1]); // Affiche World!\n```\n\n#### `charAt`\n\nLa méthode `charAt` permet de récupérer le caractère (type `char`) se trouvant à l'indice passé en paramètre.\n\n```java\nString s = \"Hello World!\";\nchar h = s.charAt(0);\nchar d  = s.charAt(10);\nprintln(h); // Affiche H\nprintln(d); // Affiche d\n```\n\n#### `substring`\n\nLa méthode `substring` permet de récupérer une partie de la chaîne de caractères initiale. On peut appeler cette méthode de deux façons :\n\n- Avec un seul paramètre de type entier, qui est l'indice du caractère à partir duquel on veut la sous-chaîne de caractères, qui ira jusqu'à la fin de la chaîne de caractères initiale\n```java\nString s = \"Hello World!\";\nString world = s.substring(6);\nprintln(world); // Affiche World!\n```\n- Avec deux paramètres de type entier ; le premier est toujours l'indice du premier caractère de la sous-chaîne voulue, et le deuxième est l'indice du caractère (non-compris) de fin de la sous-chaîne\n```java\nString s = \"Hello World!\";\nString hello = s.substring(0, 5);\nprintln(hello); // Affiche Hello\n```\n","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/11-bases-processing":{"title":"11 - Bases de Processing","content":"\n## Fonctions processing\n\u003e ⚠ Ce qui suit n'inclut qu'une partie de ce que peut faire processing. Pour les informations complètes, veuillez vous référer à la documentation officielle : [https://processing.org/reference](https://processing.org/reference)\n\n### Initialisation `setup`\n\nTout dessin processing complexe, c'est-à-dire qui va utiliser des fonctions, doit définir la fonction [`setup`](https://processing.org/reference/setup_.html) qui commence par définir la taille de la fenêtre :\n- Plein écran, en appelant la fonction [`fullScreen()`](https://processing.org/reference/fullScreen_.html)\n- Taille fixe, en appelant la fonction [`size(w, h)`](https://processing.org/reference/size_.html) où `w` et `h` seront des valeurs entières correspondant à la largeur et à la hauteur voulues.\n\n```java\nvoid setup() {\n  size(800, 600);\n\t\n}\n```\n\nC'est également dans le [`setup`](https://processing.org/reference/setup_.html) qu'on va configurer les paramètres globaux du dessin comme :\n- Le framerate, le nombre de frames par seconde, via la fonction [`frameRate(x)`](https://processing.org/reference/frameRate_.html) où x sera la valeur souhaitée. Par défaut, le framerate est 60.\n- Des spécifités du dessin qui ne changeront pas ([`noStroke()`](https://processing.org/reference/noStroke_.html), etc.)\n\n### Boucle principale `draw`\n\nLa \"boucle principale\" est une boucle implicite qui permet de passer à l'étape suivante du code. En processing, cette boucle principale est la fonction [`draw`](https://processing.org/reference/draw_.html), et une étape est une *frame* du dessin. C'est donc de cette fonction que partira la majorité de la logique du code : la représentation, le dessin, et l'évolution des données.\n\n```java\nvoid draw() {\n\n}\n```\n\nLa fonction [`draw`](https://processing.org/reference/draw_.html) est appelée automatiquement par processing *x* fois par seconde selon le framerate défini, il ne faut donc **pas** appeler soi-même cette fonction.\n\n### Réactions aux entrées\n\nLes différentes entrées possibles en processing sont accessibles via des fonctions qui seront appelées quand l'évènement correspondant survient, entre deux appels de [`draw`](https://processing.org/reference/draw_.html). Il ne faut définir chaque fonction qu'une seule fois.\n\n\u003e ⚠ Les réactions aux entrées ne fonctionnent que pour les dessins animés, c'est-à-dire les dessins pour lesquels on a défini le [`draw`](https://processing.org/reference/draw_.html)\n\n### Clavier\n\nPour une entrée clavier, il y aura toujours deux événèments :\n- [`keyPressed()`](https://processing.org/reference/keyPressed_.html) quand on appuie sur la touche du clavier\n- [`keyReleased()`](https://processing.org/reference/keyReleased_.html) quand on relâche la touche\n\n\u003e ⚠ Maintenir une touche du clavier enfoncée peut provoquer plusieurs appels consécutifs à [`keyPressed`](https://processing.org/reference/keyPressed_.html) mais ce comportement et la fréquence à laquelle l'évènement est produit dépendent du système d'exploitation. Par conséquent, utiliser [`keyPressed`](https://processing.org/reference/keyPressed_.html) pour bouger des parties du dessin (comme un personnage) causera des mouvements saccadés, moins fluides que si l'évolution des coordonnées était réalisée dans le [`draw`](https://processing.org/reference/draw_.html). \n\n### Souris\n\nPour une entrée souris, il y aura toujours les évènements :\n- [`mousePressed()`](https://processing.org/reference/mousePressed_.html) quand on appuie sur la touche de la souris\n- [`mouseReleased()`](https://processing.org/reference/mouseReleased_.html) quand on relâche la touche\n- [`mouseClicked()`](https://processing.org/reference/mouseClicked_.html) après avoir appuyé et relâché une touche\n\n### Exécution d'un dessin processing\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/processing-loop-dm.svg\" class=\"svg-dark-mode w-50\"/\u003e\n\u003cimg src=\"/stic/images/processing-loop-lm.svg\" class=\"svg-light-mode w-50\"/\u003e\n\u003c/p\u003e\n\n## Variables processing\n- `width` et `height` contiennent la largeur et la hauteur de la fenêtre processing, disponibles indéfiniment après l'appel de `size`  ou `fullScreen` dans le `setup`\n- `frameCount` contient le numéro de la frame actuellement dessinée par `draw`. Commence à 1.\n- `frameRate` contient le nombre de frames par seconde défini par la fonction `frameRate(x)`, ou 60 par défaut.\n- `mouseX` et `mouseY` contiennent les coordonnées (x,y) de la position du curseur de la souris dans le dessin\n- `pmouseX` et `pmouseY` contiennent les coordonnées (x,y) de la position du curseur dans la frame précédente.\n- `keyCode` contient une représentation codifée de la touche sur laquelle on vient d'appuyer : par exemple `ENTER`. Toutes les touches ne sont pas codifiées.\n- `key` contient le caractère correspondant à la touche sur laquelle on vient d'appuyer : par exemple `' '` pour la touche espace.\n- Des constantes correspondant à des \"codes\", comme pour les touches standards du clavier (`ENTER`, `LEFT`, `RIGHT`, etc.)\n\n## Imprimer en console\nPour afficher des informations dans la console de processing, il existe plusieurs fonctions :\n- [`println`](https://processing.org/reference/println_.html) qui prend en paramètres un nombre arbitraire de chaînes de caractères et les affichera sur une ligne séparés par un espace, puis fait un retour à la ligne dans la console\n\t- `println()` fera juste un retour à la ligne dans la console\n\t- `println(\"a\")` imprimera `a` en console puis fera un retour à la ligne\n\t- `println(\"a\", \"b\", \"c\", \"d\", \"e\")` imprimera `a b c d e` en console puis fera un retour à la ligne\n- [`print`](https://processing.org/reference/print_.html) qui est similaire à [`println`](https://processing.org/reference/println_.html) à la différence qu'il ne fait pas de retour à la ligne à la fin. En conséquence, si on imprime par la suite quelque chose d'autre dans le code, ce sera sur la même ligne qu'avant.\n- [`printArray`](https://processing.org/reference/printArray_.html) qui prend en paramètre un [tableau](cours/03-tableaux-matrices.md) et affiche ses éléments (un par ligne) en console","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/12-dessins-geometrie":{"title":"12 - Dessins et géometrie","content":"\n## Fenêtre\n\nLa fenêtre de processing est un repère à deux dimensions dans lequel une coordonnée *(x, y)* correspond à un pixel. L'axe horizontal, des x, croît de gauche à droite et l'axe vertical, des y, croît de bas en haut. L'origine *(0,0)* de ce repère est donc le coin supérieur gauche de la fenêtre.\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/grid-processing-dm.svg\" class=\"svg-dark-mode w-50\"/\u003e\n\u003cimg src=\"/stic/images/grid-processing-lm.svg\" class=\"svg-light-mode w-50\"/\u003e\n\u003c/p\u003e\n\n## Dessins\n\n### Couleurs\nProcessing permet de travailler sur deux échelles de couleur différentes :\n- En noir et blanc ; la couleur est alors une valeur entière entre 0 (noir) et 255 (blanc)\n\n```java\nint black = 0;\nint middleGrey = 122;\nint white = 255;\n```\n\n- En couleur ; la couleur est alors une valeur de type `color` contenant trois valeurs entières allant de 0 à 255 pour les composantes rouge, verte et bleue. On peut créer des couleurs grâce à la fonction [`color(r, g, b)`](https://processing.org/reference/color_.html) qui prend les valeurs des composantes en paramètre, ou en utilisant directement la notation hexadécimage d'une couleur.\n\n```\ncolor red = color(255, 0, 0);\ncolor green = color(0, 255, 0);\ncolor blue = color(0, 0, 255);\ncolor black = color(0, 0, 0);\ncolor white = color(255, 255, 255);\ncolor someColor = color(13, 201, 154);\ncolor fromHex = #ffffff;\n```\n\nSoit une couleur RGB, de type `color`, on peut récupérer la valeur de chacune des composantes R, G, B, grâce aux fonctions [`red`](https://processing.org/reference/red_.html), [`green`](https://processing.org/reference/green_.html), [`blue`](https://processing.org/reference/blue_.html) :\n\n```java\ncolor c = #FF10AA;\nfloat r = red(c); // 255\nfloat g = green(c); // 16\nfloat b = blue(c); // 170\n```\n\nOn peut utiliser une couleur pour définir :\n- La couleur du fond de la fenêtre via la fonction [`background`](https://processing.org/reference/background_.html)\n- La couleur des *traits* (lignes) via la fonction [`stroke`](https://processing.org/reference/stroke_.html) \n- La couleur de *remplissage* des formes géométriques et du texte via la fonction [`fill`](https://processing.org/reference/fill_.html)\n\nL'appel à background remplit le fond avec la couleur passée en paramètre en *effaçant* tout ce qui a été dessiné jusqu'à présent.\n\nQuand on appelle [`stroke`](https://processing.org/reference/stroke_.html) ou [`fill`](https://processing.org/reference/fill_.html), la couleur ne changera pas jusqu'à ce qu'on appelle à nouveau cette fonction avec une autre valeur.\n\n```java\nbackground(255); // Fond blanc\n\nstroke(0); // A partir d'ici, les traits sont noirs\nfill(color(255, 0, 0)); // A partir d'ici, le remplissage est en rouge\n\n// On dessine\n\nstroke(color(0, 255, 0)); // A partir d'ici, les traits sont verts\nfill(0); // A partir d'ici, le remplissage est noir\n\n// On dessine d'autres choses\n```\n\nAlternativement, on peut aussi dire à processing de ne *pas* coloriser les traits ou le remplissage, en appelant respectivant [`noStroke()`](https://processing.org/reference/noStroke_.html) ou [`noFill()`](https://processing.org/reference/noFill_.html). \n\nEnfin, on peut également appliquer un certain niveau d'opacité en rajoutant un paramètre aux appels de [`background`](https://processing.org/reference/background_.html),  [`stroke`](https://processing.org/reference/stroke_.html) et [`fill`](https://processing.org/reference/fill_.html). Ce paramètre est le niveau d'opacité allant de 0 (complètement opaque) à 255 (complètement transparent).\n\n```java\nbackground(0, 255); // Fond noir complètement opaque\nstroke(0, 122); // Trait noir à 50% d'opacité\nfill(color(255, 0, 0), 51); // Remplissage rouge à 20% d'opacité\n```\n\n### Points et lignes\n\nEn processing, on peut dessiner un *point*, un pixel, grâce à la fonction [`point`](https://processing.org/reference/point_.html) qui prend en paramètre les coordonnées x et y du point.\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(255);\n  stroke(0);\n\n  point(10, 10); // Dessine un point noir en (10, 10)\n}\n```\n\nOn peut dessiner une ligne grâce la fonction [`line`](https://processing.org/reference/line_.html) qui prend en paramètres les coordonnées des points aux deux extrémités de la ligne.\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(255);\n  stroke(0);\n\n  line(0, 0, width, height); // Dessine une ligne diagonale\n  line(width, 0, 0, height); // Dessine l'autre ligne diagonale\n}\n```\n\n### Rectangles\n\nOn dessine des rectangles grâce à la fonction [`rect`](https://processing.org/reference/rect_.html) qui prend toujours 4 paramètres. Ce que *sont* ces paramètres dépend du mode de dessin des rectangles ; il existe 4 modes différents :\n\n- `CORNER` : on indique les coordonnées *(x, y)* du coin supérieur gauche, la largeur *w* et la hauteur *h* du rectangle\n- `CORNERS` : on indique les coordonnées *(x1, y1)* d'un coin et les coordonnées *(x2, y2)* du coin opposé\n- `CENTER` : on indique les coordonnées *(x, y)* du centre du rectangle, la largeur *w* et la hauteur *h*\n- `RADIUS` : indique les coordonnées *(x, y)* du centre du rectangle, la moitié de la largeur *w* et la moitié de la hauteur *h* \n\nOn définit le mode de dessin en appelant la fonction [`rectMode`](https://processing.org/reference/rectMode_.html) avec le mode souhaité. Le mode `CORNER` est le mode par défaut.\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/rect-dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/rect-lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(0);\n  stroke(255);\n  fill(255);\n\n  // Dessinons le même rectangle avec chaque mode\n\n  rectMode(CORNER);\n  rect(20, 20, 100, 50);\n\n  rectMode(CORNERS);\n  rect(20, 20, 120, 70);\n\n  rectMode(CENTER);\n  rect(70, 45, 100, 50);\n\n  rectMode(RADIUS);\n  rect(70, 45, 50, 25);\n}\n```\n\nPeu importe le mode, les informations à passer à la fonction pour dessiner un rectangle nous permettent toujours d'obtenir toutes les autres informations du rectangle : les coordonnées de tous ses coins, de son centre, sa largeur et sa hauteur.\n\n- `CORNER`, soit les coordonnées *(x, y)* du coin supérieur gauche, la largeur *w* et la hauteur *h* :\n\t- Le coin supérieur droit est *(x + w, y)*\n\t- Le coin inférieur gauche est *(x, y + h)*\n\t- Le coin inférieur droit est *(x + w, y + h)*\n\t- Le centre du rectangle est *(x + w / 2, y + h / 2)*\n\n\n- `CORNERS`, soit les coordonnées *(x1, y1)* du coin supérieur gauche et les coordonnées *(x2, y2)* du coin inférieur droit :\n\t- Le coin supérieur droit est *(x2, y1)*\n\t- Le coin inférieur gauche est *(x1, y2)*\n\t- La largeur *w* est égale à *x2 - x1*\n\t- La hauteur *h* est égale *y2 - y1*\n\t- Le centre du rectangle est *(x1 + w / 2, y1 + h / 2)*\n\t- *Ces calculs peuvent s'adapter en prenant d'autres paires de coins opposés ; il faudra notamment prendre la valeur absolue de la largeur et de la hauteur.*\n\n\n- `CENTER`, soit les coordonnées *(x, y)* du centre, la largeur *w* et la hauteur *h* :\n\t- Le coin supérieur gauche est *(x - w / 2, y - w / 2)*\n\t- Le coin supérieur droit est *(x + w / 2, y - h / 2)*\n\t- Le coin inférieur gauche est *(x - w / 2, y + h / 2)*\n\t- Le coin inférieur droit est *(x + w / 2, y + h / 2)*\n\n\n- `RADIUS`, soit les coordonnées *(x, y)* du centre, la moitié de la largeur *w* et la moitié de la hauteur *h* :\n\t- Le coin supérieur gauche est *(x - w, y - h)*\n\t- Le coin supérieur droit est *(x + w, y - h)*\n\t- Le coin inférieur gauche est *(x - h, y + h)*\n\t- Le coin inférieur droit est *(x + w, y + h)*\n\t- La largeur est égale à *2 \\* w*\n\t- La hauteur est égale à *2 \\* h*\n\n### Ellipses\n\nOn dessine des ellipses grâce à la fonction [`ellipse`](https://processing.org/reference/ellipse_.html) qui prend toujours 4 paramètres. Ce que *sont* ces paramètres dépend du mode de dessin des ellipses ; il existe 4 modes différents :\n\n- `CORNER` : on indique les coordonnées *(x, y)* du coin supérieur gauche, la largeur *w* et la hauteur *h* du rectangle qui \"encadre\" l'ellipse à dessiner\n- `CORNERS` : on indique les coordonnées *(x1, y1)* d'un coin et les coordonnées *(x2, y2)* du coin opposé du rectangle qui \"encadre\" l'ellipse à dessiner\n- `CENTER` : on indique les coordonnées *(x, y)* du centre de l'ellipse, la largeur *w* (diamiètre sur l'axe horizontal) et la hauteur *h* (diamètre sur l'axe vertical)\n- `RADIUS` : indique les coordonnées *(x, y)* du centre de l'ellipse, la moitié de la largeur *w* (rayon sur l'axe horizontal) et la moitié de la hauteur *h* (rayon sur l'axe vertical)\n\nOn définit le mode de dessin en appelant la fonction [`ellipseMode`](https://processing.org/reference/ellipseMode_.html) avec le mode souhaité. Le mode `CENTER` est le mode par défaut.\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/ellipse-dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/ellipse-lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\nOn remarque qu'il s'agit en fait exactement du même principe que pour les rectangles, sauf que le dessin concret sera l'ellipse inscrite dans le rectangle défini par les paramètres.\n\nPour dessiner un cercle, il suffit d'utiliser la même valeur pour la largeur et la hauteur.\n\n### Textes\n\nAu-delà des formes géométriques, on peut également afficher du texte dans la fenêtre processing grâce à la fonction [`text`](https://processing.org/reference/text_.html) qui prend en paramètre une [chaîne de caractères](cours/10-strings.md) et les coordonnées *(x, y)* où placer ce texte.\n\nOn peut configurer l'apparence du texte :\n- Sa couleur, en appelant la fonction [`fill`](https://processing.org/reference/fill_.html) avec la couleur en paramètre\n- Sa taille, en appelant la fonction [`textSize`](https://processing.org/reference/textSize_.html) avec une taille en paramètre\n- Son alignment, par rapport aux coordonnées de sa position, en appelant la fonction [`textAlign`](https://processing.org/reference/textAlign_.html) avec un ou deux paramètres :\n\t- L'alignement horizontal, qui peut être `CENTER`, `LEFT` ou `RIGHT`\n\t- L'alignement vertical qui peut être `CENTER`, `BOTTOM`, `TOP` ou `BASELINE`\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(0);\n  fill(255);\n  textSize(50);\n  textAlign(CENTER, CENTER);\n  text(\"HELLO\", width / 2, height / 2); // Affiche HELLO au milieu de la fenêtre\n}\n```\n\n## Transformations \n\n### `translate`\n\nComme expliqué précédemment, les dessins processing se basent sur l'axe par défaut dont l'origine est le coin supérieur gauche de la fenêtre. Il est toutefois possible de *déplacer* cette origine grâce à la fonction [`translate`](https://processing.org/reference/translate_.html) qui prend en paramètre le déplacement en *x* et en *y* à effectuer.\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/translate-dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/translate-lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(0);\n  stroke(255);\n  fill(255);\n  rectMode(CENTER);\n  \n  // L'origine (0, 0) est le coin supérieur gauche\n  // On va tracer un rectangle au milieu de l'écran\n  rect(width / 2, height / 2, 100, 100);\n\n  // Equivalent en déplaçant l'origine\n  translate(width / 2, height / 2); // L'origine (0, 0) est maintenant le centre de la fenêtre\n  rect(0, 0, 100, 100);\n}\n```\n\nSi on réalisait par exemple un dessin à partir du centre de la fenêtre, comme plusieurs cercles concentriques, il serait bien plus facile de déplacer l'origine au centre de la fenêtre et d'ensuite simplement dessiner à partir de l'origine.\n\n### `rotate`\n\nDe la même façon qu'il est possible déplacer l'origine des axes, on peut également *changer l'orientation* des axes. Pour ce faire, on utilise la fonction [`rotate`](https://processing.org/reference/rotate_.html) en passant en paramètre l'angle (en radians) de rotation à appliquer. Les axes tournent dans le sens horaire. On peut également transformer un angle en degré en radians grâce à la fonction [`radians`](https://processing.org/reference/radians_.html).\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/rotate-dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/rotate-lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(0);\n  stroke(255);\n  fill(255);\n  rectMode(CENTER);\n  \n  translate(width / 2, height / 2);\n  rotate(radians(45)); // Les axes tournent de 45° dans le sens horaire\n  rect(0, 0, 100, 100);\n}\n```\n\nPour facilement appliquer une rotation à une figure géométrique, il vaut mieux d'abord déplacer l'origine aux coordonnées du centre de la figure, puis d'appliquer la rotation. Sinon, les calculs pour trouver les bonnes coordonnées deviennent assez compliqués.\n\n### `scale`\n\nOn peut augmenter ou diminuer la taille des dessins grâce la transformation [`scale`](https://processing.org/reference/scale_.html) qui prend en paramètre le pourcentage de \"zoom\". Par exemple,  `scale(2)` doublera la taille des figures.\n\n### `pushMatrix` et `popMatrix`\n\nSi l'on veut utiliser des transformations pour faciliter une partie de dessin, on peut se retrouver dans une situation où le nouveau système de coordonnées après cette partie ne convient pas du tout au reste du dessin. On pourrait envisager de refaire des transformations pour revenir à la situation précédente, mais l'exercice peut être pénible.\n\nProcessing permet de sauvegarder l'état du système de coordonnées grâce à la fonction [`pushMatrix`](https://processing.org/reference/pushMatrix_.html). Au moment où on appelle cette fonction, l'état actuel du système de coordonnées est ajouté sur une *stack*, une pile d'états. Plus tard dans le code, en appelant la fonction [`popMatrix`](https://processing.org/reference/popMatrix_.html), on récupère et rétablit le dernier état sauvegardé via [`pushMatrix`](https://processing.org/reference/pushMatrix_.html). On peut ainsi *stacker* plusieurs états et les récupérer un à un.\n\n```java\nvoid setup() {\n  size(800, 600);\n\n  // Etat par défaut : origine en haut à gauche\n  pushMatrix(); // Je rajoute l'état dans la stack\n\n  translate(10, 10); // L'origine est maintenant (10, 10) selon l'axe original\n  pushMatrix(); // Je rajoute cet état dans la stack\n\n  translate(10, 10); // L'origine est maintenant (20, 20) selon l'axe original\n\n  // Dessins\n\n  popMatrix(); // Je retire le dernier état de la stack et le rétablit\n  // L'origine est donc de nouveau (10, 10) selon l'axe original\n\n  // Dessins\n\n  popMatrix(); // Je retire le dernier état de la stack et le rétablit\n  // L'origine est donc de nouveau (0, 0)\n}\n```\n\n\n\u003e ⚠ Lorsque l'on réalise un dessin animé, toutes les transformations appliquées à l'origne et aux axes sont réinitialisés au début de chaque frame. C'est-à-dire que le dessin de chaque frame commence avec l'origine (0, 0) étant le coin supérieur gauche, et pas d'angle de rotation.\n\n## Fonctions utiles\n### Distance entre deux points\n\nPour calculer la distance entre deux points, on peut simplement utiliser la fonction processing `dist`, qui prend les coordonnées de deux points en paramètre et renvoie la distance entre. On pourrait néanmoins facilement réécrire cette fonction\n\n```java\nfloat distanceBetween(float x1, float y1, float x2, float y2) {\n  float dx = x1 - x2;\n  float dy = y1 - y2;\n  float distance = sqrt(dx * dx + dy * dy);\n  return distance;\n}\n```\n\n### Intersections\n\n#### Entre un point et un rectangle\n\nUn point se situe à l'intérieur d'un rectangle si ses coordonnées sont comprises entre les bords de ce rectangle. \n\nOn utilise le coin supérieur gauche du rectangle, la largeur et la hauteur du rectangle.\n\n```java\nboolean isPointInRect(float x, float y,\n                      float rx, float ry, float rw, float rh) {\n  return x \u003e rx \u0026\u0026 x \u003c rx+rw \u0026\u0026\n         y \u003e ry \u0026\u0026 y \u003c ry+rh;\t\t\t\t  \n}\n```\n\n#### Entre deux rectangles\n\nIl y a intersection entre deux rectangles lorsque le coin supérieur gauche de chaque rectangle se situe plus haut et plus à gauche que le coin inférieur droit de l'autre rectangle.\n\nOn utilise les coordonnées du coin supérieur gauche, la largeur et la hauteur de chaque rectangle.\n\n```java\nboolean isIntersectionRects(\n    float x1, float y1, float w1, float h1, \n    float x2, float y2, float w2, float h2) {\n  return x1 \u003c x2+w2 \u0026\u0026 y1 \u003c y2+h2 \u0026\u0026 \n         x2 \u003c x1+w1 \u0026\u0026 y2 \u003c y1+h1;\t\t\t \n}\n```\n\n#### Entre un point et un cercle\n\nUn point se situe à l'intérieur d'un cercle si la distance entre ce point et le centre du cercle est plus petite que le rayon du cercle\n\n```java\nboolean isPointInCircle(float x, float y,\n                        float cx, float cy, float cr) {\n  float dx = x - cx;\n  float dy = y - cy;\n  float distance = sqrt(dx * dx + dy * dy);\n  return distance \u003c cr;\n}\n```\n\n#### Entre deux cercles\n\nIl y a intersection entre deux cercles si la distance entre les centres de ces cercles est plus petite que la somme de leur rayon.\n\n```java\nboolean isIntersectionCircles(\n    float x1, float y1, float r1, \n    float x2, float y2, float r2) { \n  float dx = x1 - x2;\n  float dy = y1 - y2;\n  float distance = sqrt(dx * dx + dy * dy);\n  return distance \u003c r1 + r2;\n}\n```\n\n\u003e ℹ Si on remplace `\u003c` et `\u003e` par `\u003c=` et `\u003e=` dans les conditions ci-dessus, on considère alors qu'il y a intersection si les bords se touchent ou si le point est sur le bord.","lastmodified":"2022-07-02T09:38:58.525044664Z","tags":null},"/cours/13-intlist-floatlist":{"title":"13 - IntList et FloatList","content":"\n## Définition\n\nIl est possible de contenir un grand nombre de variables d'un même type dans [tableau](cours/03-tableaux-matrices.md) mais il s'agit d'une structure de données contraignante ; la taille du tableu est *fixe*, déterminée à sa création, et ne pourra pas changer. Si on devait retirer un élément de ce tableau, il faudrait en réalité créer un nouveau tableau de plus petite taille et y mettre les éléments à conserver. Pour des [objets](cours/09-classes.md), on peut utiliser des `ArrayList` qui sont des listes dynamiques, de taille variable donc, et processing propose deux classes similaires pour contenir non pas des objets, mais des variables de type `int` ou `float` ; [`IntList`](https://processing.org/reference/IntList.html) et [`FloatList`](https://processing.org/reference/FloatList.html).\n\nUne [`IntList`](https://processing.org/reference/IntList.html) (resp. [`FloatList`](https://processing.org/reference/FloatList.html)) est donc une liste dynamique contenant des éléments de type `int` (resp. `float`), qui offre les mêmes possibilités qu'un tableau et en plus le fait de pouvoir supprimer des éléments de cette liste.\n\n## Utilisation\n\u003e ℹ Les explications suivantes ne mentionneront que les `IntList` mais tout ce qui est dit s'applique de la même façon aux `FloatList`\n\n### Création\n\nUne `IntList` étant une [classe](cours/09-classes.md), on crée une nouvelle liste, un nouvel objet de type `IntList`, grâce au mot clé `new`.\n\nEn utilisant le constructeur par défaut, sans paramètre, on crée une nouvelle liste initialement vide.\n\n```java\nIntList empty = new IntList(); // Nouvelle liste vide, contiendra des entiers\nprintln(empty); // Affiche IntList size=0 [  ]\n```\n\nOn peut aussi créer une liste non vide en passant aux paramètres du constructeur un tableau d'entiers.\n\n```java\nIntList notEmpty = new IntList({ 0, 1, 2, 3 });\nprintln(notEmpty); // Affiche IntList size=4 [ 0, 1, 2, 3 ]\n```\n\n### Manipulation\n\nLa manipulation d'une [`IntList`]https://processing.org/reference/IntList.html se fait via l'appel à différentes méthodes sur cette liste :\n\n- `append(value)` qui prend en paramètre un entier et l'ajoute \"à la fin\" de la liste\n- `get(i)` qui prend en paramètre l'indice d'un élément, et renvoie l'élément se trouvant à cette place dans la liste\n- `remove(i)` qui prend en paramètre l'indice d'un élément et le supprime de la liste\n- `size()` qui renvoie le nombre d'éléments que contient la liste\n- `set(i, value)` qui prend en paramètre un indice et un objet et remplace l'élément à cet indice dans la liste par l'objet passé en paramètre. A l'inverse de la même méthode sur une [`ArrayList`](rrayIndexOutOfBoundsException), on peut ici utiliser un indice `i` plus grand que la taille actuelle de la liste, processing rajoutera alors des valeurs 0 dans la liste jusqu'à l'indice où l'on souhaite insérer la valeur.\n\n```java\nIntList list = new IntList();\nprintln(list.size()); // Affiche 0\nlist.append(5);\nlist.append(6);\nprintln(list.size()); // Affiche 2\nprintln(list.get(0)); // Affiche 5\nlist.remove(0);\nprintln(list.get(0)); // Affiche 6\nlist.set(3, 1);\nprintln(list); // Affiche IntList size=4 [ 6, 0, 0, 1 ]\n```\n\n### Erreurs\nSi on essaie d'accéder directement à une position se situant hors du tableau dans les appels à `get` ou `remove`, on aura une erreur du type `ArrayIndexOutOfBoundsException`. \n\n### Autres méthodes utiles\n\nAu-delà de la manipulation par défaut des éléments d'une [`IntList`](https://processing.org/reference/IntList.html), il existe d'autres méthodes qui peuvent s'avérer utiles :\n- `clear()`, qui retire tous les éléments de la liste ; elle sera à nouveau vide\n- `shuffle()`, qui met les éléments de la liste dans un ordre aléatoire\n- `sort()`, qui trie les éléments de la liste dans l'ordre croissant\n- `reverse()`, qui inverse l'ordre des éléments dans la liste\n- `sortReverse()`, qui trie les éléments dans l'ordre décroissant ; cela équivant à appeler consécutivement `sort()` et `reverse()`.\n- `min()`, qui renvoie le plus petit élément de la liste\n- `max()`, qui renvoie le plus grand élément de la liste\n\n","lastmodified":"2022-07-02T09:38:58.525044664Z","tags":null},"/cours/14-images-pixels":{"title":"14 - Images et pixels","content":"\n## Images\n\nProcessing permet de charger des images depuis des fichiers et de les manipuler ensuite pour, notamment, les afficher dans la fenêtre. Ces images peuvent ensuite être sauvegardées dans un fichier.\n\nUne image est représentée par la classe [`PImage`](https://processing.org/reference/PImage.html).\n\n### Chargement et sauvegarde\n\nPour charger une image depuis un fichier existant, il faut utiliser la fonction processing [`loadImage`](https://processing.org/reference/loadImage_.html) avec, en paramètre, une [chaîne de caractères](cours/10-strings.md) contenant le chemin vers le fichier de l'image.\n\n\u003e ℹ Ce chemin peut être spécifié de façon relative depuis l'endroit où se situe le fichier .pde (processing) à exécuter, ou de façon absolue en partant de la racine C:\\\\ (Windows) ou / (Unix).\n\n```java\nPImage img;\n\nvoid setup() {\n  fullScreen();\n  img = loadImage(\"images/dog.png\");\n}\n```\n\nProcessing ne permet pas de charger des images *avant* le `setup`. On ne peut donc pas appeler la fonction [`loadImage`](https://processing.org/reference/loadImage_.html) au niveau des variables globales. \n\nLes formats d'image acceptés sont `gif`, `jpg`, `png` et `tga`.\n\n\u003e ⚠ Si le chemin spécifié pour charger une image n'existe pas, la fonction renverra `null`.\n\nOn peut sauvegarder une image grâce à la méthode `save` sur l'image en \npassant en paramètre le chemin vers le fichier où on l'on veut sauver l'image. Si ce fichier n'existe pas, il sera créé.\n\n```java\nPImage img;\n\nvoid setup() {\n  fullScreen();\n  img = loadImage(\"images/dog.png\"); // Charge l'image dog.png\n  img.save(\"images/renamedDog.png\"); // Sauve l'image dans un autre fichier\n}\n```\n\n### Manipulation\n\n#### Affichage\n\nPour afficher une image dans la fenêtre processing, il faut utiliser la fonction `image` avec, en paramètres, l'image à afficher et les coordonnées *(x, y)* ou placer le coin supérieur gauche de l'image.\n\n```java\nPImage img;\n\nvoid setup() {\n  fullScreen();\n  img = loadImage(\"images/dog.png\"); // Charge l'image dog.png\n  image(img, 0, 0);\n}\n```\n\n#### Attributs\n\nUne fois une image chargée, on a accès \n- A sa largeur, via l'attribut `width`\n- A sa hauteur, via l'attribut `height`\n- Aux pixels qui la composent, stockés dans un attribut `pixels`, un *tableau à une dimension* de `color`.\n\nComme les pixels sont stockés dans un tableau à une dimension, on ne peut pas directement accéder à un pixel via ses coordonnées \"écran\" *(x, y)*. Il faut d'abord convertir ces coordonnées dans un repère à deux dimensions (~ matrice) à leur coordonnée équivalente à une dimension. Ce calcul est relativement simple dès lors qu'on connaît la largeur de l'image (~ matrice), car le tableau a une dimension contient en fait le contenu de chaque *ligne* de la matrice, mise bout à bout.\n\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/1d-2d-dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/1d-2d-lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n\nLa formule pour passer des coordonnées *(x, y)* à deux dimensions à la coordonnée *k* à une dimension, connaissant la largeur *w*, est `k = y x w + x`. On multiplie *y*, le nombre de lignes, par la largeur de l'image *w*, car on aura, avant le *x*, l'indice de la colonne, tous les éléments des lignes d'avant, sachant qu'on a *w* éléments par ligne et *y* lignes.\n\nSimilairement, la formule pour passer de la coordonnée *k* à une dimension aux coordonnées *(x, y)*, connaissant la largeur w est :\n- `y = k / w`, la division ***entière*** de *k* par la largeur, pour savoir combien de lignes *complètes* sont incluses jusqu'à la position *k*\n-  `x = k % w`, le reste de la division entière de *k* par la largeur, pour savoir combien d'éléments il y a sur la ligne actuelle *incomplète* de la matrice où se situe *k*\n\n```java\nPImage img;\n\nvoid setup() {\n  fullScreen();\n  img = loadImage(\"images/dog.png\"); // Charge l'image dog.png\n  \n  // Parcourir les pixels\n  for (int k = 0; k \u003c img.pixels.length; k++) {\n    int x = k % img.width;\n    int y = k / img.width;\n    if (img.pixels[k] != img.get(x, y)) {\n      println(\"Pas possible ?!\"); // On ne devrait jamais arriver ici\n    }\n  }\n\n  // Equivalent à\n  for (int x = 0; x \u003c img.width; x++) {\n    for (int y = 0; y \u003c img.height; y++) {\n      int k = y * img.width + x;\n      if (img.pixels[k] != img.get(x, y)) {\n        println(\"Pas possible ?!\"); // On ne devrait jamais arriver ici\n      }\n    }\n  }\n}\n```\n\n#### Méthodes\n\nLa classe [`PImage`](https://processing.org/reference/PImage.html) propose des méthodes utilitaires pour plus facilement manipuler des images :\n- `get(x, y)` qui renvoie la couleur (`color`) du pixel en position *(x, y)* sur l'image.\n- `get(x, y, w, h)` qui renvoie une sous partie de l'image ; un rectangle dont le coin supérieur gauche est en position *(x, y)*, de largeur *w* et de hauteur *h*.\n- `set(x, y, c)` qui change la couleur du pixel en position *(x, y)* par la couleur *c* passée en paramètre.\n- `save(filename)` comme déjà mentionné, pour sauver l'image dans un fichier *filename*.\n\nIl est plus facile d'interagir avec les pixels de l'image avec les méthodes `get` et `set`, mais cela est moins efficace que d'accéder directement aux éléments du tableau de pixels.\n\n## Pixels de la fenêtre\n\nLa fenêtre de processing pouvant elle-même être considérée comme une image, processing permet d'en manipuler directement les pixels via un tableau de pixels `pixels`. \n\n### Chargement\n\nPour pouvoir lire ou modifier directement les pixels de la fenêtre de processing, il faut d'abord les *charger* en appelant la fonction [`loadPixels()`](https://processing.org/reference/loadPixels_.html). Une fois cette fonction appelée, on aura accès à une variable globale processing `pixels`, qui est un tableau (à une dimension) de couleurs.\n\n```java\nvoid setup() {\n  size(20, 20);\n  background(0); // Fond noir\n  loadPixels(); // On charge les pixels de la fenêtre actuelle de processing\n  color p = pixels[0];\n  println(red(p)); // Composante rouge du premier pixel : 0\n  println(green(p)); // Composante verte du premier pixel : 0\n  println(blue(p)); // Composante bleue du premier pixel : 0\n}\n```\n\n### Manipulation\n\nOn peut manipuler les pixels de la fenêtre de la même façon qu'on manipule les pixels d'une image [`PImage`](https://processing.org/reference/PImage.html), **mais** si on modifie la valeur de certains pixels, il faut alors appeler la fonction [`updatePixels()`](https://processing.org/reference/updatePixels_.html) pour que ces changements soient répercutés sur l'affichage de la fenêtre.\n\n```java\nvoid setup() {\n  size(20, 20);\n  background(0); // Fond noir\n  loadPixels(); // On charge les pixels de la fenêtre actuelle de processing\n  \n  pixels[10 * 20 + 10] = color(255, 0, 0);\n  // A ce stade, la fenêtre n'a pas changé et reste toute noire\n  \n  updatePixels(); // On met à jour la fenêtre processing\n  // Il y a maintenant un pixel rouge au centre\n}\n```\n\n\u003e ℹ Manipuler les pixels de la fenêtre revient à dessiner des points grâce à la fonction `point`.","lastmodified":"2022-07-02T09:38:58.525044664Z","tags":null},"/cours/15-tables":{"title":"15 - Tables","content":"\n## Définition\n\nProcessing permet de charger des fichiers tabulaires (`csv`) pour en manipuler les données, supprimer/rajouter des lignes, etc. Ces données sont stockées dans une *table*, représentée par la classe [`Table`](https://processing.org/reference/Table.html). On peut facilement se représenter de quoi il s'agit en visualisant une feuille Excel. On peut aussi créer soi même des tables et les sauvegarder dans des fichiers.\n\n## Chargement, création et sauvegarde\n\n### Chargement\n\nPour charger une table depuis un fichier, il faut utiliser la fonction [`loadTable`](https://processing.org/reference/loadTable_.html), avec, en paramètre, une [chaîne de caractères](cours/10-strings.md) contenant le chemin vers le fichier. La logique de chargement est similaire à celle des [images](cours/14-images-pixels.md) ; le nom du fichier peut être un chemin relatif au sketch processing ou absolu, et on ne peut pas charger des tables avant le `setup`, s'il y a en un.\n\n```java\nTable table = loadTable(\"data.csv\");\n```\n\nLorsque l'on charge une table depuis un fichier, il est possible que le fichier ait une première ligne représentant le nom des colonnes (comme dans un tableau Excel). Processing ne pouvant pas le deviner, il faut, quand c'est le cas, spécifier qu'on charge un fichier dont la première ligne contient les en-têtes, en rajoutant en paramètre la valeur `\"header\"`.\n\n```java\nTable table = loadTable(\"data.csv\", \"header\");\n```\n\n### Création\n\nPour créer une nouvelle table, vide, il suffit simplement d'appeler le constructeur de la classe [`Table`](https://processing.org/reference/Table.html) avec le mot clé `new`.\n\n```java\nTable newTable = new Table();\n```\n\n### Sauvegarde\n\nPour sauvegarder le contenu d'une table dans un fichier, il faut appeler la fonction [`saveTable`](https://processing.org/reference/saveTable_.html) avec en paramètres la table à sauvegarder, et le nom/chemin du fichier où la sauvegarder.\n\n```java\nTable table = loadTable(\"data.csv\");\nsaveTable(table, \"renamedData.csv\");\n```\n\n## Manipulation\n\n### Lecture\nLa classe [`Table`](https://processing.org/reference/Table.html) a différentes méthodes qui permettent de lire son contenu ou les informations liées :\n- [`getRowCount()`](https://processing.org/reference/Table_getRowCount_.html) renvoie le nombre de lignes, sans inclure la ligne d'en-tête s'il y en a une, présentes dans la table.\n- [`getColumnCount()`](https://processing.org/reference/Table_getColumnCount_.html) renvoie le nombre de colonnes dans la table.\n- [`getString(i, j)`](https://processing.org/reference/Table_getString_.html) ou [`getString(i, name)`](https://processing.org/reference/Table_getString_.html) renvoie la valeur contenue dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-tête) comme [`String`](cours/10-strings).\n- [`getFloat(i, j)`](https://processing.org/reference/Table_getFloat_.html)ou [`getFloat(i, name)`](https://processing.org/reference/Table_getFloat_.html) renvoie la valeur contenue dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-tête) convertie en `float`.\n- [`getInt(i, j)`](https://processing.org/reference/Table_getInt_.html) ou [`getInt(i, name)`](https://processing.org/reference/Table_getInt_.html) renvoie la valeur contenue dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-tête) convertie en `int`.\n\nSoit le fichier `data.csv`\n\n```csv\nc1,c2\na,1\nb,2\nc,3\n```\n\n```java\nTable table = loadTable(\"data.csv\", \"header\");\nprintln(table.getRowCount()); // Affiche 3\nprintln(table.getColumnCount()); // Affiche 2\nprintln(table.getString(0, 0)); // Affiche a\nprintln(table.getInt(1, \"c2\")); // Affiche 2\n```\n\n### Ecriture\n\nPour modifier directement la valeur de cellules existantes dans la table, on peut utiliser les méthodes :\n- [`setString(i, j, s)`](https://processing.org/reference/Table_setString_.html) ou [`setString(i, name, s)`](https://processing.org/reference/Table_setString_.html) met la chaîne de caractères *s* dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-tête).\n- [`setFloat(i, j, f)`](https://processing.org/reference/Table_setFloat_.html)ou [`setFloat(i, name, f)`](https://processing.org/reference/Table_setFloat_.html) met le nombre flottant *f* dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-tête).\n- [`setInt(i, j, v)`](https://processing.org/reference/Table_setInt_.html) ou [`setInt(i, name, v)`](https://processing.org/reference/Table_setInt_.html) met la valeur entière *k* dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-tête).\n\nSoit le fichier `data.csv`\n\n```csv\nc1,c2\na,1\nb,2\nc,3\n```\n\n```java\nTable table = loadTable(\"data.csv\", \"header\");\ntable.setString(0, 0, \"aa\");\ntable.setInt(1, \"c2\", 22);\nsaveTable(table, \"data.csv\");\n```\n\nLe fichier `data.csv` contient maintenant\n\n```csv\nc1,c2\naa,1\nb,22\nc,3\n```\n\n### `TableRow`\n\nOn peut accéder directement aux cellules de la table depuis l'objet table, de type [`Table`](https://processing.org/reference/Table.html), mais on peut également passer par l'étape intermédiaire qui consiste à récupérer l'objet représentant une ligne en appelant la méthode [`getRow(i)`](https://processing.org/reference/Table_getRow_.html) avec l'indice de la ligne voulue. Ces objets \"lignes\" sont de type [`TableRow`](https://processing.org/reference/TableRow.html), et on peut les manipuler de façon similaire à la table :\n- [`getColumnCount()`](https://processing.org/reference/TableRow_getColumnCount_.html) renvoie le nombre de colonnes dans la ligne.\n- [`getColumnTitle(j)`](https://processing.org/reference/TableRow_getColumnTitle_.html) renvoie l'en-tête de la colonne d'indice *j*\n- [`getString(j)`](https://processing.org/reference/TableRow_getString_.html) ou [`getString(name)`](https://processing.org/reference/TableRow_getString_.html) renvoie la valeur contenue dans la colonne *j* (indice) ou *name* (en-tête) de la ligne, comme [`String`](cours/10-strings).\n- [`getFloat(j)`](https://processing.org/reference/TableRow_getFloat_.html)ou [`getFloat(name)`](https://processing.org/reference/TableRow_getFloat_.html) renvoie la valeur contenue dans la colonne *j* (indice) ou *name* (en-tête) de la ligne, convertie en `float`.\n- [`getInt(j)`](https://processing.org/reference/TableRow_getInt_.html) ou [`getInt(name)`](https://processing.org/reference/TableRow_getInt_.html) renvoie la valeur contenue dans la colonne *j* (indice) ou *name* (en-tête) de la ligne, convertie en `int`.\n- [`setString(j, s)`](https://processing.org/reference/TableRow_setString_.html) ou [`setString(name, s)`](https://processing.org/reference/TableRow_setString_.html) met la chaîne de caractères *s* dans la colonne *j* (indice) ou *name* (en-tête) de la ligne.\n- [`setFloat(j, f)`](https://processing.org/reference/TableRow_setFloat_.html)ou [`setFloat(name, f)`](https://processing.org/reference/TableRow_setFloat_.html) met le nombre flottant *f* dans la colonne *j* (indice) ou *name* (en-tête) de la ligne.\n- [`setInt(j, v)`](https://processing.org/reference/TableRow_setInt_.html) ou [`setInt(name, v)`](https://processing.org/reference/TableRow_setInt_.html) met la valeur entière *k* dans la colonne *j* (indice) ou *name* (en-tête) de la ligne.\n\n```csv\nc1,c2\na,1\nb,2\nc,3\n```\n\n```java\nTable table = loadTable(\"data.csv\", \"header\");\nTableRow row1 = table.getRow(0);\nTableRow row2 = table.getRow(1);\nrow1.setString(0, \"aa\");\nrow2.setInt(\"c2\", 22);\nsaveTable(table, \"data.csv\");\n```\n\nLe fichier `data.csv` contient maintenant\n\n```csv\nc1,c2\naa,1\nb,22\nc,3\n```\n\n### Structure\n\nPour modifier la structure d'une table, on peut utiliser les méthodes :\n- [`addRow()`](https://processing.org/reference/Table_addRow_.html) ajoute une nouvelle ligne (vide), tout en bas de la table. La ligne créée ([`TableRow`](https://processing.org/reference/TableRow.html)) est renvoyée. Si on passe une autre [`TableRow`](https://processing.org/reference/TableRow.html) en paramètre, la nouvelle ligne créée contiendra alors une copie des données de la ligne passée en paramètre.\n- [`removeRow(i)`](https://processing.org/reference/Table_removeRow_.html) supprime la ligne à l'indice *i* dans la table.\n- [`addColumn()`](https://processing.org/reference/Table_addColumn_.html) ajoute une nouvelle colonne, vide pour chaque ligne, à droite de la table. Si on passe en paramètre le nom de la colonne, il s'agira de l'en-tête qui pourra ensuite être utilisée pour plus facilement accéder aux éléments de cette colonne. On peut éventuellement passer un deuxième paramètre correspondant au type de données attendu dans la colonne ; `Table.INT`, `Table.FLOAT` et `Table.STRING` (défaut).\n- [`removeColumn(j)`](https://processing.org/reference/Table_removeColumn_.html) ou [`removeColumn(name)`](https://processing.org/reference/Table_removeColumn_.html) supprime la colonne à l'indice *j* ou avec le nom *name* spécifié en paramètre. \n\n```java\nTable table = new Table();\ntable.addColumn(\"a\"); // On ajoute une colonne a\ntable.addColumn(\"b\"); // On ajoute une colonne b\ntable.addColumn(\"c\"); // On ajoute une colonne c\ntable.removeColumn(\"a\"); // On retire la colonne a\ntable.removeColumn(1); // On retire la deuxième colonne, c\ntable.addColumn(\"d\"); // On ajoute la colonne d\n\n// On a donc une table avec deux colonnes, b et d\n\nTableRow firstRow = table.addRow(); // Première ligne\nfirstRow.setString(\"b\", \"test\");\nfirstRow.setInt(\"d\", 1);\n\ntable.addRow(firstRow); // On rajoute une deuxième ligne qui contient les mêmes valeurs que la première\ntable.setInt(1, \"d\", 2); // On met la valeur 2 dans la colonne d de la deuxième ligne\n\nsaveTable(table, \"random.csv\");\n```\n\nOn obtient alors un fichier `random.csv` contenant :\n\n```csv\nb,d\ntest,1\ntest,2\n```\n\n\n### Tri\n\nOn peut facilement trier une table en appelant la méthode [`sort`](https://processing.org/reference/Table_sort_.html) avec en paramètre l'indice ou le nom de la colonne à trier. Les lignes de la table seront alors réorganisées selon l'ordre croissant des valeurs apparaissant dans cette colonne.\n\nPour des tris plus complexes qui demandent de comparer plusieurs colonnes, il faudra définir la comparaison adéquate et implémenter un algorithme de tri.\n\n```java\nvoid setup() {\n  Table t = loadTable(\"data.csv\");\n\n  // Bubble sort\n  for (int k = table.getRowCount()-1; k \u003e 0; k--) {\n    for (int i = 0; i \u003c k; i++) {\n      TableRow row1 = table.getRow(i);\n      TableRow row2 = table.getRow(i + 1);\n      if (compare(row1, row2) \u003e 0) {\n        // La ligne i devrait être après la ligne i + 1\n        // On les échange\n        swapRows(table, i, i + 1);\n      }\n    }\n  }\n}\n\nint compare(TableRow row1, TableRow row2) {\n  // Implémenter la comparaison\n  return 0;\n}\n\nvoid swapRows(Table t, int i1, int i2) { \n  for (int j = 0; j \u003c t.getColumnCount(); j++) { \n    String swapped = t.getString(i1, j); \n    t.setString(i1, j, t.getString(i2, j)); \n    t.setString(i2, j, swapped); \n  }\n}\n```","lastmodified":"2022-07-02T09:38:58.525044664Z","tags":null},"/tutoriels/debugger":{"title":"Débugger (et pas déboguer)","content":"\n## Manuellement\nPour débugger manuellement, le plus \"facile\" est parfois de simplement afficher en console, aux endroits importants du code, l'état de certaines variables, ou simplement un indicateur pour savoir si on est arrivé à cet endroit du code.\n\n```java\nvoid setup() {\n  println(\"Now calling foo(0)\");\n  foo(0);\n  println(\"Now calling foo(1)\");\n  foo(1);\n}\n\nvoid foo(int i) {\n  println(\"Starting foo with parameter \" + i);\n  for (int j = 0; j \u003c 4; j++) {\n    i = i + 2;\n    println(\"i = \" + i, \"j = \" + j);\n    println(i + j);\n  }\n}\n```\n\nLe problème avec cette façon de faire est qu'on peut très vite se perdre dans la quantité d'informations qui sera affichée en console, d'autant plus pour des dessins animés où chaque frame génère plein d'impressions en console. Le code s'alourdit également et on en perd en lisibilité.\n\n## Debugger processing\n\n### Activer le mode debug\n\nL'environnement processing offre un outil de débuggage qui permet de mettre l'exécution du code en *pause* aux endroits voulus, et d'avoir accès au [contexte](cours/07-blocs-contextes.md) de cette ligne de code grâce à une fenêtre supplémentaire qui liste toutes les variables visibles à ce moment de l'exécution ainsi que leur valeur.\n\nIl s'agit en réalité d'un mode d'exécution du code différent, que l'on peut activer dans processing via le raccourci `ctrl-d` ou explicitement via le menu :\n\n![[tutoriels/images/enable-debugger.png]]\n\n### Points d'arrêt\n\nUne fois le mode activé, la fenêtre de debug s'ouvre. Elle est actuellement vide puisqu'il n'y a pas encore de code en train d'être exécuté. On peut maintenant définir des points d'arrêt, ou *breakpoints*, en cliquant sur le numéro d'une ligne ; il y aura alors un symbole (losange) à la place du numéro de la ligne. Lorsque le code exécuté arrivera sur cette ligne de code, il se mettra en pause *avant* que cette ligne soit exécutée. Pour retirer le point d'arrêt, on peut cliquer sur le losange et il disparaîtra. On peut définir autant de points d'arrêt que l'on veut, tant qu'il s'agit d'une ligne *exécutable* (par une ligne vide, par exemple).\n\n![[tutoriels/images/breakpoints.png]]\n\nDans l'exemple ci-dessus, on voit qu'on a mis des points d'arrêt sur les lignes 2, 3, et 8.\n\n### Débugger !\nUne fois le code lancé, l'exécution se mettra automatiquement en pause dès qu'on arrive sur un point d'arrêt. La ligne sur laquelle on s'est arrêté aura un symbole différent (une flèche). \n\nLorsque l'exécution est en pause, plusieurs choix sont possibles :\n\n![[tutoriels/images/choices.png]]\n\n- Le premier bouton lance l'exécution complète du code. S'il était déjà lancé, il se relançera ; c'est la même chose que pour le mode d'exécution normal.\n- Le deuxième bouton \"step\" permet d'exécuter la ligne de code actuelle, et de passer à la suivante comme si on y avait mis un point d'arrêt.\n- Le troisième bouton \"continue\" permet de relancer l'exécution du code jusqu'au prochain point d'arrêt.\n\nLe bouton step permet ainsi d'exécuter le code ligne par ligne et de voir tous les changements dans le contexte au fur et à mesure.\n\n### Exemple\n- Dans l'appel de `foo(0)`, on s'arrête sur la ligne 8 lors de la première boucle du `for`. On voit dans la fenêtre des variables que `i` vaut 0 et `j` vaut 0.\n\n![[tutoriels/images/debug.png]]\n\n- On clique sur le bouton \"step\" et on passe à la ligne 9. On voit dans la fenêtre des variables que `i` vaut maintenant 2 (résultat de `i` + 2 à la ligne d'avant).\n\n![[tutoriels/images/debug-2.png]]\n\n- Ainsi de suite...","lastmodified":"2022-07-02T09:38:58.525044664Z","tags":null},"/tutoriels/space-invaders":{"title":"Space Invaders simplifié","content":"\n## Introduction\n\nSpace Invaders est un jeu d’arcade créé en 1978. Il s’agit du tout premier jeu \"shooter' fixe. Dans ce jeu, le joueur incarne un vaisseau qui se déplace latéralement et tente de repousser une vague d’envahisseurs à l’aide d’un canon laser. Les aliens se rapprochent lentement mais sûrement du vaisseau et tirent également des lasers vers le vaisseau. Les lasers se déplacent verticalement et disparaissent quand ils touchent un ennemi ou atteignent le bord de l’écran de jeu. Il y a des obstacles entre le vaisseau et les envahisseurs qui sont progressivement détruits par les lasers.\n\n![[tutoriels/images/SpaceInvadersOriginal2.png]]\n\n## Version minimale\n\n### Vie et fin de jeu \nDans cette version, les aliens sont inoffensifs et le joueur ne perd jamais. Quand une vague d’aliens est entièrement détruite, une nouvelle vague arrive. \n\n### Ennemis\n\nUne vague d’aliens a les dimensions suivantes : 5 lignes de 10 aliens. Ils ne se déplacent pas et ne tirent pas. \n\n### Destruction\n\nAu contact d’un laser, l’alien touché et le laser sont détruits immédiatement. Si un laser atteint le haut de l’écran sans avoir touché un alien, il disparaît. \n\n### Contrôles\n\nLes mouvements latéraux du vaisseau sont contrôlés par les touches `FLÈCHE-GAUCHE` et `FLÈCHE-DROITE`. La touche `ESPACE` permet de tirer des lasers. \n\n### Dimensions\n\nVous pouvez utiliser les dimensions suivantes : \n- Les dimensions de la fenêtre sont de 1000x800 pixels\n- Les aliens et le vaisseau sont des rectangles de 50x50 pixels\n- Les lasers sont des rectangles de 5x30 pixels \n\n### Démonstration\n\u003cp align=\"center\"\u003e\n\u003ciframe src=\"https://openprocessing.org/sketch/1592175/embed/?plusEmbedHash=YTc3Mzc1ODI5ODMzYzhkMTdkYzAyM2U4Yjk1MDc4YWJiZTEyMzc2ZjVmZTRmMTQ4NTQ1MGY5NDdmN2VlNTdlNGMwMWI1ZDNjMzc2NjkyZGEyMThiMWIxZGNmODYyZjEyNmM3ODE3YWUyMjZmMDEyMGVhN2NiYTgwYWNkN2U3Y2RrdGg2VWk4NXkxVWNWVitBZitsbXozUTdOVFQ5UERTd0c2dmpZM0VybXloKzFUMUxDb1dvTU9JWWpBWnlEUVdoSlFscFl5SW1TWXRyeWN2ZWhWVEVBUT09\u0026plusEmbedTitle=true\" width=\"600\" height=\"500\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\n\n## Version améliorée\n\n### Fin de jeu\n\nLes aliens se rapprochent lentement mais sûrement du vaisseau. Si le joueur ne parvient pas à détruire l’entièreté de la vague avant que les aliens atteignent le bas de l’écran, le jeu est perdu. \n\n### Gestion des couleurs\n\nChaque alien peut, aléatoirement, avoir une des couleurs suivantes : `color(240, 20, 20)`, `color(200, 20, 200)`, `color(20, 200, 20)`, `color(20, 100, 250)`, `color(240, 200, 0)`. \n\n### Gestion de la difficulté\n\nLorsque la vague d’aliens est détruite, un nouvelle vague arrive. Chaque vague d’aliens est plus résistante que la précédente : à chaque nouvelle vague, il faut un coup de laser en plus pour détruire un alien. A la deuxième vague, il faudra donc toucher un alien 2 fois pour le détruire, 3 fois pour la troisième vague, et ainsi de suite. \n\n### Gestion de la transparence\n\nSi vous gérez également la difficulté des vagues, le taux d’opacité d’un alien diminue en fonction du nombre de lasers qui l’ont déjà touché, pour un minimum de 50%. Par exemple, à la vague 3, un alien sera initialement visible à 100%, à 75% après le premier coup et à 50% après le deuxième ; il sera détruit après le troisième coup.\n\n### Démonstration\n\n\u003cp align=\"center\"\u003e\n\u003ciframe src=\"https://openprocessing.org/sketch/1592193/embed/?plusEmbedHash=YmI5ZWNkMzIwYzFiZGNhODBkOGM0NzYyN2ZmMTAyNjBiYzc5OGQ4OTk0OTY2YmJmNTUwMjRlOWZmOWU4MmNiMzQ5ODhmOTg5M2E1MTA0ZjU3OWFkMzRjZThjZTliZmU5NDBiNjcyZmIyNmVhNWQ5YmZmOTkyOWRhM2NjOTI0NzFzSkRWU29QRzRzOTZYOXArekUvTmk3OFhNWWRRRjFCbXVwNkUrZ2ZSNmp4UHlwOUlpaE55WUt5NEc0Y1VubWhNM1JlWWJhVnhaQ3N0RmJQL0xyeXJTUT09\u0026plusEmbedTitle=true\" width=\"600\" height=\"500\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\n\n## Solution\n\nL'entièreté de la solution est disponible dans le tutoriel OpenProcessing [http://oppr.org/s/cCeVZINr](http://oppr.org/s/cCeVZINr)","lastmodified":"2022-07-02T09:38:58.529044811Z","tags":null},"/tutoriels/structurer-une-solution":{"title":"Structurer une solution processing","content":"\n## Vue d'ensemble\nUne solution [processing](cours/11-bases-processing.md) contiendra\n\n-   La déclaration de variables globales (visibles dans tous les blocs)\n-   Le `setup`\n-   Le `draw`\n-   Les fonctions de réaction aux inputs pertinantes (`mousePressed`, `keyPressed`, etc.)\n-   Des fonctions globales, utilitaires\n-   Des classes\n\nIl est plus facile d'écrire une classe dans un onglet spécifique pour cette classe, et, si le code devient trop long, de regrouper en différents onglets (~ bloc logique) les différentes fonctions.\n\n## Etat et données\n\nL'_état_ du code est l'ensemble des informations (~ variables) qui permettent, à tout moment, de représenter le dessin et de le faire évoluer.\n\n### Constantes\n\nLes [variables](cours/01-variables-litteraux.md) **constantes** sont des valeurs qui ne changeront pas lors de l'exécution du code, mais qui seront amenées à être utilisées régulièrement. On préfère ainsi voir apparaître ce genre de valeurs dans des variables constantes, pour pouvoir facilement les changer sans devoir reparcourir tout le code. \n\nLorsque ces variables sont bien nommées, elles peuvent également améliorer la lisibilité du code :\n\n```java\nint WON = 1;\nint PLAYING = 0;\nint LOST = -1;\n\nint status = PLAYING;\n\n// ... Some code\n\nif (status == WON) {\n  // Do something if we won\n} else if (status == LOST) {\n  // Do something else if we lost\n} else {\n  // Continue playing\n}\n```\n\n### Déterminer les informations nécessaires\n\nLes autres variables sont déterminées par ce dont nous avons besoin pour avoir le comportement voulu. Par exemple, si on veut dessiner une balle qui rebondit sur les bords de l'écran, il faudra connaître les informations qui permettent de dessiner cette balle : ses coordonnées, sa taille, sa couleur, etc. Ce qu'on peut voir comme une seule information doit parfois être stockée en plusieurs variables.\n\n\u003e ⚠️ Il est **difficile** de réussir à déterminer toutes les variables dont on a besoin dès le début. C'est seulement en avançant dans la solution et dans les fonctionnalités implémentées qu'on se rend compte qu'il manque des informations.\n\n### Evolution des données\n\nLes variables non constantes sont amenées à changer lors de l'exécution du code. On peut distinguer deux types d'évolution :\n- L'évolution naturelle (dans le `draw`)\n- L'évolution forcée en réaction aux entrées clavier/souris de l'utilisateur\n\n## Initialisation\n\nC'est en général dans le `setup` qu'on va initialiser l'état, les valeurs initiales des données. On peut aussi y configurer certains paramètres globaux du dessin (largeur des lignes, etc.).\n\n```java\nvoid setup() {\n  size(800, 600);\n\n  // Configuration globale du dessin\n\n  // Initialisation des données\n\t\n}\n```\n\n## Boucle principale\n\nC'est du `draw` que partira la majorité de la logique du code : la représentation, le dessin, et l'évolution naturelle des données. L'ordre des différentes mises à jour de données et des dessins dépendra du comportement voulu.\n\n```java\nvoid draw() {\n  background(0);\n\n  // Dessiner\n\n  // Faire évoluer les données\n\n}\n```\n\n## Réactions aux entrées\n\nIl faudra définir les fonctions correspondant à toutes les entrées possibles pour le dessin et y ajouter la logique voulue. Cette logique est en général un changement dans l'état des données qui aura un impact sur l'évolution naturelle des données dans le `draw`.\n\nOn pourrait par exemple imaginer une voiture qui roule relativement vite sur une avenue dégagée. Le mouvement est continu, on ferait donc évoluer les informations de position dans le `draw`. Au loin, le conducteur aperçoit un feu de signalisation qui vient de passer orange. En *réaction* à ce *signal*, la position de la voiture ou sa vitesse ne va pas changer, mais le conducteur va appuyer sur le frein pour appliquer une décélaration qui fera diminuer la vitesse. Il faut donc en général concevoir les fonctions de réaction aux entrées comme une réaction ponctuelle à un signal sans directement appliquer la conséquence de cette réaction.\n\n```java\nint x = 0;\nint speed = 10;\nint acceleration = 0;\n\nvoid setup() {\n  fullScreen();\n  noStroke();\n  fill(255);\n}\n\nvoid draw() {\n  background(0);\n\n  ellipse(x, height / 2, 50, 50);\n\n  speed = constrain(speed + acceleration, -15, 30);\n  x += speed;\n}\n\nvoid keyPressed() {\n  // Signal, on appuie sur l'accélérateur ou le frein\n  // On ne modifie pas la vitesse directement\n  if (keyCode == LEFT) {\n    acceleration = -1;  \n  } else if (keyCode == RIGHT) {\n    acceleration = 1;  \n  }\n}\n\nvoid keyReleased() {\n  // Signal, on relâche l'accélérateur ou le frein\n  // On ne modifie pas la vitesse directement\n  acceleration = 0;\n}\n```\n\n## Fonctions et classes\n\nL'utilisation de [fonctions](cours/06-fonctions.md) et de [classes](cours/09-classes.md) n'est fondamentalement pas obligatoire pour mettre au point une solution, mais on se prive alors de mécanismes précieux permettant de simplifier le code, le rendre plus lisible, d'éviter la redondance, etc.\n\nPrenons par exemple un dessin où un personnage glisse sur le sol jusqu'à rencontrer un obstacle, auquel cas il trouve une nouvelle direction \"libre\" et continue sa glissade. Le code suivant nous permet facilement de comprendre *ce que fait le dessin*. *Comment* le dessin est effectivement réalisé dépendra de la façon dont on aura défini et implémenté les différentes classes/fonctions.\n\n```java\nMyMap map;\nMyCharacter character;\n\nvoid setup() {\n  fullScreen();\n\n  map = new Map();\n  map.addRandomObstacles();\n  \n  character = new MyCharacter(width / 2, height / 2);\n  character.chooseRandomDirection();\n}\n\nvoid draw() {\n  background(0);\n\n  map.display();\n  character.display();\n\n  character.move();\n  \n  if (character.isFacingAnObstacle()) {\n    character.changeDirection();\n  }\n\n}\n```\n\nIl est parfois plus facile de concevoir directement la solution en orienté objet (\"je vais faire des objets Balle\"). Bien souvent, lorsque l'on détermine les informations nécessaires, elles-mêmes sont déduites des concepts qui peuvent directement être traduits en classes.\n\n## Conseils généraux\n- Aller à l'essentiel, d'abord faire fonctionner ce qu'on veut puis seulement essayer d'améliorer ou de simplifier\n- Isoler des fonctionnalités pour seulement ensuite les intégrer au code principal\n- Avancer petit à petit, ne pas essayer de tout faire en une fois\n- [Débugger](tutoriels/debugger.md), via le debugger de processing ou en affichant en console ce qu'il se passe, les valeurs, etc.\n\n## Exemple\n\nUn tutoriel processing (disponible ici) montrant comment réaliser le dessin d'une balle qui part du centre de l'écran vers une direction aléatoire, et rebondit sur les bords, est disponible ici : [http://oppr.org/s/JADVJw4f](http://oppr.org/s/JADVJw4f)\n","lastmodified":"2022-07-02T09:38:58.529044811Z","tags":null}}