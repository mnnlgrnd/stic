{"/":{"title":"Algorithmes et Programmation","content":"\n## Le√ßons\n\n### Th√©orie\n#### [01 - Variables et litt√©raux](cours/01-variables-litteraux.md) \n#### [02 - Expressions](cours/02-expressions.md)\n#### [03 - Tableaux et matrices](cours/03-tableaux-matrices.md)\n#### [04 - Alternatives](cours/04-alternatives.md)\n#### [05 - Boucles](cours/05-boucles.md)\n#### [06 - Fonctions](cours/06-fonctions.md)\n#### [07 - Blocs et contextes](cours/07-blocs-contextes.md)\n#### [08 - R√©cursivit√©](cours/08-recursivite.md)\n#### [09 - Classes](cours/09-classes.md)\n#### [10 - Strings](cours/10-strings.md)\n\n### Processing\n#### [11 - Bases de processing](cours/11-bases-processing.md)\n#### [12 - Dessins et g√©om√©trie](cours/12-dessins-geometrie.md)\n#### [13 - IntList et FloatList](cours/13-intlist-floatlist.md)\n#### [14 - Images et pixels](cours/14-images-pixels.md)\n#### [15 - Tables](cours/15-tables.md)\n\n\n\n## Tutoriels\n### [Structurer une solution processing](tutoriels/structurer-une-solution.md)\n### [D√©bugger](tutoriels/debugger.md)\n### [Jeu : Space Invaders simplifi√©](tutoriels/space-invaders.md)\n\n","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/01-variables-litteraux":{"title":"01 - Variables et litt√©raux","content":"\n## Variables\n\n### D√©finition\n\nUne variable est un **_conteneur_** d√©fini par\n\n-   Son **type** : le type de donn√©es qu'elle pourra contenir\n-   Son **nom** : le nom √† utiliser pour r√©cup√©rer la valeur qu'elle contient\n\n### Types\n\nLes types de variables dits **primitifs** sont les types inh√©rents au langage (ici, Java), on retrouve notamment\n\n| Type      | Valeurs                                                 |\n|:--------- |:------------------------------------------------------- |\n| `boolean` | `true` ou `false`                                       |\n| `char`    | Caract√®re, toujours √©crit entre `''`, par exemple `'a'` |\n| `short`   | Petit nombre entier entre `-128` et `127`               |\n| `int`     | Grand nombre entier entre `-2147483648` √† `2147483647`  |\n| `long`    | Tr√®s grand nombre entier                                |\n| `float`   | Nombre d√©cimal, par exemple `3.14`                      |\n| `double`  | Nombre d√©cimal plus pr√©cis                              |\n\n### D√©claration\n\nD√©clarer une variable permet de cr√©er une nouvelle variable qui sera d√©sormais utilisable dans la suite du code. Pour d√©clarer une variable, il faut imp√©rativement indiquer son type et son nom :\n\n```java\nint i;\n```\n\nDans ce cas-ci, la variable `i` existe maintenant en processing, mais ne contient encore aucune valeur. On peut √©galement d√©clarer une nouvelle variable **et** lui donner une valeur initiale :\n\n```java\nint i = 5;\n```\n\n#### Erreurs\n\n-   Lorsque l'on veut utiliser une variable qui n'existe pas, qui n'a pas √©t√© d√©clar√©e, processing affichera une erreur du type `The variable \"j\" does not exist`\n-  Lorsque l'on d√©clare une variable avec le m√™me nom qu'une autre variable, processing renverra une erreur du type `Duplicate local variable i`\n\n### Assignation\n\nL'assignation consiste √† d√©finir la (nouvelle) valeur d'une variable d√©clar√©e :\n\n```java\nint i; // D√©claration\ni = 5; // Assignation\n```\n  \n\nL'assignation est donc une ligne de code du type :\n\n\\\u003cnom\\_variable\\\u003e **=** \\\u003cvaleur\\\u003e ;\n  \nLe symbole **=** est **toujours** l'op√©rateur qui permet d'assigner une valeur √† une variable. La comparaison de deux valeurs se fait avec le symbole **\\=\\=**.\n\nOn peut mettre √† droite d'une assignation tout ce qui sera _√©valu√©_ par Processing au **m√™me type** que la variable √† laquelle on va assigner cette valeur.\n\n#### Exemples\n\n```java\n// D√©clarations\n\nint i;\nint j;\n\n// Assignations\n\ni = 5; // i va contenir 5\nj = 5 * 2; // j va contenir 5 * 2 -\u003e √©valu√© √† 10\ni = j; // i va contenir j -\u003e √©valu√© √† 10\ni = j * 2; // i va contenir j * 2 -\u003e √©valu√© √† 10 * 2 -\u003e √©valu√© √† 20\n```\n\n#### Erreurs\n\n- Lorsque l'on veut assigner √† une variable une valeur d'un type incompatible, par exemple `int i = 3.14;`, on aura une erreur du type `Type mismatch, \"float\" does not match with \"int\"`\n\n### Evaluation\n\nL'**√©valuation** est l'interpr√©tation, par Processing, d'un morceau de code, une **[expression](cours/02-expressions.md)**, pour en d√©duire une **valeur.** Une expression peut √™tre \n\n-   Une valeur (par exemple `1`, `'a'`, `true`, etc.)\n-   Une variable\n-   Un appel de fonction : le type de la valeur sera le type de retour de cette fonction, par exemple `float f = random(0, 1)`, on assigne √† la variable `f` un nombre al√©atoire entre 0 et 1 que nous retourne la fonction `random`\n-   Un calcul impliquant des valeurs, variables ou appels de fonction : processing respectera alors l'ordre des op√©rateurs/parenth√®ses\n\nUne expression peut donc √™tre utilis√©e\n\n-   Pour une assignation\n\n```java\nint i = 5;\ni = 5 * 2;\ni = i + 1;\n```\n\n-   Dans un appel de fonction\n\n```java\nprintln(i); // On affiche ce que contient la variable i\n```\n\n### Constantes\n\nSi la valeur contenue dans une variable n'est pas amen√©e √† √©voluer pendant l'ex√©cution du programme, mais qu'elle restera toujours la m√™me, on peut imposer cette contrainte en d√©clarant explicitement une variable *constante*. Pour ce faire, il faut utiliser le mot cl√© `final` avant le type de la variable.\n\n```java\nfinal int CONSTANT = 1;\n```\n\nPour facilement diff√©rencier les variables constantes, qui sont donc des variables auxquelles on ne pourra assigner qu'une seule fois une valeur, il est conseill√© de mettre leur nom enti√®rement en majuscule.\n\nSi, par inadvertance, on essaie malgr√© tout d'assigner une nouvelle valeur √† une variable constante, on aura une erreur du type `Final local variable \u003cname\u003e may already have been assigned`.\n\n## Litt√©raux\n\n### D√©finition\n\nA la diff√©rence d'une variable, un *litt√©ral* qualifie une valeur constante utilis√©e directement dans du code. \n\n### Type\n\nTout comme une variable, un litt√©ral a un type, mais celui est en g√©n√©ral implicite et inf√©r√© directement par le langage. On retrouve diff√©rents litt√©raux :\n- `true` et `false`, les litt√©raux de type bool√©en\n- Les litt√©raux de nombres entiers comme `1`, `23094`, etc.\n- Les litt√©raux de nombres √† virgule, comme `3.14`, `-23.45`, etc. On peut forcer le type d'un litt√©ral de nombre √† √™tre `float` ou `double`  en utilisant `f` ou `d` apr√®s le litt√©ral :\n\t- `1f` est de type `float`\n\t- `3.14d` est de type `double`\n- Les litt√©raux de type caract√®re (`char`) comme `'a'`, `'+'`, etc. ; n'importe quel caract√®re entre deux `'`\n- Les litt√©raux de cha√Ænes de caract√®res (strings), vu dans la le√ßon [09 - Strings](cours/10-strings.md)\n\n### Assignation √† une variable\n\nLorsque l'on utilise un litt√©ral dans une assignation pour stocker sa valeur dans une variable, il faut donc que ce type *corresponde* √† celui de la variable. \n\n\u003e **Correspondance n'est ici pas √©quivalence**. \n\nLe litt√©ral `10` est de type entier, mais peut tout √† fait √™tre stock√© dans une variable de type `float` puisque float peut contenir des nombres de plus grande pr√©cision. Le contraire n'est pas vrai ; par exemple, le litt√©ral `3.14` contient un nombre √† virgule qui ne peut pas √™tre stock√© dans une variable enti√®re (`int`,  `long`) car la pr√©cision du litt√©ral est plus grande que celle du type de la variable. Il faut alors convertir explicitement le litt√©ral en entier via la fonction de conversion `int`, par exemple `int(3.14)`, qui ne conservera que la partie enti√®re du nombre.","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/02-expressions":{"title":"02 - Expressions","content":"\n\n## D√©finition\n\nEn Java, une **expression** est une √©criture poss√©dant une ***valeur*** et un ***type*** et dans laquelle on peut retrouver :\n- Des litt√©raux\n- Des noms de variables\n- Des op√©rateurs\n- Des appels de [fonctions](cours/06-fonctions.md)\n\nLa ***valeur*** d'une expression est calcul√©e en tenant compte des valeurs contenues dans les variables apparaissant dans l'expression et des valeurs retourn√©es par les appels de fonction. Le ***type*** de l'expression est le type de cette valeur, du r√©sultat.\n\nLes op√©rateurs possibles dans une expression d√©pendent de son type. Comme dans des expressions math√©matiques classiques, la priorit√© des op√©rateurs est respect√©e pour obtenir le r√©sultat final, et on peut utiliser des parenth√®ses \n\n## Expressions bool√©ennes\n\nLes expressions bool√©ennes sont des expressions dont le type est `boolean`, c'est-√†-dire des expressions dans la valeur est `true` ou `false`. \n\n### Op√©rateurs \n\nLes op√©rateurs possibles dans les expressions bool√©ennes sont donc les op√©rateurs logiques de base ainsi que les op√©rateurs de comparaison entre nombres.\n\nLes op√©rateurs logiques sont, dans l'ordre des priorit√©s :\n\n- `!`, la n√©gation \n- `\u0026\u0026`, le ET logique\n- `||` , le OU logique\n\n```java\nprintln(true); // Affiche true\nprintln(!true); // Affiche false\nprintln(true || false); // Affiche true\nprintln(true \u0026\u0026 false); // Affiche false\n\nprintln(true || false \u0026\u0026 false); // Affiche true car on fait d'abord le \u0026\u0026\n                                 // Ca √©quivaut donc √† true || false -\u003e true\nprintln((true || false) \u0026\u0026 false); // Affiche false car on respecte les parenth√®ses\n                                   // Ca √©quivaut donc √† true \u0026\u0026 false -\u003e false\n``` \n\nLes op√©rateurs de comparaison ont tous le m√™me ordre d'importance, et sont :\n\n- `==` , l'√©galit√©\n- `!=` , la diff√©rence\n- `\u003e` , strictement plus grand\n- `\u003e=`, plus grand ou √©gal\n- `\u003c`, strictement plus petit\n- `\u003c=`, plus petit ou √©gal\n\n```java\nprintln(1 == 1); // Affiche true\nprintln(1 != 1); // Affiche false\nprintln(2 \u003e 1); // Affiche true\nprintln(1 \u003e= 2); // Affiche false\nprintln(1 \u003c 2); // Affiche true\nprintln(2 \u003c= 1); // Affiche false\n```\n\n## Expressions math√©matiques\n\nLes expressions math√©matiques sont des expressions dont le r√©sultat est de type num√©rique (entier ou flottant). Les op√©rateurs sont donc les op√©rateurs classiques en math√©matiques, dans l'ordre des priorit√©s :\n\n- `*` et `/` pour la multiplication et la division\n- `+` et `-` pour l'addition et la soustraction\n\n```java\nprintln(1 + 1); // Affiche 2\nprintln(3 * 3); // Affiche 9\nprintln(2 + 2 * 2); // Affiche 6\n```\n\n### Entiers et flottants\n\nIl faut bien faire attention aux types des valeurs que l'on utilise dans une expression car ce sont eux qui d√©terminent le type du r√©sultat. \n\nLorsqu'une expression ne contient que des valeurs enti√®res, le r√©sultat sera lui-m√™me entier, et ce m√™me si la vraie expression math√©matique correspondante ne l'est pas. Ainsi, l'expression `1 / 2` ne contient que des entiers, et le r√©sultat sera donc le r√©sultat de la *division enti√®re* de 1 par 2, qui vaut donc `0`. \n\nDe fa√ßon plus g√©n√©rale, si une expression ne contient que des valeurs du m√™me type, ce sera aussi le type de l'expression. Si par contre l'expression contient des valeurs de diff√©rents types, l'expression prendra le type ayant la plus grande pr√©cision (voir [01 - Variables et litt√©raux](cours/01-variables-litteraux.md)).\n\nAinsi, si une expression contient des valeurs de type `int` et des valeurs de type `float`, donc flottantes, l'expression sera de type `float`. Par exemple, le r√©sultat de `1.0 / 2` est flottant, et il s'agit donc de la division normale dont le r√©sultat `0.5`.\n\n```java\nint m = 1 / 2; // 0\nfloat n = 1.0 / 2; // 0.5\n```\n\n### Modulo\n\nOn peut √©galement utiliser l'op√©rateur `%` pour le \"modulo\", le reste de la division enti√®re. \n\n```java\nprintln(1 % 4); // Affiche 1\nprintln(10 % 4); // Affiche 2\nprintln(12 % 4); // Affiche 0\n```\n\nL'utilisation du modulo permet de transformer une suite continue en un cycle de valeurs allant de 0 √† la valeur du modulo - 1 :\n\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/modulo_dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/modulo_lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n### Sucres syntaxiques\n(A prononcer avec l'accent qu√©becois car c'est la seule bonne raison de traduire un terme anglais)\n\nLes sucres syntaxiques, ou *syntactic sugars*, sont des facilit√©s, des raccourcis de code qu'un langage met √† disposition des utilisateurs.\n\n#### Raccourcis math√©matiques\n\nPour les op√©rations math√©matiques, Java propose des raccourcis pour les calculs de la forme *x = x \\\u003cop√©rateur\\\u003e \\\u003cexpression\\\u003e*. C'est-√†-dire quand on assigne √† une variable le r√©sultat d'une op√©ration simple entre cette variable et une autre expression. On peut √©viter de r√©p√©ter la variable *x* en utilisant le sucre syntaxique correspondant *x \\\u003cop√©rateur\\\u003e= \\\u003cexpression\\\u003e*. Ceci est valable pour les 4 op√©rateurs math√©matiques standards `+`, `-`, `*` et `/`.\n\n```java\nint i = 0;\n\ni = i + 5; // Forme normale\ni += 5; // Sucre syntaxique \n\ni = i * (45 / 3); // Forme normale\ni *= 45 / 3; // Sucre syntaxique\n```\n\n#### Incr√©mentation et d√©cr√©mentation\n\nDe plus, lorsque le calcul est de type *x = x + 1* ou *x = x - 1*, on peut davantage simplifier la ligne de code en utilisant les op√©rateurs d'incr√©mentation `++` et de d√©cr√©mentation `--`.\n\n```java\nint i = 0;\n\ni = i + 1; // Forme normale\ni++; // Incr√©mentation\n\ni = i - 1; // Forme normale\ni--; // D√©cr√©mentation\n```\n\n##### üïµ‚Äç‚ôÄ Comme expression\n\nLes op√©rateurs `++` et `--` peuvent s'utiliser avant ou apr√®s la variable √† incr√©menter/d√©cr√©ment√©r. Dans les deux cas, la valeur de la variable sera mise √† jour avec le r√©sultat de l'addition/soustraction avec 1.\n\nLa diff√©rence r√©side dans le fait qu'il s'agit d'une expression ; on peut donc utiliser l'incr√©mentation/d√©cr√©mentation comme expression pour une assignation : `int y = x++`. Dans ce cas, l'ordre dans lequel Java va effecter le calcul et l'√©valuation de la valeur √† assigner √† la deuxi√®me variable d√©pend du placement de l'op√©rateur `++` ou `--` :\n\n- Si l'op√©rateur se situe *apr√®s* la variable `x` , alors Java va d'abord √©valuer la valeur actuelle de cette variable. Cette valeur sera assign√©e √† la variable `y`, puis le calcul incr√©mental/d√©cr√©mental sera effectu√© et la valeur de `x` chang√©e\n\n```java\nint x = 0;\nint y = x++;\nprintln(x); // Affiche 1\nprintln(y); // Affiche 0\n```\n\n- Si l'op√©ration se situe *avant* la variable `x`, c'est l'inverse. C'est d'abord l'incr√©mentation/d√©cr√©mentation qui est faite, puis cette nouvelle valeur de `x` sera assign√©e √† `y`.\n\n```java\nint x = 0;\nint y = ++x;\nprintln(x); // Affiche 1\nprintln(y); // Affiche 1\n```","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/03-tableaux-matrices":{"title":"03 - Tableaux et matrices","content":"\n## Tableaux\n\n### D√©finition\n\nUn **tableau** est une collection ordonn√©e de variables du m√™me type. On acc√®de a une variable du tableau gr√¢ce au nom du tableau et √† la position de la variable dans celui-ci.\n\nUn tableau est un type de donn√©es au m√™me titre que le sont `int`, `float`, etc. Il s'agit cependant d'un type dit *r√©f√©rentiel* et non primitif, car la variable de type tableau contient en r√©alit√© une r√©f√©rence vers un une suite de blocs en m√©moire contenant les variables du tableau.\n\n### Stockage en m√©moire\n\nLorsqu'un programme processing s'ex√©cute, il poss√®de sa propre m√©moire dans laquelle seront stock√©es toutes les variables et tout ce qu'il se d√©roule dans le programme (appels de fonction, etc.). Cette m√©moire se compose de deux parties :\n\n- La m√©moire dite statique, le *stack*, qui contient notamment les variables (locales) de type primitif et des **r√©f√©rences** vers des donn√©es stock√©es dans le *heap*\n- La m√©moire dite dynamique, le *heap*, qui contient notamment des tableaux et des [objets](cours/09-classes.md)\n\n\u003cimg src=\"/stic/images/stack_heap_dm.svg\" class=\"svg-dark-mode\"/\u003e\n\u003cimg src=\"/stic/images/stack_heap_lm.svg\" class=\"svg-light-mode\"/\u003e\n\n\u003e ‚ö† Le stockage en m√©moire est en r√©alit√© plus complexe, l'important ici est de comprendre la diff√©rence entre une valeur et une r√©f√©rence. Pour plus de d√©tails sur la gestion de la m√©moire lors de l'ex√©cution d'un programme Java, Google est votre ami.\n\n## D√©claration\n\nOn d√©clare un tableau comme on d√©clare une [variable](cours/01-variables-litteraux.md), √† ceci pr√®s qu'il faut rajouter l'op√©rateur `[]` pour indiquer qu'il s'agit d'un tableau. On peut ajouter cet op√©rateur soit apr√®s le **type** de donn√©es du tableau, soit apr√®s son nom. Il s'agit de d√©clarations √©quivalentes.\n\n```java\nint[] integers;\n```\n\nou\n\n```java\nint integers[];\n```\n\nOn d√©clare ici une variable appel√©e `integers` qui est un tableau de nombres entiers.\n\n## Cr√©ation\n\nIl existe deux fa√ßons de cr√©er un tableau :\n\n1. On peut cr√©er un tableau vide en indiquant sa taille, le nombre d'√©l√©ments qu'il contient.\n\n```java\nint[] integers = new int[6];\n```\n\n2. On peut cr√©er un tableau en indiquant directement les valeurs qu'il contient entre `{}`. La taille du tableau sera donc le nombre d'√©l√©ments qu'on d√©finit.\n\n```java\nint[] integers = new int[] { 1, 2, 4, 8, 16, 32 };\n```\n\nDans les deux cas, l'utilisation du mot cl√© `new` est obligatoire. Ce mot cl√© indique qu'on cr√©e une nouvelle **r√©f√©rence** et est responsable de l'allocation en m√©moire.\n\n## Manipulation\n\nUne fois un tableau d√©clar√© et cr√©√©, on peut acc√©der √† sa taille et aux diff√©rents √©l√©ments qu'il contient.\n\n### Taille du tableau\n\nLa taille d'un tableau **est d√©termin√©e √† sa cr√©ation et ne peut pas √™tre chang√©e**, on peut la r√©cup√©rer gr√¢ce au champ sp√©cial `length` du tableau, de la fa√ßon suivante :\n\n```java\nint[] integers = new int[] { 1, 2, 3 };\nprintln(integers.length); // Affiche 3\n```\n\n### √âlements du tableau\n\nPour acc√©der √† un √©l√©ment particulier du tableau, il faut utiliser l'op√©rateur de tableau et l'indice de l'√©l√©ment apr√®s le nom du tableau, par exemple `integers[1]`.\n\n\u003e ‚ö† En informatique, on commence √† compter √† partir de 0. Le premier √©l√©ment aura donc l'indice 0, le deuxi√®me l'indice 1, ainsi de suite.\n\nLorsque l'on acc√®de √† un √©l√©ment du tableau, on r√©cup√®re une variable (celle stock√©e dans le heap), et on peut donc s'en servir comme tel ; c'est-√†-dire lui assigner une valeur, ou l'√©valuer dans des expressions.\n\n```java\nint[] integers = new int[] { 1, 2, 3 };\n\n// Evalue la variable √† l'indice 0 dans le tableau et affiche 1\nprintln(integers[0]); \n\n// Assigne la valeur 0 √† la variable √† l'indice 1 dans le tableau\nintegers[1] = 0; \n\n// Evalue la variable √† l'indice 1 dans le tableau et affiche 0\nprintln(integers[0]);\n\n// Evalue la variable √† l'indice 2 dans le tableau et affiche 3\nprintln(integers[2]); \n```\n\n### Parcourir le tableau\n\nPour parcourir un tableau, c'est-√†-dire pour *it√©rer* sur chacun de ces √©l√©ments, il faudra utiliser une boucle dont les explications sont disponibles dans la le√ßon [06 - Boucles](cours/05-boucles.md).\n\n### Erreurs\n\n- Lorsque l'on essaie d'acc√©der √† un √©l√©ment dont l'indice est sup√©rieur √† la taille du tableau, c'est-√†-dire √† une position **hors** du tableau, l'ex√©cution du code provoquera une erreur du type `ArrayIndexOutOfBoundsException` avec l'indice auquel on a voulu acc√©der.\n\n\n## Matrices\n\n### Tableau de tableaux\n\nUn tableau √©tant un type de donn√©es, il est tout √† fait possible de d√©finir un tableau *de tableaux*, c'est-√†-dire un tableau dont tous les √©l√©ments sont des r√©f√©rences vers des tableaux d'un (m√™me) type de donn√©es. On peut ainsi avoir un tableau de tableaux d'entiers (2 dimensions), un tableau de tableaux de tableaux de bool√©ens (3 dimensions), etc. Tous les tableaux d'une m√™me dimension auront la m√™me taille, puisque la taille d'un tableau est statique et d√©finie √† sa cr√©ation.\n\n\u003cimg src=\"/stic/images/matrix_dm.svg\" class=\"svg-dark-mode\"/\u003e\n\u003cimg src=\"/stic/images/matrix_lm.svg\" class=\"svg-light-mode\"/\u003e\n\nUne matrice est un tableau de tableaux : un tableau √† deux dimensions, comme dans Excel, par exemple. On parlera ainsi de **lignes** pour la premi√®re dimension et de **colonnes** pour la deuxi√®me dimension.\n\n### D√©claration\n\nPour d√©clarer une matrice, il faut simplement d√©clarer un tableau dont le type d'√©l√©ments est lui-m√™me tableau, c'est-√†-dire en rajoutant `[]` apr√®s le type d'√©l√©ments de ce tableau. Par exemple, un tableau de tableaux d'entiers sera not√© `int[][]`. \n\n```java\nint[][] t1; // Tableau de tableaux d'entiers\nfloat[][] t2; // Tableau de tableaux de float\nboolean[][] t3; // Tableau de tableaux de bool√©ens\n```\n\n### Cr√©ation\n\nComme pour un tableau \"classique\", √† une seule dimension, une matrice peut √™tre cr√©√©e de deux fa√ßons :\n\n1. On peut cr√©er une matrice vide en indiquant la taille du tableau (le nombre de lignes), et la taille des tableaux se trouvant dans ce tableau principal (le nombre de colonnes) dans l'op√©rateur `[]`, un par dimension.\n\n```java\n// Tableau contenant 3 tableaux de 10 √©l√©ments chacun\nint[][] integers = new int[3][10]; \n```\n\nOn peut donc ainsi cr√©er des tableaux de dimension compl√®tement arbitraire :\n\n```java\nint[][][][][] whyNot = new int[3][6][9][6][3];\n```\n\n2. On peut cr√©er une matrice en indiquant directement les valeurs qu'elle contient entre `{}`. Les accolades d√©limitent **un** tableau, et pour d√©finir le contenu de la deuxi√®me dimension, le contenu de chaque ligne, il faut aussi utiliser `{}`. Les tailles des tableaux seront alors d√©termin√©es automatiquement.\n\n```java\nint[][] integers = new int[][] { \n  { 1, 2, 3 }, // Premi√®re ligne\n  { 4, 5, 6 }, // Deuxi√®me ligne\n  { 7, 8, 9 }  // Troisi√®me ligne\n};\n```\n\n### Taille de la matrice\n\nPour la taille de la matrice, on parlera plus simplement de son nombre de lignes et de colonnes, qui sont, respectivement, la taille du tableau de la premi√®re dimension et la taille des tableaux de la deuxi√®me dimension. On peut r√©cup√©rer ces informations comme on le ferait pour un tableau quelconque.\n\n```java\nint[][] m = new int[][] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint nbLines = m.length;\nint nbColumns = m[0].length; // m[0] = premi√®re ligne\n```\n\n### √âlements de la matrice\n\nOn acc√®de aux **lignes** d'une matrice de la m√™me fa√ßon qu'on manipule un tableau, avec l'op√©rateur `[]`, et aux √©l√©ments d'une ligne en r√©utilisant l'op√©rateur `[]` sur la ligne r√©cup√©r√©e, puisqu'il s'agit √©galement d'un tableau.\n\n```java\nint[][] m = new int[][] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint[] firstLine = m[0];\nint[] secondLine = m[1];\nint firstElementOfFirstLine = firstLine[0];\nint lastElementOfThirdLine = m[2][2];\n\nprintln(m[1][1]); // Affiche 5\nm[1][1] = 10;\nprintln(m[1][1]); // Affiche 10\n```\n\nOn parlera en g√©n√©ral de coordonn√©es *i* et *j* des √©l√©ments dans la matrice :\n- i est l'indice de la ligne, √† utiliser dans les premiers `[]`\n- j est l'indice de la colonne, √† utiliser dans les deuxi√®mes `[]` (les crochets qui s'appliquent donc sur la ligne, le tableau, r√©cup√©r√©e par les premiers crochets)\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/matrix_ix_dm.svg\" class=\"svg-dark-mode w-50\"/\u003e\n\u003cimg src=\"/stic/images/matrix_ix_lm.svg\" class=\"svg-light-mode w-50\"/\u003e\n\u003c/p\u003e\n\n### Parcourir une matrice\n\nPour parcourir une matrice, c'est-√†-dire pour *it√©rer* sur chacun de ses √©l√©ments, il faudra utiliser des boucles imbriqu√©es dont les explications sont disponibles dans la le√ßon [05 - Boucles](cours/05-boucles.md).","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/04-alternatives":{"title":"04 - Alternatives","content":"\n## D√©finition\n\nUne alternative, ou branchement conditionnel, est un *bloc de code* dont l'ex√©cution est **optionnelle** et d√©pend d'une certaine **condition**, **une [expression](cours/02-expressions.md) bool√©enne** dans laquelle on retrouve en g√©n√©ral des variables utilis√©es avant cette alternative.\n\n## Branchement `if` simple {id=\"branchementsimple\"}\n\nOn commence toujours une alternative par le mot cl√© `if` suivi de la condition entre parenth√®ses. Le code optionnel est le bloc de code compris entre les accolades `{}` venant apr√®s le `if`.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est √† √©gal √† 0\n  println(\"i est √©gal √† 0\");\n}\n\nprintln(\"Apr√®s le if\");\n```\n\n## Branchement avec `else`\n\nLe mot cl√© `else` permet d'ex√©cuter un bloc de code optionnel, diff√©rent, lorsque la condition du `if` le pr√©c√©dant n'est pas remplie. Il faut encore une fois mettre ce bloc de code entre accolades `{}`.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est √† √©gal √† 0\n  println(\"i est √©gal √† 0\");\n} else {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i n'est pas √©gal √† 0\n  println(\"i n'est pas √©gal √† 0\");\n}\n\nprintln(\"Apr√®s le if/else\");\n```\n\n## Branchement multiple avec `else if`\n\nIl est possible de faire un branchement multiple avec diff√©rentes conditions, chacune ayant son propre bloc de code optionnel. Ce branchement multiple commence toujours par un `if`, et chaque branche conditionnelle suppl√©mentaire est introduite via le mot cl√© `else if` suivi de la condition entre parenth√®ses.\n\nD√®s que la condition d'un des branchements est respect√©e, le bloc de code correspondant sera ex√©cut√©, et **on finit le branchement** ; on en sort et continue l'ex√©cution du code suivant le branchement.\n\nDans le cas d'un branchement multiple, le branchement `else`, si pr√©sent, ne sera donc ex√©cut√© que lorsqu'aucune condition de tous les `if`/`else if` n'est remplie.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est √† √©gal √† 0\n  println(\"i est √©gal √† 0\");\n} else if (i \u003e 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est strictement sup√©rieur √† 0\n  println(\"i est plus grand que 0\");\n} else {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i n'est ni √©gal, ni sup√©rieur √† 0\n  println(\"i n'est pas √©gal ni plus grand que 0\");\n}\n\nprintln(\"Apr√®s le if/else\");\n```\n\n\u003e ‚ö† Encha√Æner plusieurs branchements `if` n'est pas √©quivalent √† un branche `if`/`else if`.  Dans le cas de `if` cons√©cutifs, chaque branchement/condition sera √©valu√© ; dans le cas d'un branchement multiple `if`/`else if`, l'√©valuation des conditions s'arr√™te d√®s lors que la condition d'une des branches est respect√©e.\n\n## Branchements imbriqu√©s\nOn parle d'*imbrication* lorsqu'on utilise un branchement conditionnel √† l'int√©rieur d'un autre branchement conditionnel.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est √† √©gal √† 0\n  println(\"i est √©gal √† 0\");\n} else if (i \u003e 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est strictement sup√©rieur √† 0\n  println(\"i est plus grand que 0\");\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n} else {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i n'est ni √©gal, ni sup√©rieur √† 0\n  println(\"i n'est pas √©gal ni plus grand que 0\");\n  if (i \u003c -5) {\n    println(\"i est plus petit que -5\");\n  }\n}\n\nprintln(\"Apr√®s le if/else\");\n```\n\n## Remarques\n\n### Blocs et indentation\nUn bloc de code est d√©limit√© par des accolades `{}`. Pour une meilleure lisibilit√© du code, il est important de penser √† *indenter* chaque bloc, c'est √† dire √† le d√©caler (vers la droite) du bloc de code qui l'englobe. L'indentation est compl√®tement optionnelle mais essentielle pour un code propre et lisible. \n\nOn peut ainsi facilement voir, dans le cas des branchements conditionnels, dans quelle branche se situe le bloc de code. Cela devient encore plus utile lorsqu'on a plusieurs `if` imbriqu√©s.\n\n```java\nint i = int(random(-10, 10));\n\n// Peu lisible\nif (i \u003e 0) {\nprintln(\"i est plus grand que 0\");\nif (i \u003e 5) {\nprintln(\"i est plus grand que 5\");\n}\n}\n\n// Avec accolades\nif (i \u003e 0) {\n  println(\"i plus grand que 0\");\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n}\n```\n\n### Notation alternative\n\nLorsqu'un bloc de code conditionnel ne contient qu'une seule ligne de code *ex√©cutable*, on peut se passer des accolades `{}`. \n\n```java\nint i = int(random(-10, 10));\n\n// Avec accolades\nif (i \u003e 0) {\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n}\n\n// Sans accolades\nif (i \u003e 0)\n  if (i \u003e 5)\n    println(\"i est plus grand que 5\");\n```\n\nComme on le voit ici, le `if` imbriqu√© et ce qu'il contient ne sont consid√©r√©s que comme un seul bloc ex√©cutable, et on peut donc se passer des accolades autour m√™me s'il s'agit, visuellement, de plus qu'une seule ligne de code.\n\n\u003e ‚ö† Pour √©viter des probl√®mes, je conseille d'√©viter cette notation et de toujours utiliser les accolades pour d√©limiter les blocs.\n\n\n","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/05-boucles":{"title":"05 - Boucles","content":"\n## D√©finition\n\nUne boucle est un *bloc de code* dont l'ex√©cution est **optionnelle** et **r√©p√©t√©e** tant que la **condition**, **une [expression](cours/02-expressions.md) bool√©enne**, est respect√©e. \n\nLa logique est similaire √† celle d'un [branchement conditionnel simple](/cours/04-alternatives.md#branchementsimple), √† la diff√©rence que dans un branchement conditionnel, on passe √† la suite du code lorsqu'on finit l'ex√©cution du bloc optionnel. Dans le cas d'une boucle, apr√®s une ex√©cution du bloc optionnel, on revient √† la condition qui est alors r√©√©valu√©e pour √©ventuellement recommencer l'ex√©cution du bloc de code.\n\n## Boucle `while`\n\nLa boucle de base est d√©finie par l'utilisation du mot cl√© `while` suivi de la condition entre parenth√®ses et du bloc de code optionnel entre accolades `{}`. La structure est la m√™me que pour le branchement simple `if`.\n\n```java\nint i = 0;\n\nwhile (i \u003c 5) {\n  println(i);\n  i += 1;\n}\n```\n\nLe code ci-dessus affichera donc successivement, dans la console :\n\n```bash\n0\n1\n2\n3\n4\n```\n\nPour qu'une boucle ait du sens, il faut que le code optionnel manipule et change la ou les variables impliqu√©es dans la condition de cette boucle, sans quoi on pourrait cr√©er des boucles \"infinies\" pour lesquells la condition est toujours vraie car ind√©pendante du code de la boucle.\n\n```java\nint i = 0;\n\nwhile (i \u003c 5) { // i ne change pas et on ne sort jamais de la boucle\n  println(i);\n}\n```\n\n\n## Boucle `for`\n\n On utilise r√©guli√®rement des boucles pour r√©p√©ter un certain nombre de fois un m√™me bloc de code, et la condition de cette boucle ne repr√©sente donc que le nombre d'it√©rations voulues. Dans ce cas, il est parfois plus simple d'utiliser une autre boucle, la boucle `for`. Cette boucle se compose de trois parties :\n - L'initialisation d'une variable \"compteur\". Cette variable peut avoir d√©j√† √©t√© d√©clar√©e dans le code, ou il peut s'agir d'une nouvelle variable d√©clar√©e uniquement dans le contexte de cette boucle\n - Une condition pour continuer √† boucler. On veut en g√©n√©ral que la variable compteur soit plus petite qu'une *borne* (le nombre de r√©p√©titions souhait√©es).\n - Une it√©ration, une assignation qui modifie la valeur de la variable compteur pour passer √† l'√©tape suivante.\n\nLa boucle est donc de la forme *for (\\\u003cinitialisation\\\u003e; \\\u003ccondition\\\u003e; \\\u003cassignation\\\u003e) {  }*\n\n```java\n// Avec while\nint i = 0;\nwhile (i \u003c 5) {\n   println(i);\n   i++;\n}\n\n// La boucle for √©quivalente\nfor (int j = 0; j \u003c 5; j++) {\n  println(j);\n}\n```\n\n## Boucles imbriqu√©es\n\nDe la m√™me fa√ßon qu'on peut mettre des branchements conditionnels `if` dans d'autres branchements, et avoir donc des `if` imbriqu√©s, on peut tout √† fait mettre des boucles dans des boucles, des boucles dans des branchements conditionnels, des branchements conditionnels dans des boucles, etc.\n\n```java\nint i = 0;\nwhile (i \u003c 3) {\n  println(i);\n  int j = 0;\n  while (j \u003c 3) {\n    println(j);\n    j++;\n  }\n  i++;\n}\n```\n\nLe code ci-dessus affichera donc successivement, dans la console :\n\n```plain\n0\n0\n1\n2\n1\n0\n1\n2\n2\n0\n1\n2\n```\n\n## Parcourir des tableaux\nLes boucles sont particuli√®rement utiles lorsque l'on manipule des [tableaux](cours/03-tableaux-matrices). On peut utiliser une boucle pour parcourir tous les √©l√©ments du tableau et ex√©cuter un bloc de code similaire pour chaque √©l√©ment. Le plus simple est alors d'utiliser une boucle `for` qui it√®re sur chaque position dans le tableau, donc de `0`  √† la taille du tableau - 1. Pour rappel, on peut obtenir la taille d'un tableau gr√¢ce au champ `length` de ce tableau.\n\n```java\nint[] t = new int[] { 1, 2, 3, 4, 5 };\n\nfor (int i = 0; i \u003c t.length; i++) {\n   println(t[i]);\n}\n```\n\nLe code ci-dessus parcoure ainsi tous les √©l√©ments du tableau et affiche leur valeur dans la console.\n\nEn d√©finissant la borne sup√©rieur comme √©tant la taille `length` du tableau, et non une valeur fixe (dans ce cas-ci on aurait pu mettre 5), le code fonctionnera peu importe la taille effective du tableau que l'on a cr√©√© avant la boucle, puisque la vraie taille sera toujours utilis√©e.\n\n## Parcourir des matrices\n\nGr√¢ce aux boucles imbriqu√©es, il est tr√®s facile de parcourir une matrice, un tableau de tableaux. On peut en effet it√©rer sur les lignes dans une boucle, et sur chaque colonne de cette ligne dans une boucle imbriqu√©e, ou invers√©ment (les colonnes puis les lignes par colonne).\n\nComme pour un tableau √† une dimension, il est plus facile d'utiliser des boucles `for` que des boucles `while`. On choisit en g√©n√©ral comme nom de variable compteur `i` pour la premi√®re dimension, les lignes, et `j` pour la deuxi√®me, les colonnes. Ces noms sont tout √† fait arbitraires et pourraient √™tre chang√©s, mais garder une certaine coh√©rence de nommage, comme utiliser le m√™me nom pour les variables repr√©sentant des indices de ligne et pour celles repr√©sentant des indices de colonne, permet de naviguer plus ais√©ment dans son propre code.\n\n```java\nint[][] m = new int[][] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint nbLines = m.length;\nfor (int i = 0; i \u003c nbLines; i++) {\n  // i va prendre successivement la position de chaque ligne\n  // On r√©cup√®re le nombre de colonnes dans la ligne i\n  int nbColumns = m[i].length;\n  for (int j = 0; j \u003c nbColumns; j++) {\n  // On affiche la coordonn√©e (i,j) et la valeur de l'√©l√©ment correspondant\n    println(i, j, m[i][j]);\n  }\n}\n```\n\nCe code affiche les coordonn√©es (ligne, colonne) de chaque √©l√©ment de la matrice et la valeur de cet √©l√©ment, en commen√ßant par la premi√®re ligne et toutes ses colonnes, la deuxi√®me ligne, etc. On verra donc, dans la console :\n\n```plain\n0 0 1\n0 1 2\n0 2 3\n1 0 4\n1 1 5\n1 2 6\n2 0 7\n2 1 8\n2 2 9\n```","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/06-fonctions":{"title":"06 - Fonctions","content":"\n## D√©finition\n\nUne fonction permet de d√©finir un bloc de code **r√©utilisable** que l'on pourra **appeler** √† n'importe quel moment dans le code.\n\n### Signature\n\nPour pouvoir appeler une fonction, il faut la d√©clarer en sp√©cifiant :\n- Son **type** de retour (`int`, `float`, etc.) ou `void` si elle ne renvoie rien\n- Son **nom** ; √† utiliser pour appeler la fonction\n- Ses **param√®tres** ; leur type et leur nom\n\nEt le code de cette fonction entre accolades `{}` en respectant la syntaxe \n\n*\\\u003ctype\\\u003e \\\u003cnom\\\u003e(\\\u003ctype_p_1\\\u003e \\\u003cnom_p_1\\\u003e, ..., \\\u003ctype_p_n\\\u003e \\\u003cnom_p_n\\\u003e) { \n   // code\n}*\n\nUne fonction peut ne pas avoir de param√®tres si on ne met rien dans les parenth√®ses, mais elles restent obligatoires.\n\nLe type de retour, le nom et le type des param√®tres constituent ce qu'on appelle la **signature** d'une fonction. On ne peut pas cr√©er deux fonctions ayant la m√™me signature, le code affichera alors l'erreur `Duplicate method \u003csignature\u003e`.\n\n\u003e‚Ñπ L'ordre dans lequel les fonctions sont d√©finies n'a pas d'importance\n\n## Appel et ex√©cution\n\nUn **appel** √† une fonction consiste √† utiliser le nom de la fonction suivi de parenth√®ses avec, √©ventuellement, les valeurs √† passer aux param√®tres de cette fonction. \n\nIl faut obligatoirement appeler la fonction en respectant sa signature ; les valeurs pass√©es doivent correspondre en nombre et en type aux param√®tres d√©finis dans la signature de la fonction qu'on appelle. Sinon, le code affichera une erreur du type `The function \"\u003cname\u003e\" expects parameters like: \u003csignature\u003e`.\n\nLorsque le programme arrive sur l'appel √† la fonction, il ex√©cutera le bloc de code de cette fonction dans un [contexte](cours/07-blocs-contextes) diff√©rent dans lequel ne seront disponibles que les variables globales et les param√®tres de la fonction.\n\n```java\nvoid foo() {\n  println(\"foo\");\n}\n\nint bar(int i) {\n  return i * 2;\n}\n\nvoid setup() {\n  foo(); // Appelle la fonction foo, qui va afficher foo \n  println(bar(1)); // Affiche le r√©sultat de l'appel √† bar(1) : 2\n}\n```\n\nLorsque l'ex√©cution du code est termin√©e, la ligne de code suivant celle de l'appel est la prochaine qui sera ex√©cut√©e.\n\n\u003e ‚ö† Pour qu'un code avec des fonctions et appels de fonction soit ex√©cutable en processing, il est obligatoire de mettre les appels de fonction dans une des fonctions de processing (setup, draw, etc.) et pas dans le contexte global.\n\n## Retour de fonction\n\n### Fonctions avec retour\n\nUne fonction qui *retourne* ou *renvoie* une valeur doit avoir d√©fini son type de retour, c'est-√†-dire le type de la valeur qu'elle renvoie. Pour qu'une fonction retourne effectivement une valeur, il faut utiliser le mot cl√© `return` suivi d'une expression, dans la fonction. Cette expression sera renvoy√©e par l'appel √† la fonction, et on pourra utiliser des appels √† cette fonction dans d'autres expressions.\n\n```java\nint foo() {\n  return 1;\n}\n\nvoid setup() {\n  int i = foo() + 1;\n  println(i); // Affiche 2\n}\n```\n\nDans le code ci-dessus, on appelle la fonction `foo` qui renvoie une valeur de type `int`. On utilise un appel √† cette fonction dans l'expression utilis√©e pour l'assignation √† la variable `i`. L'appel √† foo est √©valu√© : le code est ex√©cut√© et la valeur renvoy√©e est 1 ; on effectue ensuite la somme de cette valeur et de 1, qui vaut 2, et on assigne ce r√©sultat √† la variable `i` qui va donc contenir 2.\n\nSi la fonction contient des branchements conditionnels, il est **obligatoire** que, peu importe la branche ex√©cut√©e, on atteigne un `return`. En effet, il faut que la fonction renvoie **toujours** une valeur. Dans le cas contraire, le code affichera une erreur du type `This method must return a result of type x`.\n\n### Fonctions `void`\n\nUne fonction d√©finie avec `void` comme \"type\" de retour est en r√©alit√© une fonction qui ne va rien retourner. Les appels √† cette fonction ne peuvent donc pas √™tre utilis√©s dans des expressions car ils ne peuvent pas √™tre √©valu√©s. Les appels ne peuvent se faire que comme ligne ex√©cutable simple :\n\n```java\nvoid foo() {\n  println(\"foo\");\n}\n\nvoid setup() {\n  foo();\n}\n```\n\n## Param√®tres\n\nLes param√®tres, ou arguments, d'une fonction, sont des variables utilisables dans le code de la fonction et pour lesquelles il faudra passer une valeur √† chaque fois qu'on appelle la fonction. Le nom des param√®tres est arbitraire mais une fonction est plus compr√©hensible lorsque ses param√®tres sont nomm√©s intelligemment.\n\n```java\nint square(int i) {\n  return i * i;\n}\n\nvoid setup() {\n  println(square(0)); // Affiche 0\n  println(square(1)); // Affiche 1\n  println(square(2)); // Affiche 4\n  println(square(3)); // Affiche 9\n}\n```\n\nOn d√©finit une fonction `square` qui va nous permettre de calculer le carr√© d'un nombre. Ce nombre, *n'importe lequel*, on le repr√©sente par le param√®tre `i`, de type entier. La fonction calcule ensuite le carr√© de cette variable, `i * i` et renvoie cette valeur. Nous n'avons besoin de valeurs pour ce param√®tre que lorsque l'on appelle effectivement la fonction, comme on le fait plus loin : `println(square(2))` par exemple, affiche en console le r√©sultat de l'appel √† la fonction `square` o√π le param√®tre `i` vaut 2. L'appel renverra donc le carr√© de 2 : 4.\n\n## Utilit√©s\nUne fonction permet de ne d√©finir qu'une seule fois un bout de code qui pourrait appara√Ætre plusieurs fois : c'est ce qu'on appelle la *factorisation*. \n\nAvant factorisation :\n\n```java\nvoid setup() {\n  float a = random(0, 1);\n  if (a \u003c= 0.25) {\n    a = 0;\n  } else if (a \u003c= 0.75) {\n    a = 0.5;\n  } else {\n    a = 1;\n  }\n  println(a);\n  \n  float b = random(0, 1);\n  if (b \u003c= 0.25) {\n    b = 0;\n  } else if (b \u003c= 0.75) {\n    b = 0.5;\n  } else {\n    b = 1;\n  }\n  println(b);\n}\n```\n\nApr√®s factorisation :\n\n```java\nvoid setup() {\n  float a = roundToClosestHalf(random(0, 1));\n  println(a);\n\n  float b = roundToClosestHalf(random(0, 1));\n  println(b);\n}\n\nfloat roundToClosestHalf(float n) {\n  if (n \u003c= 0.25) {\n    n = 0;\n  } else if (n \u003c= 0.75) {\n    n = 0.5;\n  } else {\n    n = 1;\n  }\n  return n;\n}\n```\n\nL'utilisation de fonctions permet √©galement d'am√©liorer la structure d'un programme, en d√©finissant des fonctions aux responsabilit√©s bien limit√©es et dont les noms, savamment choisis, peuvent am√©liorer la lisibilit√© du code. Comme on le voit plus haut, le nom donn√© √† la fonction permet de comprendre facilement ce que le code fait.","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/07-blocs-contextes":{"title":"07 - Blocs et contextes","content":"\n## Blocs\n\nUn *bloc de code* est une s√©rie de lignes de code d√©limit√©e par des accolades `{}`. Ces blocs sont, comme vu pr√©c√©demment, li√©s √† des [branchements conditionnels](cours/04-alternatives), des [boucles](cours/05-boucles) ou des [fonctions](cours/06-fonctions.md). Chaque bloc a son propre *contexte*.\n\n## Contexte et port√©e\nLa *port√©e* d'une variable d√©finit dans quel contexte celle-ci est visible par du code et donc utilisable. Chaque bloc a acc√®s aux variables d√©clar√©es dans son propre contexte et √† celles d√©clar√©es dans le contexte \"parent\" ou englobant.\n\n```java\nint i = 0;\nint j = 1;\n\nif (i == 0) {\n  // D√©but du contexte du if, on a acc√®s aux variables i et j\n  int k = 2 * j; // La variable k est locale au contexte du if\n  println(k);\n}\n\n// A partir d'ici, k n'existe plus\n\n```\n\n\u003e ‚Ñπ Une indentation correcte du code permet de facilement voir les diff√©rents niveaux de contextes\n\n### Global\n\nLe contexte global est le contexte principal d'ex√©cution du programme dans lequel on va retrouver des variables globales, des branchements, des boucles, des d√©finitions de fonctions, etc.\n\n### Branchements et boucles\n\nLes contextes des branchements conditionnels et des boucles sont des \"sous\" contextes, des contextes englob√©s dans d'autres contextes. \n\nPour les boucles, chaque *it√©ration* de la boucle est un contexte diff√©rent. Le contexte d'une it√©ration prend fin quand on arrive au bout de l'ex√©cution de cette it√©ration.\n\n### Fonctions\n\nPour les fonctions, chaque *appel* de fonction est un contexte diff√©rent et **ind√©pendant**, le contexte parent de l'appel de la fonction est le contexte global et non le bloc de code dans lequel se trouve l'appel √† cette fonction. Les param√®tres de la fonction sont √©galement des variables locales √† chaque appel de la fonction dont la valeur est celle qu'on a pass√©e dans l'appel.\n\n```java\nint i = 1; // Variable globale\n\nif (i \u003e 0) {\n  int j = 1; // Variable locale\n  foo(j + i); // Appel de fonction\n}\n\nvoid foo(int k) {\n  int j = k; // Variable locale, le j dans le if n'est pas visible ici\n  println(i, j); // Affiche 1 2\n}\n```","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/08-recursivite":{"title":"08 - R√©cursivit√©","content":"\n## D√©finition\n\nOn dit de quelque chose qu'elle est *r√©cursive* d√®s lors qu'elle s'utilise elle-m√™me.\n\nUn exemple de r√©cursivit√© assez connu est la mise en ab√Æme, o√π on inclut dans une oeuvre l'oeuvre elle-m√™me :\n\n![[cours/images/recursion.jpeg]]\n\n## Fonction r√©cursive\n\nUne fonction est r√©cursive si, dans le code de cette fonction, on retrouve un (ou plusieurs) appels √† cette m√™me fonction. Il s'agit alors de r√©cursivit√© directe.\n\n```java\nvoid foo() {\n  if (random(0, 1) \u003e 0.5) {\n    println(\"Recursive call\");\n    foo();\n  }\n}\n```\n\nIl est √©galement possible de faire de la r√©cursivit√© en appelant indirectement une autre fonction qui elle-m√™me, lors de son ex√©cution, appelle la fonction de d√©part.\n\n```java\nvoid foo() {\n  if (random(0, 1) \u003e 0.5) {\n    println(\"Recursive call\");\n    bar();\n  }\n}\n\nvoid bar() {\n   foo();\n}\n```\n\n\n## Conditions d'arr√™t\n\nQuand on d√©finit une fonction r√©cursive, il est imp√©ratif que cet appel r√©cursif soit *conditionnel*. En effet, si l'appel r√©cursif √©tait toujours ex√©cut√© lors d'un appel √† la fonction, on ne sortirait plus jamais du cycle d'appels. On parle alors de *conditions d'arr√™t*, qui sont les situations dans lesquells il ne faut pas/plus faire d'appel r√©cursif. \n\nCes conditions d'arr√™t portent en g√©n√©ral sur les param√®tres de la fonction r√©cursive, et chaque appel r√©cursif doit inclure un changement dans la valeur de ces param√®tres, de sorte que les conditions d'arr√™t puissent avoir un r√©sultat diff√©rent selon le contexte de l'appel.\n\n```java\nvoid foo() {\n  foo(); // Appel inconditionnel, foo() s'appelle sans cesse\n}\n\nvoid bar(int i) {\n  if (i \u003e 0) {\n    bar(i - 1); // Appel conditionnel avec √©volution des param√®tres\n  }\n}\n```\n\nIl pourrait aussi s'agir de variables globales, le principal √©tant que le *contexte* de chaque appel soit diff√©rent. S'il √©tait similaire (les variables visibles par le contexte ont la m√™me valeur) et que les conditions portent sur ces variables, on serait dans une situation de r√©cursivit√© infinie, ce que l'ordinateur ne peut bien entendu pas g√©rer. Lorsque l'on cr√©e une telle situation, souvent par erreur, le programme renverra une erreur du type `StackOverflowError`.\n\n## Stack d'appels\n\nComme vu pr√©c√©demment, un appel de fonction s'ex√©cute dans son propre contexte ; il en va de m√™me pour les appels r√©cursifs. Un appel r√©cursif induit un nouveau contexte \"par-dessus\", masquant l'existant, celui de l'appel r√©cursif pr√©c√©dant. Lorsque l'on arrive au bout de l'ex√©cution du code d'un appel r√©cursif, on revient au contexte pr√©c√©dant, ainsi de suite, jusqu'√† sortir compl√®tement de ce \"stack\", cet empilement d'appels r√©cursifs et leur contexte. \n\nConsid√©rons la fonction r√©cursive suivante.\n\n```java\nvoid foo(int i) {\n  println(i);\n  if (i \u003c 3) {\n    foo(i + 1);\n  }\n}\n```\n\nSi on appelle initialement la fonction en passant 0 en param√®tre : `foo(0)`, l'ex√©cution ressemblera √†\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/recursion-dm.svg\" class=\"svg-dark-mode w-50\"/\u003e\n\u003cimg src=\"/stic/images/recursion-lm.svg\" class=\"svg-light-mode w-50\"/\u003e\n\u003c/p\u003e\n\nEt affichera en console\n\n```plain\n0\n1\n2\n3\n```\n\n## Construire une solution r√©cursive\n\nSi on construit une solution r√©cursive pour un certain probl√®me, cela signifie qu'il faut parvenir, dans le code de la fonction, √† r√©soudre une *petite* partie de ce probl√®me de sorte qu'il reste un probl√®me similaire mais plus petit, que l'on r√©soudra via l'appel r√©cursif.\n\nPrenons par exemple un probl√®me qui consiste √† suivre une s√©rie de directions. La fonction r√©cursive va extraire une partie du probl√®me, la premi√®re direction √† suivre, et la r√©soudre ; on suit la direction indiqu√©e. Il reste maintenant toutes les autres directions √† suivre, mais on peut, pour ce faire, appeler r√©cursivement la fonction. La condition d'arr√™t sera ici lorsqu'il n'y a plus de directions √† suivre.\n\n```java\nvoid followDirections(int[] directions) { \n  if (directions.length \u003e 0) { \n    int firstDirection = directions[0]; \n    followDirection(firstDirection); \n\n    int[] remainingDirections = removeFirstElement(directions);\n    followDirections(remainingDirections);\n  }\n} \n\nvoid followDirection(int direction) { \n  // TODO \n  println(direction);\n} \n\nint[] removeFirstElement(int[] array) { \n  if (array.length \u003e 0) { \n    int[] newArray = new int[array.length - 1]; \n    for (int i = 1; i \u003c array.length; i++) { \n      newArray[i - 1] = array[i];\n    } \n    return newArray;\n  } else { \n    return new int[] {};\n  }\n}\n```","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/09-classes":{"title":"09 - Classes","content":"\n## D√©finition\n\nDans un langage *orient√© objet* comme Java, on peut d√©finir des *classes*. Une classe est un *prototype*, une maquette, repr√©sentant un concept souvent tir√© du monde r√©el, et qui nous va permettre de plus facilement interagir avec ce concept.\n\nUn *objet* est une instance d'une classe, un cas concret correspondant au prototype d√©fini.\n\nImaginons par exemple une classe `Human`, chaque personne serait alors une instance de cette classe, une *r√©alisation* de ce qui d√©finit un humain.\n\n## Structure\n\n### Syntaxe\n\nPour d√©finir une classe, il faut utiliser le mot cl√© `class` suivi du nom de la classe. C'est ce nom qui servira de *type* (au m√™me titre que `int`, `float`, etc.) lorsque l'on d√©clarera une variable contenant une instance de cette classe. \n\nIl faut ensuite mettre tout ce qui constitue la classe entre accolades.\n\n\u003e ‚Ñπ En Java, on nomme habituellement une classe en commen√ßant par une lettre majuscule, ce qui permet de la distinguer de simples variables, qui devraient commencer par une lettre minuscule.\n\n```java\nclass Human {\n\n  // D√©finition de la classe\n\n}\n```\n\nUne classe est g√©n√©ralement d√©coup√©e en trois parties : les attributs, le constructeur et les m√©thodes.\n\n### Attributs\nLes *attributs* d'une classe sont des variables que l'on d√©clare dans cette classe et qui repr√©sentent des informations qu'auront toujours des instances de la classe. La valeur de ces variables changera bien entendu d'une instance √† l'autre.\n\nPour notre classe `Human`, on aura par exemple un attribut `hungry` de type bool√©en, qui indique si une personne a faim.\n\n```java\nclass Human {\n\n  // Attributs\n  boolean hungry;\n\n}\n```\n\n### Constructeur\nLe *constructeur* est une sorte de fonction particuli√®re qui permet d'instancier un nouvel objet de la classe. Cette \"fonction\" doit imp√©rativement porter le m√™me nom que la classe, et il ne faut pas d√©finir un type de retour. On peut se dire que c'est parce que la valeur retourn√©e par le constructeur sera toujours du type de la classe.\n\nLe constructeur d'une classe est donc responsable de l'initialisation d'un objet de cette classe, et c'est l√† qu'on initialise les diff√©rents attributs, soit avec une valeur fixe, soit avec une valeur pass√©e en param√®tre.\n\n\u003e ‚Ñπ On peut aussi initialiser les attributs quand on les d√©clare, comme pour des variables classiques\n\nIl est possible de d√©finir plusieurs constructeurs tant que chaque constructeur a des param√®tres diff√©rents ; on d√©finit alors plusieurs fa√ßons diff√©rentes de cr√©er un nouvel objet.\n\n```java\nclass Human {\n\n  // Attributs\n  boolean hungry;\n\n  // Constructeur par d√©faut\n  Human() {\n    hungry = false;\n  }\n\n  // Constructeur avec param√®tre\n  Human(boolean tempHungry) {\n    hungry = tempHungry;\n  }\n\n}\n```\n\n\u003e ‚Ñπ Si on ne d√©finit pas explicitement de constructeur, c'est comme si on avait d√©fini un constructeur sans param√®tre qui ne fait rien.\n\n### Instance `this`\nLes constructeurs param√©tr√©s utilisent en g√©n√©ral des param√®tres correspondant aux diff√©rents attributs, et on aurait tendance √† vouloir les nommer de la m√™me fa√ßon que les attributs pour savoir facilement √† quoi ils correspondent. En ce faisant, on perd cependant la visibilit√© sur l'attribut du m√™me nom :\n\n```java\nclass Human {\n\n  // Attributs\n  boolean hungry;\n\n  // Constructeur par d√©faut\n  Human() {\n    hungry = false;\n  }\n\n  // Constructeur avec param√®tre\n  Human(boolean hungry) {\n    // Le nom hungry visible est celui du param√®tre !!\n    hungry = hungry; // Ne fait rien\n  }\n\n}\n```\n\nPour acc√©der explicitement √† un attribut de la classe, on peut utiliser le mot cl√© `this`. Ce mot cl√© repr√©sente en quelque sorte l'instance de la classe sur laquelle on travaille, m√™me si elle n'existe pas encore. Depuis ce `this`, on peut acc√©der √† tous les attributs et aux m√©thodes avec la syntaxe this.\\\u003cattribut\\\u003e ou this.\\\u003cm√©thode\\\u003e. On peut ainsi utiliser la variable locale `hungry` pour mettre sa valeur dans l'attribut correspondant de l'instance `this.hungry` :\n\n```java\nclass Human {\n\n  // Attributs\n  boolean hungry;\n\n  // Constructeur par d√©faut\n  Human() {\n    hungry = false;\n  }\n\n  // Constructeur avec param√®tre\n  Human(boolean hungry) {\n    this.hungry = hungry;\n  }\n\n}\n```\n\nL'utilisation du `this` n'est pas obligatoire lorsque le nom d'un attribut n'est pas cach√© par celui d'un param√®tre, mais c'est parfois plus facile de l'utiliser pour rendre plus visible que la variable ou la fonction qu'on utilise est d√©finie dans la classe ; qu'il s'agit donc d'un attribut ou d'une m√©thode.\n\n### M√©thodes\n\nLes *m√©thodes* sont des [fonctions](cours/06-fonctions.md) internes √† la classe qui repr√©sentent des comportements, des choses qu'il est sens√© de faire pour le concept repr√©sent√© par la classe. Lorsque l'on appelle une m√©thode d'une classe, comme on appelle une fonction, l'ex√©cution se passe dans un contexte particulier propre √† l'instance et dans lequel on a acc√®s √† tous les attributs de l'objet (`this`).\n\nToujours pour notre `Human`, on va d√©finir une m√©thode `eat`, qui ne renvoie rien, donc `void`, et ne prend aucun param√®tre. Cette fonction met √† jour l'attribut `hungry` pour lui mettre la valeur `false`, car l'humain n'a plus faim apr√®s avoir mang√©. \n\n```java\nclass Human {\n\n  // Attributs\n  boolean hungry;\n\n  // Constructeur par d√©faut\n  Human() {\n    hungry = false;\n  }\n\n  // Constructeur avec param√®tre\n  Human(boolean hungry) {\n    this.hungry = hungry;\n  }\n\n  void eat() {\n    println(\"nom nom nom\");\n    hungry = false;\n  }\n\n}\n```\n\n## Objets\n### D√©claration\nLes *objets* sont des instances d'une classe, et on va les stocker comme on stockerait des valeurs enti√®res, flottantes, etc. : dans des variables. Le *type* d'une variable contenant un objet sera le nom de la classe.\n\n```java\nHuman human; // Variable qui contiendra un objet de la classe Human\n```\n\n### Cr√©ation\n\nLes objets, comme les [tableaux](cours/03-tableaux-matrices.md), sont des *r√©f√©rences*, et pour cr√©er des r√©f√©rences, il faut utiliser le mot cl√© `new`, ici suivi de l'appel √† un constructeur de la classe.\n\n```java\nHuman human = new Human(); // Constructeur vide\nHuman anotherHuman = new Human(true); // Constructeur explicite, cet humain a faim\n```\n\n### Manipulation\n\nPour manipuler ou interagir avec un objet, il faut utiliser le `.` apr√®s le nom de l'objet, comme si on \"entrait\" dans ce qu'il contient : ses attributs et ses m√©thodes. Apr√®s le `.`, on peut donc soit mettre le nom d'un attribut, pour en √©valuer sa valeur ou le modifier, soit appeler une m√©thode de l'objet.\n\n```java\nHuman human = new Human();\nprintln(human.hungry); // Affiche si l'humain a faim -\u003e false par d√©faut\nhuman.hungry = true; // On met √† jour l'attribut;\nprintln(human.hungry); // Affiche true\nhuman.eat(); // Appel de la m√©thode eat de notre humain\nprintln(human.hungry); // Affiche false\n```\n\n\u003e ‚Ñπ On pr√©f√®re en g√©n√©ral √©viter d'interagir directement avec les attributs d'un objet, mais de passer plut√¥t par des m√©thodes, par exemple `human.setHungry(true)`\n\n### `null`\n\nSi on n'initialise pas une variable objet, la r√©f√©rence n'est pas d√©finie et est alors `null`. Cela signifie que la variable ne contient rien. On peut √©galement \"supprimer\" la valeur contenue dans une variable objet en lui assignant la valeur `null`.\n\n```java\nHuman human = new Human();\nhuman.eat(); // Affiche nom nom nom\nhuman = null; // Supprime l'humain r√©f√©renc√©\n```\n\nLorsque l'on essaie d'interagir avec une variable objet, soit en acc√©dant √† un de ses attributs, soit en appelant une m√©thode, mais que la variable ne contient rien, donc `null`, on aura une erreur du type `NullPointerException`.\n\n## Listes d'objets\n\nSi l'on doit manipuler un grand nombre d'objets du m√™me type, il y a deux solutions possibles :\n- Ce nombre est fixe, on peut alors utiliser un tableau ; par exemple `Human[] humans = new Human[10];`\n- Ce nombre est variable et est amen√© √† changer (nouveaux √©l√©ments, √©l√©ments en moins) pendant l'ex√©cution du code. Dans ce cas, on peut utiliser une `ArrayList`, qui repr√©sente donc une liste d'√©l√©ments de taille variable.\n\n### ArrayList\n\n#### Cr√©ation\nPour d√©clarer une [`ArrayList`](https://processing.org/reference/ArrayList.html) d'un certain type d'objets, il faut sp√©cifier ce type entre `\u003c\u003e` :\n\n```java\nArrayList\u003cHuman\u003e humans = new ArrayList\u003cHuman\u003e();\n```\n\nOn cr√©e ici une liste initialement vide dans laquelle on pourra rajouter des objets.\n\n\u003e ‚Ñπ Vous remarquez l'utilisation du mot cl√© `new` pour la cr√©ation de la liste ; ArrayList est une *classe* existante en Java.\n\n#### Manipulation\n\nLa manipulation de la liste se fait via l'appel √† diff√©rentes m√©thodes sur cette liste :\n\n- `add(object)` qui prend en param√®tre un objet du type d'√©l√©ments de la liste, et ajoute cet √©l√©ment \"√† la fin\" de la liste\n- `get(i)` qui prend en param√®tre l'indice d'un √©l√©ment, et renvoie l'√©l√©ment se trouvant √† cette place dans la liste\n- `remove(i)` qui prend en param√®tre l'indice d'un √©l√©ment et le supprime de la liste\n- `size()` qui renvoie le nombre d'√©l√©ments que contient la liste\n- `set(i, object)` qui prend en param√®tre un indice et un objet et remplace l'√©l√©ment √† cet indice dans la liste par l'objet pass√© en param√®tre\n\n```java\nArrayList\u003cHuman\u003e humans = new ArrayList\u003cHuman\u003e();\nhumans.add(new Human(true));\nhumans.add(new Human());\nhumans.add(new Human());\nprintln(humans.size()); // Affiche 3\nprintln(humans.get(0).hungry); // Affiche true\nhumans.get(0).eat();\nprintln(humans.get(0).hungry); // Affiche false\nhumans.remove(2);\nhumans.remove(1);\nprintln(humans.size()); // Affiche 1\nhumans.set(0, new Human(true));\nprintln(humans.get(0).hungry); // Affiche true\n```\n\n#### Erreurs\n\nComme pour les tableaux, si on essaie d'acc√©der √† un √©l√©ment hors du tableau, c'est-√†-dire √† une position plus grande que sa taille, on aura une erreur du type `IndexOutOfBoundsException`.\n\n## Utilit√©\n\n### Structure\n\nComme pour les fonctions, d√©finir des classes permet souvent de mieux structurer le code et de lui donner plus de \"sens\" proche du r√©el. Une classe permet d'isoler du code sp√©cifique √† un concept pr√©cis, et de ne pas le perdre au milieu du reste.\n\n### Factorisation\n\nD√©finir une classe permet de simplifier le code lorsqu'on se sert de plusieurs instances d'un m√™me concept car, que l'on utilise des classes ou non, ces concepts sont pr√©sents dans le code.\n\nImaginons par exemple qu'on ait besoin de d√©finir 20 cercles pour les dessiner ; il nous faut leurs coordonn√©es (x, y) et leur couleur. Sans classe, il faudrait utiliser trois tableaux, un par information li√©e √† un cercle.\n\n```java\nint[] circlesX;\nint[] circlesY;\ncolor[] circlesColor;\n\nvoid setup() {\n  circlesX = new int[20];\n  circlesY = new int[20];\n  circlesColor = new color[20];\n  \n  for (int i = 0; i \u003c 20; i++) {\n    circlesX[i] = int(random(0, 100));\n    circlesY[i] = int(random(0, 100));\n    circlesColor[i] = randomColor();\n  }\n}\n\ncolor randomColor() {\n return color(int(random(0, 256)), \n              int(random(0, 256)), \n              int(random(0, 256)));\n}\n```\n\nEn d√©finissant une classe repr√©sentant ces cercles, on simplifie le code tout en le rendant plus lisible :\n\n```java\nclass Circle {\n  int x;\n  int y;\n  color c;\n\n  Circle(int x, int y, color c) {\n    this.x = x;\n    this.y = y;\n    this.c = c;\n  }\n}\n\nCircle[] circles;\n\nvoid setup() {\n  circles = new Circle[20];\n  for (int i = 0; i \u003c 20; i++) {\n    circles[i] = new Circle(int(random(0, 100)), \n                            int(random(0, 100)),\n                            randomColor());\n  }\n}\n\ncolor randomColor() {\n return color(int(random(0, 256)), \n              int(random(0, 256)), \n              int(random(0, 256)));\n}\n```\n\n\u003e ‚ö† Un code plus simple ne veut pas n√©cessairement dire plus court. Le code est plus simple car il ne faut plus interagir qu'avec un seul tableau, le tableau d'objets, plut√¥t qu'avec autant de tableaux qu'on aurait d'attributs dans ces objets.","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/10-strings":{"title":"10 - Strings","content":"\n## D√©finition\n Un **string** est un type de donn√©es particulier permettant de contenir une cha√Æne de caract√®res, du texte. Il ne s'agit pas d'un type primitif comme `int`, `float`, etc. mais d'une [classe](cours/09-classes.md) `String` existante dans le langage Java de base.\n\nComme toute variable, on d√©clare un string en indiquant son type, `String`, et le nom de la variable. En Java, une cha√Æne de caract√®res est d√©limit√©e par des guillemets. Ainsi, toute valeur entre `\" \"` sera √©valu√©e par processing comme √©tant du type `String`.\n\n```java\nString s = \"Hello World!\";\nprintln(s); // Affiche Hello World!\n```\n\n### Objets et litt√©raux\n\nBien que `String` soit une classe, Java permet d'utiliser des litt√©raux de type `String` : des cha√Ænes de caract√®res entre guillements `\"`. Ces litt√©raux sont stock√©s diff√©remment que les objets en m√©moire, de fa√ßon centrale, de sorte qu'une m√™me cha√Æne de caract√®res utilis√©e plusieurs fois soit un seul litt√©ral en m√©moire.\n\n```java\nprintln(\"abc\" == \"abc\"); // Affiche true\nprintln(\"abc\" == \"bcd\"); // Affiche false\n```\n\nIl est par contre possible de cr√©er explicitement un objet de type `String` via le constructeur en utilisant un litt√©ral en param√®tre. Il s'agit alors d'un objet √† part enti√®re qui sera stock√© dans la m√©moire heap, et deux objets `String` qui contiennent la m√™me cha√Æne de caract√®res seront diff√©rents.\n\n```java\nString s1 = \"Hello\";\nString s2 = new String(\"Hello\");\nprintln(s1 == \"Hello\"); // Affiche true\nprintln(s2 == \"Hello\"); // Affiche false\n```\n\n\n## Manipulation\n\n### Concat√©nation\n\nLa **concat√©nation** est une op√©ration qui permet de combiner deux cha√Ænes de caract√®res via l'op√©rateur `+`. Les deux cha√Ænes de caract√®res seront alors mises \"bout √† bout\" pour n'en former qu'une.\n\n```java\nString s1 = \"Hello \";\nString s2 = \"World\";\nString s3 = s1 + s2;\nprintln(s); // Affiche Hello World\n```\n\nComme toute op√©ration simple, on peut l'utiliser plusieurs fois dans une m√™me expression, ce qui permet de construire facilement des cha√Ænes de caract√®res en combinant des variables de type `String`  et des litt√©raux.\n\n```java\nString s1 = \"Hello\";\nString s2 = \"World\";\nprintln(s1 + \" \" + s2 + \"!\");\n```\n\n#### Concat√©nation avec un autre type\n\nOn peut concat√©ner une cha√Æne de caract√®res avec une valeur d'un autre type, cette valeur sera alors convertie automatiquement par processing en une cha√Æne de caract√®res correspondant √† son contenu.\n\n```java\nString s = \"Number \";\nint i = 5;\nprintln(s + i); // Affiche Number 5\n```\n\n\n### Comparaison\n\nComme on peut avoir des objets ou des litt√©raux `String`, et que les comparaisons classiques avec `==` et `!=` ne se comporteront pas forc√©ment de la fa√ßon √† laquelle on s'attend, comme expliqu√© plus haut, il est pr√©f√©rable de se servir des m√©thodes `compareTo` et `equals`.\n\n#### `compareTo`\n\nLa m√©thode `compareTo` disponible sur un `String` permet de comparer la cha√Æne de caract√®res de ce `String` avec celle pass√©e en param√®tre. La m√©thode renvoie un nombre entier :\n- Positif si le premier `String` est \"plus grand\" que le second, dans l'ordre croissant\n- N√©gatif si le premier `String` est \"plus petit\" que le second, dans l'ordre croissant\n- 0 si les deux `String` contiennent la m√™me cha√Æne de caract√®res.\n\n```java\nString abc = \"abc\";\nString bcd = \"bcd\";\nprintln(abc.compareTo(bcd)); // Affiche -1\nprintln(bcd.compareTo(abc)); // Affiche 1\nprintln(abc.compareTo(\"abc\")); // Affiche 0\n```\n\n#### `equals`\n\nLa m√©thode `equals` disponible sur un `String` permet de savoir si ce `String` contient la m√™me cha√Æne de caract√®res qu'un autre `String`, utilis√© en param√®tre. Cette m√©thode renvoie donc le bool√©en `true` si les deux `String` contiennent la m√™me cha√Æne de caract√®res, ou `false` dans le cas contraire.\n\n```java\nString abc = \"abc\";\nString bcd = \"bcd\";\nprintln(abc.equals(bcd)); // Affiche false\nprintln(abc.equals(\"abc\")); // Affiche true\n```\n\n### M√©thodes utiles\n\n#### `length`\n\nOn peut r√©cup√©rer la taille d'une cha√Æne de caract√®res en appelant la fonction `length` sur cette cha√Æne de caract√®res.\n\n```java\nString s1 = \"Hello\";\nString s2 = \":D\";\nprintln(s1.length()); // Affiche 5\nprintln(s2.length()); // Affiche 2\n```\n\n#### `split`\n\nLa m√©thode `split` permet de scinder une cha√Æne de caract√®res sur base d'un s√©parateur, une cha√Æne de caract√®res √† passer en param√®tre. Le `split` renvoie un tableau de `String` correspondant aux diff√©rentes parties de la cha√Æne initiale qui √©taient s√©par√©es par le s√©parateur. Par exemple, utiliser `split(\" \")` permet de couper une phrase sur les espaces et de r√©cup√©rer un tableau de mots.\n\n```java\nString s = \"Hello World!\";\nString[] parts = s.split(\" \");\nprintln(parts.length); // Affiche 2\nprintln(parts[0]); // Affiche Hello\nprintln(parts[1]); // Affiche World!\n```\n\n#### `charAt`\n\nLa m√©thode `charAt` permet de r√©cup√©rer le caract√®re (type `char`) se trouvant √† l'indice pass√© en param√®tre.\n\n```java\nString s = \"Hello World!\";\nchar h = s.charAt(0);\nchar d  = s.charAt(10);\nprintln(h); // Affiche H\nprintln(d); // Affiche d\n```\n\n#### `substring`\n\nLa m√©thode `substring` permet de r√©cup√©rer une partie de la cha√Æne de caract√®res initiale. On peut appeler cette m√©thode de deux fa√ßons :\n\n- Avec un seul param√®tre de type entier, qui est l'indice du caract√®re √† partir duquel on veut la sous-cha√Æne de caract√®res, qui ira jusqu'√† la fin de la cha√Æne de caract√®res initiale\n```java\nString s = \"Hello World!\";\nString world = s.substring(6);\nprintln(world); // Affiche World!\n```\n- Avec deux param√®tres de type entier ; le premier est toujours l'indice du premier caract√®re de la sous-cha√Æne voulue, et le deuxi√®me est l'indice du caract√®re (non-compris) de fin de la sous-cha√Æne\n```java\nString s = \"Hello World!\";\nString hello = s.substring(0, 5);\nprintln(hello); // Affiche Hello\n```\n","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/11-bases-processing":{"title":"11 - Bases de Processing","content":"\n## Fonctions processing\n\u003e ‚ö† Ce qui suit n'inclut qu'une partie de ce que peut faire processing. Pour les informations compl√®tes, veuillez vous r√©f√©rer √† la documentation officielle : [https://processing.org/reference](https://processing.org/reference)\n\n### Initialisation `setup`\n\nTout dessin processing complexe, c'est-√†-dire qui va utiliser des fonctions, doit d√©finir la fonction [`setup`](https://processing.org/reference/setup_.html) qui commence par d√©finir la taille de la fen√™tre :\n- Plein √©cran, en appelant la fonction [`fullScreen()`](https://processing.org/reference/fullScreen_.html)\n- Taille fixe, en appelant la fonction [`size(w, h)`](https://processing.org/reference/size_.html) o√π `w` et `h` seront des valeurs enti√®res correspondant √† la largeur et √† la hauteur voulues.\n\n```java\nvoid setup() {\n  size(800, 600);\n\t\n}\n```\n\nC'est √©galement dans le [`setup`](https://processing.org/reference/setup_.html) qu'on va configurer les param√®tres globaux du dessin comme :\n- Le framerate, le nombre de frames par seconde, via la fonction [`frameRate(x)`](https://processing.org/reference/frameRate_.html) o√π x sera la valeur souhait√©e. Par d√©faut, le framerate est 60.\n- Des sp√©cifit√©s du dessin qui ne changeront pas ([`noStroke()`](https://processing.org/reference/noStroke_.html), etc.)\n\n### Boucle principale `draw`\n\nLa \"boucle principale\" est une boucle implicite qui permet de passer √† l'√©tape suivante du code. En processing, cette boucle principale est la fonction [`draw`](https://processing.org/reference/draw_.html), et une √©tape est une *frame* du dessin. C'est donc de cette fonction que partira la majorit√© de la logique du code : la repr√©sentation, le dessin, et l'√©volution des donn√©es.\n\n```java\nvoid draw() {\n\n}\n```\n\nLa fonction [`draw`](https://processing.org/reference/draw_.html) est appel√©e automatiquement par processing *x* fois par seconde selon le framerate d√©fini, il ne faut donc **pas** appeler soi-m√™me cette fonction.\n\n### R√©actions aux entr√©es\n\nLes diff√©rentes entr√©es possibles en processing sont accessibles via des fonctions qui seront appel√©es quand l'√©v√®nement correspondant survient, entre deux appels de [`draw`](https://processing.org/reference/draw_.html). Il ne faut d√©finir chaque fonction qu'une seule fois.\n\n\u003e ‚ö† Les r√©actions aux entr√©es ne fonctionnent que pour les dessins anim√©s, c'est-√†-dire les dessins pour lesquels on a d√©fini le [`draw`](https://processing.org/reference/draw_.html)\n\n### Clavier\n\nPour une entr√©e clavier, il y aura toujours deux √©v√©n√®ments :\n- [`keyPressed()`](https://processing.org/reference/keyPressed_.html) quand on appuie sur la touche du clavier\n- [`keyReleased()`](https://processing.org/reference/keyReleased_.html) quand on rel√¢che la touche\n\n\u003e ‚ö† Maintenir une touche du clavier enfonc√©e peut provoquer plusieurs appels cons√©cutifs √† [`keyPressed`](https://processing.org/reference/keyPressed_.html) mais ce comportement et la fr√©quence √† laquelle l'√©v√®nement est produit d√©pendent du syst√®me d'exploitation. Par cons√©quent, utiliser [`keyPressed`](https://processing.org/reference/keyPressed_.html) pour bouger des parties du dessin (comme un personnage) causera des mouvements saccad√©s, moins fluides que si l'√©volution des coordonn√©es √©tait r√©alis√©e dans le [`draw`](https://processing.org/reference/draw_.html). \n\n### Souris\n\nPour une entr√©e souris, il y aura toujours les √©v√®nements :\n- [`mousePressed()`](https://processing.org/reference/mousePressed_.html) quand on appuie sur la touche de la souris\n- [`mouseReleased()`](https://processing.org/reference/mouseReleased_.html) quand on rel√¢che la touche\n- [`mouseClicked()`](https://processing.org/reference/mouseClicked_.html) apr√®s avoir appuy√© et rel√¢ch√© une touche\n\n### Ex√©cution d'un dessin processing\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/processing-loop-dm.svg\" class=\"svg-dark-mode w-50\"/\u003e\n\u003cimg src=\"/stic/images/processing-loop-lm.svg\" class=\"svg-light-mode w-50\"/\u003e\n\u003c/p\u003e\n\n## Variables processing\n- `width` et `height` contiennent la largeur et la hauteur de la fen√™tre processing, disponibles ind√©finiment apr√®s l'appel de `size`  ou `fullScreen` dans le `setup`\n- `frameCount` contient le num√©ro de la frame actuellement dessin√©e par `draw`. Commence √† 1.\n- `frameRate` contient le nombre de frames par seconde d√©fini par la fonction `frameRate(x)`, ou 60 par d√©faut.\n- `mouseX` et `mouseY` contiennent les coordonn√©es (x,y) de la position du curseur de la souris dans le dessin\n- `pmouseX` et `pmouseY` contiennent les coordonn√©es (x,y) de la position du curseur dans la frame pr√©c√©dente.\n- `keyCode` contient une repr√©sentation codif√©e de la touche sur laquelle on vient d'appuyer : par exemple `ENTER`. Toutes les touches ne sont pas codifi√©es.\n- `key` contient le caract√®re correspondant √† la touche sur laquelle on vient d'appuyer : par exemple `' '` pour la touche espace.\n- Des constantes correspondant √† des \"codes\", comme pour les touches standards du clavier (`ENTER`, `LEFT`, `RIGHT`, etc.)\n\n## Imprimer en console\nPour afficher des informations dans la console de processing, il existe plusieurs fonctions :\n- [`println`](https://processing.org/reference/println_.html) qui prend en param√®tres un nombre arbitraire de cha√Ænes de caract√®res et les affichera sur une ligne s√©par√©s par un espace, puis fait un retour √† la ligne dans la console\n\t- `println()` fera juste un retour √† la ligne dans la console\n\t- `println(\"a\")` imprimera `a` en console puis fera un retour √† la ligne\n\t- `println(\"a\", \"b\", \"c\", \"d\", \"e\")` imprimera `a b c d e` en console puis fera un retour √† la ligne\n- [`print`](https://processing.org/reference/print_.html) qui est similaire √† [`println`](https://processing.org/reference/println_.html) √† la diff√©rence qu'il ne fait pas de retour √† la ligne √† la fin. En cons√©quence, si on imprime par la suite quelque chose d'autre dans le code, ce sera sur la m√™me ligne qu'avant.\n- [`printArray`](https://processing.org/reference/printArray_.html) qui prend en param√®tre un [tableau](cours/03-tableaux-matrices.md) et affiche ses √©l√©ments (un par ligne) en console","lastmodified":"2022-07-02T09:38:58.521044517Z","tags":null},"/cours/12-dessins-geometrie":{"title":"12 - Dessins et g√©ometrie","content":"\n## Fen√™tre\n\nLa fen√™tre de processing est un rep√®re √† deux dimensions dans lequel une coordonn√©e *(x, y)* correspond √† un pixel. L'axe horizontal, des x, cro√Æt de gauche √† droite et l'axe vertical, des y, cro√Æt de bas en haut. L'origine *(0,0)* de ce rep√®re est donc le coin sup√©rieur gauche de la fen√™tre.\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/grid-processing-dm.svg\" class=\"svg-dark-mode w-50\"/\u003e\n\u003cimg src=\"/stic/images/grid-processing-lm.svg\" class=\"svg-light-mode w-50\"/\u003e\n\u003c/p\u003e\n\n## Dessins\n\n### Couleurs\nProcessing permet de travailler sur deux √©chelles de couleur diff√©rentes :\n- En noir et blanc ; la couleur est alors une valeur enti√®re entre 0 (noir) et 255 (blanc)\n\n```java\nint black = 0;\nint middleGrey = 122;\nint white = 255;\n```\n\n- En couleur ; la couleur est alors une valeur de type `color` contenant trois valeurs enti√®res allant de 0 √† 255 pour les composantes rouge, verte et bleue. On peut cr√©er des couleurs gr√¢ce √† la fonction [`color(r, g, b)`](https://processing.org/reference/color_.html) qui prend les valeurs des composantes en param√®tre, ou en utilisant directement la notation hexad√©cimage d'une couleur.\n\n```\ncolor red = color(255, 0, 0);\ncolor green = color(0, 255, 0);\ncolor blue = color(0, 0, 255);\ncolor black = color(0, 0, 0);\ncolor white = color(255, 255, 255);\ncolor someColor = color(13, 201, 154);\ncolor fromHex = #ffffff;\n```\n\nSoit une couleur RGB, de type `color`, on peut r√©cup√©rer la valeur de chacune des composantes R, G, B, gr√¢ce aux fonctions [`red`](https://processing.org/reference/red_.html), [`green`](https://processing.org/reference/green_.html), [`blue`](https://processing.org/reference/blue_.html) :\n\n```java\ncolor c = #FF10AA;\nfloat r = red(c); // 255\nfloat g = green(c); // 16\nfloat b = blue(c); // 170\n```\n\nOn peut utiliser une couleur pour d√©finir :\n- La couleur du fond de la fen√™tre via la fonction [`background`](https://processing.org/reference/background_.html)\n- La couleur des *traits* (lignes) via la fonction [`stroke`](https://processing.org/reference/stroke_.html) \n- La couleur de *remplissage* des formes g√©om√©triques et du texte via la fonction [`fill`](https://processing.org/reference/fill_.html)\n\nL'appel √† background remplit le fond avec la couleur pass√©e en param√®tre en *effa√ßant* tout ce qui a √©t√© dessin√© jusqu'√† pr√©sent.\n\nQuand on appelle [`stroke`](https://processing.org/reference/stroke_.html) ou [`fill`](https://processing.org/reference/fill_.html), la couleur ne changera pas jusqu'√† ce qu'on appelle √† nouveau cette fonction avec une autre valeur.\n\n```java\nbackground(255); // Fond blanc\n\nstroke(0); // A partir d'ici, les traits sont noirs\nfill(color(255, 0, 0)); // A partir d'ici, le remplissage est en rouge\n\n// On dessine\n\nstroke(color(0, 255, 0)); // A partir d'ici, les traits sont verts\nfill(0); // A partir d'ici, le remplissage est noir\n\n// On dessine d'autres choses\n```\n\nAlternativement, on peut aussi dire √† processing de ne *pas* coloriser les traits ou le remplissage, en appelant respectivant [`noStroke()`](https://processing.org/reference/noStroke_.html) ou [`noFill()`](https://processing.org/reference/noFill_.html). \n\nEnfin, on peut √©galement appliquer un certain niveau d'opacit√© en rajoutant un param√®tre aux appels de [`background`](https://processing.org/reference/background_.html),  [`stroke`](https://processing.org/reference/stroke_.html) et [`fill`](https://processing.org/reference/fill_.html). Ce param√®tre est le niveau d'opacit√© allant de 0 (compl√®tement opaque) √† 255 (compl√®tement transparent).\n\n```java\nbackground(0, 255); // Fond noir compl√®tement opaque\nstroke(0, 122); // Trait noir √† 50% d'opacit√©\nfill(color(255, 0, 0), 51); // Remplissage rouge √† 20% d'opacit√©\n```\n\n### Points et lignes\n\nEn processing, on peut dessiner un *point*, un pixel, gr√¢ce √† la fonction [`point`](https://processing.org/reference/point_.html) qui prend en param√®tre les coordonn√©es x et y du point.\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(255);\n  stroke(0);\n\n  point(10, 10); // Dessine un point noir en (10, 10)\n}\n```\n\nOn peut dessiner une ligne gr√¢ce la fonction [`line`](https://processing.org/reference/line_.html) qui prend en param√®tres les coordonn√©es des points aux deux extr√©mit√©s de la ligne.\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(255);\n  stroke(0);\n\n  line(0, 0, width, height); // Dessine une ligne diagonale\n  line(width, 0, 0, height); // Dessine l'autre ligne diagonale\n}\n```\n\n### Rectangles\n\nOn dessine des rectangles gr√¢ce √† la fonction [`rect`](https://processing.org/reference/rect_.html) qui prend toujours 4 param√®tres. Ce que *sont* ces param√®tres d√©pend du mode de dessin des rectangles ; il existe 4 modes diff√©rents :\n\n- `CORNER` : on indique les coordonn√©es *(x, y)* du coin sup√©rieur gauche, la largeur *w* et la hauteur *h* du rectangle\n- `CORNERS` : on indique les coordonn√©es *(x1, y1)* d'un coin et les coordonn√©es *(x2, y2)* du coin oppos√©\n- `CENTER` : on indique les coordonn√©es *(x, y)* du centre du rectangle, la largeur *w* et la hauteur *h*\n- `RADIUS` : indique les coordonn√©es *(x, y)* du centre du rectangle, la moiti√© de la largeur *w* et la moiti√© de la hauteur *h* \n\nOn d√©finit le mode de dessin en appelant la fonction [`rectMode`](https://processing.org/reference/rectMode_.html) avec le mode souhait√©. Le mode `CORNER` est le mode par d√©faut.\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/rect-dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/rect-lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(0);\n  stroke(255);\n  fill(255);\n\n  // Dessinons le m√™me rectangle avec chaque mode\n\n  rectMode(CORNER);\n  rect(20, 20, 100, 50);\n\n  rectMode(CORNERS);\n  rect(20, 20, 120, 70);\n\n  rectMode(CENTER);\n  rect(70, 45, 100, 50);\n\n  rectMode(RADIUS);\n  rect(70, 45, 50, 25);\n}\n```\n\nPeu importe le mode, les informations √† passer √† la fonction pour dessiner un rectangle nous permettent toujours d'obtenir toutes les autres informations du rectangle : les coordonn√©es de tous ses coins, de son centre, sa largeur et sa hauteur.\n\n- `CORNER`, soit les coordonn√©es *(x, y)* du coin sup√©rieur gauche, la largeur *w* et la hauteur *h* :\n\t- Le coin sup√©rieur droit est *(x + w, y)*\n\t- Le coin inf√©rieur gauche est *(x, y + h)*\n\t- Le coin inf√©rieur droit est *(x + w, y + h)*\n\t- Le centre du rectangle est *(x + w / 2, y + h / 2)*\n\n\n- `CORNERS`, soit les coordonn√©es *(x1, y1)* du coin sup√©rieur gauche et les coordonn√©es *(x2, y2)* du coin inf√©rieur droit :\n\t- Le coin sup√©rieur droit est *(x2, y1)*\n\t- Le coin inf√©rieur gauche est *(x1, y2)*\n\t- La largeur *w* est √©gale √† *x2 - x1*\n\t- La hauteur *h* est √©gale *y2 - y1*\n\t- Le centre du rectangle est *(x1 + w / 2, y1 + h / 2)*\n\t- *Ces calculs peuvent s'adapter en prenant d'autres paires de coins oppos√©s ; il faudra notamment prendre la valeur absolue de la largeur et de la hauteur.*\n\n\n- `CENTER`, soit les coordonn√©es *(x, y)* du centre, la largeur *w* et la hauteur *h* :\n\t- Le coin sup√©rieur gauche est *(x - w / 2, y - w / 2)*\n\t- Le coin sup√©rieur droit est *(x + w / 2, y - h / 2)*\n\t- Le coin inf√©rieur gauche est *(x - w / 2, y + h / 2)*\n\t- Le coin inf√©rieur droit est *(x + w / 2, y + h / 2)*\n\n\n- `RADIUS`, soit les coordonn√©es *(x, y)* du centre, la moiti√© de la largeur *w* et la moiti√© de la hauteur *h* :\n\t- Le coin sup√©rieur gauche est *(x - w, y - h)*\n\t- Le coin sup√©rieur droit est *(x + w, y - h)*\n\t- Le coin inf√©rieur gauche est *(x - h, y + h)*\n\t- Le coin inf√©rieur droit est *(x + w, y + h)*\n\t- La largeur est √©gale √† *2 \\* w*\n\t- La hauteur est √©gale √† *2 \\* h*\n\n### Ellipses\n\nOn dessine des ellipses gr√¢ce √† la fonction [`ellipse`](https://processing.org/reference/ellipse_.html) qui prend toujours 4 param√®tres. Ce que *sont* ces param√®tres d√©pend du mode de dessin des ellipses ; il existe 4 modes diff√©rents :\n\n- `CORNER` : on indique les coordonn√©es *(x, y)* du coin sup√©rieur gauche, la largeur *w* et la hauteur *h* du rectangle qui \"encadre\" l'ellipse √† dessiner\n- `CORNERS` : on indique les coordonn√©es *(x1, y1)* d'un coin et les coordonn√©es *(x2, y2)* du coin oppos√© du rectangle qui \"encadre\" l'ellipse √† dessiner\n- `CENTER` : on indique les coordonn√©es *(x, y)* du centre de l'ellipse, la largeur *w* (diami√®tre sur l'axe horizontal) et la hauteur *h* (diam√®tre sur l'axe vertical)\n- `RADIUS` : indique les coordonn√©es *(x, y)* du centre de l'ellipse, la moiti√© de la largeur *w* (rayon sur l'axe horizontal) et la moiti√© de la hauteur *h* (rayon sur l'axe vertical)\n\nOn d√©finit le mode de dessin en appelant la fonction [`ellipseMode`](https://processing.org/reference/ellipseMode_.html) avec le mode souhait√©. Le mode `CENTER` est le mode par d√©faut.\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/ellipse-dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/ellipse-lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\nOn remarque qu'il s'agit en fait exactement du m√™me principe que pour les rectangles, sauf que le dessin concret sera l'ellipse inscrite dans le rectangle d√©fini par les param√®tres.\n\nPour dessiner un cercle, il suffit d'utiliser la m√™me valeur pour la largeur et la hauteur.\n\n### Textes\n\nAu-del√† des formes g√©om√©triques, on peut √©galement afficher du texte dans la fen√™tre processing gr√¢ce √† la fonction [`text`](https://processing.org/reference/text_.html) qui prend en param√®tre une [cha√Æne de caract√®res](cours/10-strings.md) et les coordonn√©es *(x, y)* o√π placer ce texte.\n\nOn peut configurer l'apparence du texte :\n- Sa couleur, en appelant la fonction [`fill`](https://processing.org/reference/fill_.html) avec la couleur en param√®tre\n- Sa taille, en appelant la fonction [`textSize`](https://processing.org/reference/textSize_.html) avec une taille en param√®tre\n- Son alignment, par rapport aux coordonn√©es de sa position, en appelant la fonction [`textAlign`](https://processing.org/reference/textAlign_.html) avec un ou deux param√®tres :\n\t- L'alignement horizontal, qui peut √™tre `CENTER`, `LEFT` ou `RIGHT`\n\t- L'alignement vertical qui peut √™tre `CENTER`, `BOTTOM`, `TOP` ou `BASELINE`\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(0);\n  fill(255);\n  textSize(50);\n  textAlign(CENTER, CENTER);\n  text(\"HELLO\", width / 2, height / 2); // Affiche HELLO au milieu de la fen√™tre\n}\n```\n\n## Transformations \n\n### `translate`\n\nComme expliqu√© pr√©c√©demment, les dessins processing se basent sur l'axe par d√©faut dont l'origine est le coin sup√©rieur gauche de la fen√™tre. Il est toutefois possible de *d√©placer* cette origine gr√¢ce √† la fonction [`translate`](https://processing.org/reference/translate_.html) qui prend en param√®tre le d√©placement en *x* et en *y* √† effectuer.\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/translate-dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/translate-lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(0);\n  stroke(255);\n  fill(255);\n  rectMode(CENTER);\n  \n  // L'origine (0, 0) est le coin sup√©rieur gauche\n  // On va tracer un rectangle au milieu de l'√©cran\n  rect(width / 2, height / 2, 100, 100);\n\n  // Equivalent en d√©pla√ßant l'origine\n  translate(width / 2, height / 2); // L'origine (0, 0) est maintenant le centre de la fen√™tre\n  rect(0, 0, 100, 100);\n}\n```\n\nSi on r√©alisait par exemple un dessin √† partir du centre de la fen√™tre, comme plusieurs cercles concentriques, il serait bien plus facile de d√©placer l'origine au centre de la fen√™tre et d'ensuite simplement dessiner √† partir de l'origine.\n\n### `rotate`\n\nDe la m√™me fa√ßon qu'il est possible d√©placer l'origine des axes, on peut √©galement *changer l'orientation* des axes. Pour ce faire, on utilise la fonction [`rotate`](https://processing.org/reference/rotate_.html) en passant en param√®tre l'angle (en radians) de rotation √† appliquer. Les axes tournent dans le sens horaire. On peut √©galement transformer un angle en degr√© en radians gr√¢ce √† la fonction [`radians`](https://processing.org/reference/radians_.html).\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/rotate-dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/rotate-lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n```java\nvoid setup() {\n  size(800, 600);\n  background(0);\n  stroke(255);\n  fill(255);\n  rectMode(CENTER);\n  \n  translate(width / 2, height / 2);\n  rotate(radians(45)); // Les axes tournent de 45¬∞ dans le sens horaire\n  rect(0, 0, 100, 100);\n}\n```\n\nPour facilement appliquer une rotation √† une figure g√©om√©trique, il vaut mieux d'abord d√©placer l'origine aux coordonn√©es du centre de la figure, puis d'appliquer la rotation. Sinon, les calculs pour trouver les bonnes coordonn√©es deviennent assez compliqu√©s.\n\n### `scale`\n\nOn peut augmenter ou diminuer la taille des dessins gr√¢ce la transformation [`scale`](https://processing.org/reference/scale_.html) qui prend en param√®tre le pourcentage de \"zoom\". Par exemple,  `scale(2)` doublera la taille des figures.\n\n### `pushMatrix` et `popMatrix`\n\nSi l'on veut utiliser des transformations pour faciliter une partie de dessin, on peut se retrouver dans une situation o√π le nouveau syst√®me de coordonn√©es apr√®s cette partie ne convient pas du tout au reste du dessin. On pourrait envisager de refaire des transformations pour revenir √† la situation pr√©c√©dente, mais l'exercice peut √™tre p√©nible.\n\nProcessing permet de sauvegarder l'√©tat du syst√®me de coordonn√©es gr√¢ce √† la fonction [`pushMatrix`](https://processing.org/reference/pushMatrix_.html). Au moment o√π on appelle cette fonction, l'√©tat actuel du syst√®me de coordonn√©es est ajout√© sur une *stack*, une pile d'√©tats. Plus tard dans le code, en appelant la fonction [`popMatrix`](https://processing.org/reference/popMatrix_.html), on r√©cup√®re et r√©tablit le dernier √©tat sauvegard√© via [`pushMatrix`](https://processing.org/reference/pushMatrix_.html). On peut ainsi *stacker* plusieurs √©tats et les r√©cup√©rer un √† un.\n\n```java\nvoid setup() {\n  size(800, 600);\n\n  // Etat par d√©faut : origine en haut √† gauche\n  pushMatrix(); // Je rajoute l'√©tat dans la stack\n\n  translate(10, 10); // L'origine est maintenant (10, 10) selon l'axe original\n  pushMatrix(); // Je rajoute cet √©tat dans la stack\n\n  translate(10, 10); // L'origine est maintenant (20, 20) selon l'axe original\n\n  // Dessins\n\n  popMatrix(); // Je retire le dernier √©tat de la stack et le r√©tablit\n  // L'origine est donc de nouveau (10, 10) selon l'axe original\n\n  // Dessins\n\n  popMatrix(); // Je retire le dernier √©tat de la stack et le r√©tablit\n  // L'origine est donc de nouveau (0, 0)\n}\n```\n\n\n\u003e ‚ö† Lorsque l'on r√©alise un dessin anim√©, toutes les transformations appliqu√©es √† l'origne et aux axes sont r√©initialis√©s au d√©but de chaque frame. C'est-√†-dire que le dessin de chaque frame commence avec l'origine (0, 0) √©tant le coin sup√©rieur gauche, et pas d'angle de rotation.\n\n## Fonctions utiles\n### Distance entre deux points\n\nPour calculer la distance entre deux points, on peut simplement utiliser la fonction processing `dist`, qui prend les coordonn√©es de deux points en param√®tre et renvoie la distance entre. On pourrait n√©anmoins facilement r√©√©crire cette fonction\n\n```java\nfloat distanceBetween(float x1, float y1, float x2, float y2) {\n  float dx = x1 - x2;\n  float dy = y1 - y2;\n  float distance = sqrt(dx * dx + dy * dy);\n  return distance;\n}\n```\n\n### Intersections\n\n#### Entre un point et un rectangle\n\nUn point se situe √† l'int√©rieur d'un rectangle si ses coordonn√©es sont comprises entre les bords de ce rectangle. \n\nOn utilise le coin sup√©rieur gauche du rectangle, la largeur et la hauteur du rectangle.\n\n```java\nboolean isPointInRect(float x, float y,\n                      float rx, float ry, float rw, float rh) {\n  return x \u003e rx \u0026\u0026 x \u003c rx+rw \u0026\u0026\n         y \u003e ry \u0026\u0026 y \u003c ry+rh;\t\t\t\t  \n}\n```\n\n#### Entre deux rectangles\n\nIl y a intersection entre deux rectangles lorsque le coin sup√©rieur gauche de chaque rectangle se situe plus haut et plus √† gauche que le coin inf√©rieur droit de l'autre rectangle.\n\nOn utilise les coordonn√©es du coin sup√©rieur gauche, la largeur et la hauteur de chaque rectangle.\n\n```java\nboolean isIntersectionRects(\n    float x1, float y1, float w1, float h1, \n    float x2, float y2, float w2, float h2) {\n  return x1 \u003c x2+w2 \u0026\u0026 y1 \u003c y2+h2 \u0026\u0026 \n         x2 \u003c x1+w1 \u0026\u0026 y2 \u003c y1+h1;\t\t\t \n}\n```\n\n#### Entre un point et un cercle\n\nUn point se situe √† l'int√©rieur d'un cercle si la distance entre ce point et le centre du cercle est plus petite que le rayon du cercle\n\n```java\nboolean isPointInCircle(float x, float y,\n                        float cx, float cy, float cr) {\n  float dx = x - cx;\n  float dy = y - cy;\n  float distance = sqrt(dx * dx + dy * dy);\n  return distance \u003c cr;\n}\n```\n\n#### Entre deux cercles\n\nIl y a intersection entre deux cercles si la distance entre les centres de ces cercles est plus petite que la somme de leur rayon.\n\n```java\nboolean isIntersectionCircles(\n    float x1, float y1, float r1, \n    float x2, float y2, float r2) { \n  float dx = x1 - x2;\n  float dy = y1 - y2;\n  float distance = sqrt(dx * dx + dy * dy);\n  return distance \u003c r1 + r2;\n}\n```\n\n\u003e ‚Ñπ Si on remplace `\u003c` et `\u003e` par `\u003c=` et `\u003e=` dans les conditions ci-dessus, on consid√®re alors qu'il y a intersection si les bords se touchent ou si le point est sur le bord.","lastmodified":"2022-07-02T09:38:58.525044664Z","tags":null},"/cours/13-intlist-floatlist":{"title":"13 - IntList et FloatList","content":"\n## D√©finition\n\nIl est possible de contenir un grand nombre de variables d'un m√™me type dans [tableau](cours/03-tableaux-matrices.md) mais il s'agit d'une structure de donn√©es contraignante ; la taille du tableu est *fixe*, d√©termin√©e √† sa cr√©ation, et ne pourra pas changer. Si on devait retirer un √©l√©ment de ce tableau, il faudrait en r√©alit√© cr√©er un nouveau tableau de plus petite taille et y mettre les √©l√©ments √† conserver. Pour des [objets](cours/09-classes.md), on peut utiliser des `ArrayList` qui sont des listes dynamiques, de taille variable donc, et processing propose deux classes similaires pour contenir non pas des objets, mais des variables de type `int` ou `float` ; [`IntList`](https://processing.org/reference/IntList.html) et [`FloatList`](https://processing.org/reference/FloatList.html).\n\nUne [`IntList`](https://processing.org/reference/IntList.html) (resp. [`FloatList`](https://processing.org/reference/FloatList.html)) est donc une liste dynamique contenant des √©l√©ments de type `int` (resp. `float`), qui offre les m√™mes possibilit√©s qu'un tableau et en plus le fait de pouvoir supprimer des √©l√©ments de cette liste.\n\n## Utilisation\n\u003e ‚Ñπ Les explications suivantes ne mentionneront que les `IntList` mais tout ce qui est dit s'applique de la m√™me fa√ßon aux `FloatList`\n\n### Cr√©ation\n\nUne `IntList` √©tant une [classe](cours/09-classes.md), on cr√©e une nouvelle liste, un nouvel objet de type `IntList`, gr√¢ce au mot cl√© `new`.\n\nEn utilisant le constructeur par d√©faut, sans param√®tre, on cr√©e une nouvelle liste initialement vide.\n\n```java\nIntList empty = new IntList(); // Nouvelle liste vide, contiendra des entiers\nprintln(empty); // Affiche IntList size=0 [  ]\n```\n\nOn peut aussi cr√©er une liste non vide en passant aux param√®tres du constructeur un tableau d'entiers.\n\n```java\nIntList notEmpty = new IntList({ 0, 1, 2, 3 });\nprintln(notEmpty); // Affiche IntList size=4 [ 0, 1, 2, 3 ]\n```\n\n### Manipulation\n\nLa manipulation d'une [`IntList`]https://processing.org/reference/IntList.html se fait via l'appel √† diff√©rentes m√©thodes sur cette liste :\n\n- `append(value)` qui prend en param√®tre un entier et l'ajoute \"√† la fin\" de la liste\n- `get(i)` qui prend en param√®tre l'indice d'un √©l√©ment, et renvoie l'√©l√©ment se trouvant √† cette place dans la liste\n- `remove(i)` qui prend en param√®tre l'indice d'un √©l√©ment et le supprime de la liste\n- `size()` qui renvoie le nombre d'√©l√©ments que contient la liste\n- `set(i, value)` qui prend en param√®tre un indice et un objet et remplace l'√©l√©ment √† cet indice dans la liste par l'objet pass√© en param√®tre. A l'inverse de la m√™me m√©thode sur une [`ArrayList`](rrayIndexOutOfBoundsException), on peut ici utiliser un indice `i` plus grand que la taille actuelle de la liste, processing rajoutera alors des valeurs 0 dans la liste jusqu'√† l'indice o√π l'on souhaite ins√©rer la valeur.\n\n```java\nIntList list = new IntList();\nprintln(list.size()); // Affiche 0\nlist.append(5);\nlist.append(6);\nprintln(list.size()); // Affiche 2\nprintln(list.get(0)); // Affiche 5\nlist.remove(0);\nprintln(list.get(0)); // Affiche 6\nlist.set(3, 1);\nprintln(list); // Affiche IntList size=4 [ 6, 0, 0, 1 ]\n```\n\n### Erreurs\nSi on essaie d'acc√©der directement √† une position se situant hors du tableau dans les appels √† `get` ou `remove`, on aura une erreur du type `ArrayIndexOutOfBoundsException`. \n\n### Autres m√©thodes utiles\n\nAu-del√† de la manipulation par d√©faut des √©l√©ments d'une [`IntList`](https://processing.org/reference/IntList.html), il existe d'autres m√©thodes qui peuvent s'av√©rer utiles :\n- `clear()`, qui retire tous les √©l√©ments de la liste ; elle sera √† nouveau vide\n- `shuffle()`, qui met les √©l√©ments de la liste dans un ordre al√©atoire\n- `sort()`, qui trie les √©l√©ments de la liste dans l'ordre croissant\n- `reverse()`, qui inverse l'ordre des √©l√©ments dans la liste\n- `sortReverse()`, qui trie les √©l√©ments dans l'ordre d√©croissant ; cela √©quivant √† appeler cons√©cutivement `sort()` et `reverse()`.\n- `min()`, qui renvoie le plus petit √©l√©ment de la liste\n- `max()`, qui renvoie le plus grand √©l√©ment de la liste\n\n","lastmodified":"2022-07-02T09:38:58.525044664Z","tags":null},"/cours/14-images-pixels":{"title":"14 - Images et pixels","content":"\n## Images\n\nProcessing permet de charger des images depuis des fichiers et de les manipuler ensuite pour, notamment, les afficher dans la fen√™tre. Ces images peuvent ensuite √™tre sauvegard√©es dans un fichier.\n\nUne image est repr√©sent√©e par la classe [`PImage`](https://processing.org/reference/PImage.html).\n\n### Chargement et sauvegarde\n\nPour charger une image depuis un fichier existant, il faut utiliser la fonction processing [`loadImage`](https://processing.org/reference/loadImage_.html) avec, en param√®tre, une [cha√Æne de caract√®res](cours/10-strings.md) contenant le chemin vers le fichier de l'image.\n\n\u003e ‚Ñπ Ce chemin peut √™tre sp√©cifi√© de fa√ßon relative depuis l'endroit o√π se situe le fichier .pde (processing) √† ex√©cuter, ou de fa√ßon absolue en partant de la racine C:\\\\ (Windows) ou / (Unix).\n\n```java\nPImage img;\n\nvoid setup() {\n  fullScreen();\n  img = loadImage(\"images/dog.png\");\n}\n```\n\nProcessing ne permet pas de charger des images *avant* le `setup`. On ne peut donc pas appeler la fonction [`loadImage`](https://processing.org/reference/loadImage_.html) au niveau des variables globales. \n\nLes formats d'image accept√©s sont `gif`, `jpg`, `png` et `tga`.\n\n\u003e ‚ö† Si le chemin sp√©cifi√© pour charger une image n'existe pas, la fonction renverra `null`.\n\nOn peut sauvegarder une image gr√¢ce √† la m√©thode `save` sur l'image en \npassant en param√®tre le chemin vers le fichier o√π on l'on veut sauver l'image. Si ce fichier n'existe pas, il sera cr√©√©.\n\n```java\nPImage img;\n\nvoid setup() {\n  fullScreen();\n  img = loadImage(\"images/dog.png\"); // Charge l'image dog.png\n  img.save(\"images/renamedDog.png\"); // Sauve l'image dans un autre fichier\n}\n```\n\n### Manipulation\n\n#### Affichage\n\nPour afficher une image dans la fen√™tre processing, il faut utiliser la fonction `image` avec, en param√®tres, l'image √† afficher et les coordonn√©es *(x, y)* ou placer le coin sup√©rieur gauche de l'image.\n\n```java\nPImage img;\n\nvoid setup() {\n  fullScreen();\n  img = loadImage(\"images/dog.png\"); // Charge l'image dog.png\n  image(img, 0, 0);\n}\n```\n\n#### Attributs\n\nUne fois une image charg√©e, on a acc√®s \n- A sa largeur, via l'attribut `width`\n- A sa hauteur, via l'attribut `height`\n- Aux pixels qui la composent, stock√©s dans un attribut `pixels`, un *tableau √† une dimension* de `color`.\n\nComme les pixels sont stock√©s dans un tableau √† une dimension, on ne peut pas directement acc√©der √† un pixel via ses coordonn√©es \"√©cran\" *(x, y)*. Il faut d'abord convertir ces coordonn√©es dans un rep√®re √† deux dimensions (~ matrice) √† leur coordonn√©e √©quivalente √† une dimension. Ce calcul est relativement simple d√®s lors qu'on conna√Æt la largeur de l'image (~ matrice), car le tableau a une dimension contient en fait le contenu de chaque *ligne* de la matrice, mise bout √† bout.\n\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/1d-2d-dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/1d-2d-lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n\nLa formule pour passer des coordonn√©es *(x, y)* √† deux dimensions √† la coordonn√©e *k* √† une dimension, connaissant la largeur *w*, est `k = y x w + x`. On multiplie *y*, le nombre de lignes, par la largeur de l'image *w*, car on aura, avant le *x*, l'indice de la colonne, tous les √©l√©ments des lignes d'avant, sachant qu'on a *w* √©l√©ments par ligne et *y* lignes.\n\nSimilairement, la formule pour passer de la coordonn√©e *k* √† une dimension aux coordonn√©es *(x, y)*, connaissant la largeur w est :\n- `y = k / w`, la division ***enti√®re*** de *k* par la largeur, pour savoir combien de lignes *compl√®tes* sont incluses jusqu'√† la position *k*\n-  `x = k % w`, le reste de la division enti√®re de *k* par la largeur, pour savoir combien d'√©l√©ments il y a sur la ligne actuelle *incompl√®te* de la matrice o√π se situe *k*\n\n```java\nPImage img;\n\nvoid setup() {\n  fullScreen();\n  img = loadImage(\"images/dog.png\"); // Charge l'image dog.png\n  \n  // Parcourir les pixels\n  for (int k = 0; k \u003c img.pixels.length; k++) {\n    int x = k % img.width;\n    int y = k / img.width;\n    if (img.pixels[k] != img.get(x, y)) {\n      println(\"Pas possible ?!\"); // On ne devrait jamais arriver ici\n    }\n  }\n\n  // Equivalent √†\n  for (int x = 0; x \u003c img.width; x++) {\n    for (int y = 0; y \u003c img.height; y++) {\n      int k = y * img.width + x;\n      if (img.pixels[k] != img.get(x, y)) {\n        println(\"Pas possible ?!\"); // On ne devrait jamais arriver ici\n      }\n    }\n  }\n}\n```\n\n#### M√©thodes\n\nLa classe [`PImage`](https://processing.org/reference/PImage.html) propose des m√©thodes utilitaires pour plus facilement manipuler des images :\n- `get(x, y)` qui renvoie la couleur (`color`) du pixel en position *(x, y)* sur l'image.\n- `get(x, y, w, h)` qui renvoie une sous partie de l'image ; un rectangle dont le coin sup√©rieur gauche est en position *(x, y)*, de largeur *w* et de hauteur *h*.\n- `set(x, y, c)` qui change la couleur du pixel en position *(x, y)* par la couleur *c* pass√©e en param√®tre.\n- `save(filename)` comme d√©j√† mentionn√©, pour sauver l'image dans un fichier *filename*.\n\nIl est plus facile d'interagir avec les pixels de l'image avec les m√©thodes `get` et `set`, mais cela est moins efficace que d'acc√©der directement aux √©l√©ments du tableau de pixels.\n\n## Pixels de la fen√™tre\n\nLa fen√™tre de processing pouvant elle-m√™me √™tre consid√©r√©e comme une image, processing permet d'en manipuler directement les pixels via un tableau de pixels `pixels`. \n\n### Chargement\n\nPour pouvoir lire ou modifier directement les pixels de la fen√™tre de processing, il faut d'abord les *charger* en appelant la fonction [`loadPixels()`](https://processing.org/reference/loadPixels_.html). Une fois cette fonction appel√©e, on aura acc√®s √† une variable globale processing `pixels`, qui est un tableau (√† une dimension) de couleurs.\n\n```java\nvoid setup() {\n  size(20, 20);\n  background(0); // Fond noir\n  loadPixels(); // On charge les pixels de la fen√™tre actuelle de processing\n  color p = pixels[0];\n  println(red(p)); // Composante rouge du premier pixel : 0\n  println(green(p)); // Composante verte du premier pixel : 0\n  println(blue(p)); // Composante bleue du premier pixel : 0\n}\n```\n\n### Manipulation\n\nOn peut manipuler les pixels de la fen√™tre de la m√™me fa√ßon qu'on manipule les pixels d'une image [`PImage`](https://processing.org/reference/PImage.html), **mais** si on modifie la valeur de certains pixels, il faut alors appeler la fonction [`updatePixels()`](https://processing.org/reference/updatePixels_.html) pour que ces changements soient r√©percut√©s sur l'affichage de la fen√™tre.\n\n```java\nvoid setup() {\n  size(20, 20);\n  background(0); // Fond noir\n  loadPixels(); // On charge les pixels de la fen√™tre actuelle de processing\n  \n  pixels[10 * 20 + 10] = color(255, 0, 0);\n  // A ce stade, la fen√™tre n'a pas chang√© et reste toute noire\n  \n  updatePixels(); // On met √† jour la fen√™tre processing\n  // Il y a maintenant un pixel rouge au centre\n}\n```\n\n\u003e ‚Ñπ Manipuler les pixels de la fen√™tre revient √† dessiner des points gr√¢ce √† la fonction `point`.","lastmodified":"2022-07-02T09:38:58.525044664Z","tags":null},"/cours/15-tables":{"title":"15 - Tables","content":"\n## D√©finition\n\nProcessing permet de charger des fichiers tabulaires (`csv`) pour en manipuler les donn√©es, supprimer/rajouter des lignes, etc. Ces donn√©es sont stock√©es dans une *table*, repr√©sent√©e par la classe [`Table`](https://processing.org/reference/Table.html). On peut facilement se repr√©senter de quoi il s'agit en visualisant une feuille Excel. On peut aussi cr√©er soi m√™me des tables et les sauvegarder dans des fichiers.\n\n## Chargement, cr√©ation et sauvegarde\n\n### Chargement\n\nPour charger une table depuis un fichier, il faut utiliser la fonction [`loadTable`](https://processing.org/reference/loadTable_.html), avec, en param√®tre, une [cha√Æne de caract√®res](cours/10-strings.md) contenant le chemin vers le fichier. La logique de chargement est similaire √† celle des [images](cours/14-images-pixels.md) ; le nom du fichier peut √™tre un chemin relatif au sketch processing ou absolu, et on ne peut pas charger des tables avant le `setup`, s'il y a en un.\n\n```java\nTable table = loadTable(\"data.csv\");\n```\n\nLorsque l'on charge une table depuis un fichier, il est possible que le fichier ait une premi√®re ligne repr√©sentant le nom des colonnes (comme dans un tableau Excel). Processing ne pouvant pas le deviner, il faut, quand c'est le cas, sp√©cifier qu'on charge un fichier dont la premi√®re ligne contient les en-t√™tes, en rajoutant en param√®tre la valeur `\"header\"`.\n\n```java\nTable table = loadTable(\"data.csv\", \"header\");\n```\n\n### Cr√©ation\n\nPour cr√©er une nouvelle table, vide, il suffit simplement d'appeler le constructeur de la classe [`Table`](https://processing.org/reference/Table.html) avec le mot cl√© `new`.\n\n```java\nTable newTable = new Table();\n```\n\n### Sauvegarde\n\nPour sauvegarder le contenu d'une table dans un fichier, il faut appeler la fonction [`saveTable`](https://processing.org/reference/saveTable_.html) avec en param√®tres la table √† sauvegarder, et le nom/chemin du fichier o√π la sauvegarder.\n\n```java\nTable table = loadTable(\"data.csv\");\nsaveTable(table, \"renamedData.csv\");\n```\n\n## Manipulation\n\n### Lecture\nLa classe [`Table`](https://processing.org/reference/Table.html) a diff√©rentes m√©thodes qui permettent de lire son contenu ou les informations li√©es :\n- [`getRowCount()`](https://processing.org/reference/Table_getRowCount_.html) renvoie le nombre de lignes, sans inclure la ligne d'en-t√™te s'il y en a une, pr√©sentes dans la table.\n- [`getColumnCount()`](https://processing.org/reference/Table_getColumnCount_.html) renvoie le nombre de colonnes dans la table.\n- [`getString(i, j)`](https://processing.org/reference/Table_getString_.html) ou [`getString(i, name)`](https://processing.org/reference/Table_getString_.html) renvoie la valeur contenue dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-t√™te) comme [`String`](cours/10-strings).\n- [`getFloat(i, j)`](https://processing.org/reference/Table_getFloat_.html)ou [`getFloat(i, name)`](https://processing.org/reference/Table_getFloat_.html) renvoie la valeur contenue dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-t√™te) convertie en `float`.\n- [`getInt(i, j)`](https://processing.org/reference/Table_getInt_.html) ou [`getInt(i, name)`](https://processing.org/reference/Table_getInt_.html) renvoie la valeur contenue dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-t√™te) convertie en `int`.\n\nSoit le fichier `data.csv`\n\n```csv\nc1,c2\na,1\nb,2\nc,3\n```\n\n```java\nTable table = loadTable(\"data.csv\", \"header\");\nprintln(table.getRowCount()); // Affiche 3\nprintln(table.getColumnCount()); // Affiche 2\nprintln(table.getString(0, 0)); // Affiche a\nprintln(table.getInt(1, \"c2\")); // Affiche 2\n```\n\n### Ecriture\n\nPour modifier directement la valeur de cellules existantes dans la table, on peut utiliser les m√©thodes :\n- [`setString(i, j, s)`](https://processing.org/reference/Table_setString_.html) ou [`setString(i, name, s)`](https://processing.org/reference/Table_setString_.html) met la cha√Æne de caract√®res *s* dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-t√™te).\n- [`setFloat(i, j, f)`](https://processing.org/reference/Table_setFloat_.html)ou [`setFloat(i, name, f)`](https://processing.org/reference/Table_setFloat_.html) met le nombre flottant *f* dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-t√™te).\n- [`setInt(i, j, v)`](https://processing.org/reference/Table_setInt_.html) ou [`setInt(i, name, v)`](https://processing.org/reference/Table_setInt_.html) met la valeur enti√®re *k* dans la cellule en ligne *i*, colonne *j* (indice) ou *name* (en-t√™te).\n\nSoit le fichier `data.csv`\n\n```csv\nc1,c2\na,1\nb,2\nc,3\n```\n\n```java\nTable table = loadTable(\"data.csv\", \"header\");\ntable.setString(0, 0, \"aa\");\ntable.setInt(1, \"c2\", 22);\nsaveTable(table, \"data.csv\");\n```\n\nLe fichier `data.csv` contient maintenant\n\n```csv\nc1,c2\naa,1\nb,22\nc,3\n```\n\n### `TableRow`\n\nOn peut acc√©der directement aux cellules de la table depuis l'objet table, de type [`Table`](https://processing.org/reference/Table.html), mais on peut √©galement passer par l'√©tape interm√©diaire qui consiste √† r√©cup√©rer l'objet repr√©sentant une ligne en appelant la m√©thode [`getRow(i)`](https://processing.org/reference/Table_getRow_.html) avec l'indice de la ligne voulue. Ces objets \"lignes\" sont de type [`TableRow`](https://processing.org/reference/TableRow.html), et on peut les manipuler de fa√ßon similaire √† la table :\n- [`getColumnCount()`](https://processing.org/reference/TableRow_getColumnCount_.html) renvoie le nombre de colonnes dans la ligne.\n- [`getColumnTitle(j)`](https://processing.org/reference/TableRow_getColumnTitle_.html) renvoie l'en-t√™te de la colonne d'indice *j*\n- [`getString(j)`](https://processing.org/reference/TableRow_getString_.html) ou [`getString(name)`](https://processing.org/reference/TableRow_getString_.html) renvoie la valeur contenue dans la colonne *j* (indice) ou *name* (en-t√™te) de la ligne, comme [`String`](cours/10-strings).\n- [`getFloat(j)`](https://processing.org/reference/TableRow_getFloat_.html)ou [`getFloat(name)`](https://processing.org/reference/TableRow_getFloat_.html) renvoie la valeur contenue dans la colonne *j* (indice) ou *name* (en-t√™te) de la ligne, convertie en `float`.\n- [`getInt(j)`](https://processing.org/reference/TableRow_getInt_.html) ou [`getInt(name)`](https://processing.org/reference/TableRow_getInt_.html) renvoie la valeur contenue dans la colonne *j* (indice) ou *name* (en-t√™te) de la ligne, convertie en `int`.\n- [`setString(j, s)`](https://processing.org/reference/TableRow_setString_.html) ou [`setString(name, s)`](https://processing.org/reference/TableRow_setString_.html) met la cha√Æne de caract√®res *s* dans la colonne *j* (indice) ou *name* (en-t√™te) de la ligne.\n- [`setFloat(j, f)`](https://processing.org/reference/TableRow_setFloat_.html)ou [`setFloat(name, f)`](https://processing.org/reference/TableRow_setFloat_.html) met le nombre flottant *f* dans la colonne *j* (indice) ou *name* (en-t√™te) de la ligne.\n- [`setInt(j, v)`](https://processing.org/reference/TableRow_setInt_.html) ou [`setInt(name, v)`](https://processing.org/reference/TableRow_setInt_.html) met la valeur enti√®re *k* dans la colonne *j* (indice) ou *name* (en-t√™te) de la ligne.\n\n```csv\nc1,c2\na,1\nb,2\nc,3\n```\n\n```java\nTable table = loadTable(\"data.csv\", \"header\");\nTableRow row1 = table.getRow(0);\nTableRow row2 = table.getRow(1);\nrow1.setString(0, \"aa\");\nrow2.setInt(\"c2\", 22);\nsaveTable(table, \"data.csv\");\n```\n\nLe fichier `data.csv` contient maintenant\n\n```csv\nc1,c2\naa,1\nb,22\nc,3\n```\n\n### Structure\n\nPour modifier la structure d'une table, on peut utiliser les m√©thodes :\n- [`addRow()`](https://processing.org/reference/Table_addRow_.html) ajoute une nouvelle ligne (vide), tout en bas de la table. La ligne cr√©√©e ([`TableRow`](https://processing.org/reference/TableRow.html)) est renvoy√©e. Si on passe une autre [`TableRow`](https://processing.org/reference/TableRow.html) en param√®tre, la nouvelle ligne cr√©√©e contiendra alors une copie des donn√©es de la ligne pass√©e en param√®tre.\n- [`removeRow(i)`](https://processing.org/reference/Table_removeRow_.html) supprime la ligne √† l'indice *i* dans la table.\n- [`addColumn()`](https://processing.org/reference/Table_addColumn_.html) ajoute une nouvelle colonne, vide pour chaque ligne, √† droite de la table. Si on passe en param√®tre le nom de la colonne, il s'agira de l'en-t√™te qui pourra ensuite √™tre utilis√©e pour plus facilement acc√©der aux √©l√©ments de cette colonne. On peut √©ventuellement passer un deuxi√®me param√®tre correspondant au type de donn√©es attendu dans la colonne ; `Table.INT`, `Table.FLOAT` et `Table.STRING` (d√©faut).\n- [`removeColumn(j)`](https://processing.org/reference/Table_removeColumn_.html) ou [`removeColumn(name)`](https://processing.org/reference/Table_removeColumn_.html) supprime la colonne √† l'indice *j* ou avec le nom *name* sp√©cifi√© en param√®tre. \n\n```java\nTable table = new Table();\ntable.addColumn(\"a\"); // On ajoute une colonne a\ntable.addColumn(\"b\"); // On ajoute une colonne b\ntable.addColumn(\"c\"); // On ajoute une colonne c\ntable.removeColumn(\"a\"); // On retire la colonne a\ntable.removeColumn(1); // On retire la deuxi√®me colonne, c\ntable.addColumn(\"d\"); // On ajoute la colonne d\n\n// On a donc une table avec deux colonnes, b et d\n\nTableRow firstRow = table.addRow(); // Premi√®re ligne\nfirstRow.setString(\"b\", \"test\");\nfirstRow.setInt(\"d\", 1);\n\ntable.addRow(firstRow); // On rajoute une deuxi√®me ligne qui contient les m√™mes valeurs que la premi√®re\ntable.setInt(1, \"d\", 2); // On met la valeur 2 dans la colonne d de la deuxi√®me ligne\n\nsaveTable(table, \"random.csv\");\n```\n\nOn obtient alors un fichier `random.csv` contenant :\n\n```csv\nb,d\ntest,1\ntest,2\n```\n\n\n### Tri\n\nOn peut facilement trier une table en appelant la m√©thode [`sort`](https://processing.org/reference/Table_sort_.html) avec en param√®tre l'indice ou le nom de la colonne √† trier. Les lignes de la table seront alors r√©organis√©es selon l'ordre croissant des valeurs apparaissant dans cette colonne.\n\nPour des tris plus complexes qui demandent de comparer plusieurs colonnes, il faudra d√©finir la comparaison ad√©quate et impl√©menter un algorithme de tri.\n\n```java\nvoid setup() {\n  Table t = loadTable(\"data.csv\");\n\n  // Bubble sort\n  for (int k = table.getRowCount()-1; k \u003e 0; k--) {\n    for (int i = 0; i \u003c k; i++) {\n      TableRow row1 = table.getRow(i);\n      TableRow row2 = table.getRow(i + 1);\n      if (compare(row1, row2) \u003e 0) {\n        // La ligne i devrait √™tre apr√®s la ligne i + 1\n        // On les √©change\n        swapRows(table, i, i + 1);\n      }\n    }\n  }\n}\n\nint compare(TableRow row1, TableRow row2) {\n  // Impl√©menter la comparaison\n  return 0;\n}\n\nvoid swapRows(Table t, int i1, int i2) { \n  for (int j = 0; j \u003c t.getColumnCount(); j++) { \n    String swapped = t.getString(i1, j); \n    t.setString(i1, j, t.getString(i2, j)); \n    t.setString(i2, j, swapped); \n  }\n}\n```","lastmodified":"2022-07-02T09:38:58.525044664Z","tags":null},"/tutoriels/debugger":{"title":"D√©bugger (et pas d√©boguer)","content":"\n## Manuellement\nPour d√©bugger manuellement, le plus \"facile\" est parfois de simplement afficher en console, aux endroits importants du code, l'√©tat de certaines variables, ou simplement un indicateur pour savoir si on est arriv√© √† cet endroit du code.\n\n```java\nvoid setup() {\n  println(\"Now calling foo(0)\");\n  foo(0);\n  println(\"Now calling foo(1)\");\n  foo(1);\n}\n\nvoid foo(int i) {\n  println(\"Starting foo with parameter \" + i);\n  for (int j = 0; j \u003c 4; j++) {\n    i = i + 2;\n    println(\"i = \" + i, \"j = \" + j);\n    println(i + j);\n  }\n}\n```\n\nLe probl√®me avec cette fa√ßon de faire est qu'on peut tr√®s vite se perdre dans la quantit√© d'informations qui sera affich√©e en console, d'autant plus pour des dessins anim√©s o√π chaque frame g√©n√®re plein d'impressions en console. Le code s'alourdit √©galement et on en perd en lisibilit√©.\n\n## Debugger processing\n\n### Activer le mode debug\n\nL'environnement processing offre un outil de d√©buggage qui permet de mettre l'ex√©cution du code en *pause* aux endroits voulus, et d'avoir acc√®s au [contexte](cours/07-blocs-contextes.md) de cette ligne de code gr√¢ce √† une fen√™tre suppl√©mentaire qui liste toutes les variables visibles √† ce moment de l'ex√©cution ainsi que leur valeur.\n\nIl s'agit en r√©alit√© d'un mode d'ex√©cution du code diff√©rent, que l'on peut activer dans processing via le raccourci `ctrl-d` ou explicitement via le menu :\n\n![[tutoriels/images/enable-debugger.png]]\n\n### Points d'arr√™t\n\nUne fois le mode activ√©, la fen√™tre de debug s'ouvre. Elle est actuellement vide puisqu'il n'y a pas encore de code en train d'√™tre ex√©cut√©. On peut maintenant d√©finir des points d'arr√™t, ou *breakpoints*, en cliquant sur le num√©ro d'une ligne ; il y aura alors un symbole (losange) √† la place du num√©ro de la ligne. Lorsque le code ex√©cut√© arrivera sur cette ligne de code, il se mettra en pause *avant* que cette ligne soit ex√©cut√©e. Pour retirer le point d'arr√™t, on peut cliquer sur le losange et il dispara√Ætra. On peut d√©finir autant de points d'arr√™t que l'on veut, tant qu'il s'agit d'une ligne *ex√©cutable* (par une ligne vide, par exemple).\n\n![[tutoriels/images/breakpoints.png]]\n\nDans l'exemple ci-dessus, on voit qu'on a mis des points d'arr√™t sur les lignes 2, 3, et 8.\n\n### D√©bugger !\nUne fois le code lanc√©, l'ex√©cution se mettra automatiquement en pause d√®s qu'on arrive sur un point d'arr√™t. La ligne sur laquelle on s'est arr√™t√© aura un symbole diff√©rent (une fl√®che). \n\nLorsque l'ex√©cution est en pause, plusieurs choix sont possibles :\n\n![[tutoriels/images/choices.png]]\n\n- Le premier bouton lance l'ex√©cution compl√®te du code. S'il √©tait d√©j√† lanc√©, il se relan√ßera ; c'est la m√™me chose que pour le mode d'ex√©cution normal.\n- Le deuxi√®me bouton \"step\" permet d'ex√©cuter la ligne de code actuelle, et de passer √† la suivante comme si on y avait mis un point d'arr√™t.\n- Le troisi√®me bouton \"continue\" permet de relancer l'ex√©cution du code jusqu'au prochain point d'arr√™t.\n\nLe bouton step permet ainsi d'ex√©cuter le code ligne par ligne et de voir tous les changements dans le contexte au fur et √† mesure.\n\n### Exemple\n- Dans l'appel de `foo(0)`, on s'arr√™te sur la ligne 8 lors de la premi√®re boucle du `for`. On voit dans la fen√™tre des variables que `i` vaut 0 et `j` vaut 0.\n\n![[tutoriels/images/debug.png]]\n\n- On clique sur le bouton \"step\" et on passe √† la ligne 9. On voit dans la fen√™tre des variables que `i` vaut maintenant 2 (r√©sultat de `i` + 2 √† la ligne d'avant).\n\n![[tutoriels/images/debug-2.png]]\n\n- Ainsi de suite...","lastmodified":"2022-07-02T09:38:58.525044664Z","tags":null},"/tutoriels/space-invaders":{"title":"Space Invaders simplifi√©","content":"\n## Introduction\n\nSpace Invaders est un jeu d‚Äôarcade cr√©√© en 1978. Il s‚Äôagit du tout premier jeu \"shooter' fixe. Dans ce jeu, le joueur incarne un vaisseau qui se d√©place lat√©ralement et tente de repousser une vague d‚Äôenvahisseurs √† l‚Äôaide d‚Äôun canon laser. Les aliens se rapprochent lentement mais s√ªrement du vaisseau et tirent √©galement des lasers vers le vaisseau. Les lasers se d√©placent verticalement et disparaissent quand ils touchent un ennemi ou atteignent le bord de l‚Äô√©cran de jeu. Il y a des obstacles entre le vaisseau et les envahisseurs qui sont progressivement d√©truits par les lasers.\n\n![[tutoriels/images/SpaceInvadersOriginal2.png]]\n\n## Version minimale\n\n### Vie et fin de jeu \nDans cette version, les aliens sont inoffensifs et le joueur ne perd jamais. Quand une vague d‚Äôaliens est enti√®rement d√©truite, une nouvelle vague arrive. \n\n### Ennemis\n\nUne vague d‚Äôaliens a les dimensions suivantes : 5 lignes de 10 aliens. Ils ne se d√©placent pas et ne tirent pas. \n\n### Destruction\n\nAu contact d‚Äôun laser, l‚Äôalien touch√© et le laser sont d√©truits imm√©diatement. Si un laser atteint le haut de l‚Äô√©cran sans avoir touch√© un alien, il dispara√Æt. \n\n### Contr√¥les\n\nLes mouvements lat√©raux du vaisseau sont contr√¥l√©s par les touches `FL√àCHE-GAUCHE` et `FL√àCHE-DROITE`. La touche `ESPACE` permet de tirer des lasers. \n\n### Dimensions\n\nVous pouvez utiliser les dimensions suivantes : \n- Les dimensions de la fen√™tre sont de 1000x800 pixels\n- Les aliens et le vaisseau sont des rectangles de 50x50 pixels\n- Les lasers sont des rectangles de 5x30 pixels \n\n### D√©monstration\n\u003cp align=\"center\"\u003e\n\u003ciframe src=\"https://openprocessing.org/sketch/1592175/embed/?plusEmbedHash=YTc3Mzc1ODI5ODMzYzhkMTdkYzAyM2U4Yjk1MDc4YWJiZTEyMzc2ZjVmZTRmMTQ4NTQ1MGY5NDdmN2VlNTdlNGMwMWI1ZDNjMzc2NjkyZGEyMThiMWIxZGNmODYyZjEyNmM3ODE3YWUyMjZmMDEyMGVhN2NiYTgwYWNkN2U3Y2RrdGg2VWk4NXkxVWNWVitBZitsbXozUTdOVFQ5UERTd0c2dmpZM0VybXloKzFUMUxDb1dvTU9JWWpBWnlEUVdoSlFscFl5SW1TWXRyeWN2ZWhWVEVBUT09\u0026plusEmbedTitle=true\" width=\"600\" height=\"500\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\n\n## Version am√©lior√©e\n\n### Fin de jeu\n\nLes aliens se rapprochent lentement mais s√ªrement du vaisseau. Si le joueur ne parvient pas √† d√©truire l‚Äôenti√®ret√© de la vague avant que les aliens atteignent le bas de l‚Äô√©cran, le jeu est perdu. \n\n### Gestion des couleurs\n\nChaque alien peut, al√©atoirement, avoir une des couleurs suivantes : `color(240, 20, 20)`, `color(200, 20, 200)`, `color(20, 200, 20)`, `color(20, 100, 250)`, `color(240, 200, 0)`. \n\n### Gestion de la difficult√©\n\nLorsque la vague d‚Äôaliens est d√©truite, un nouvelle vague arrive. Chaque vague d‚Äôaliens est plus r√©sistante que la pr√©c√©dente : √† chaque nouvelle vague, il faut un coup de laser en plus pour d√©truire un alien. A la deuxi√®me vague, il faudra donc toucher un alien 2 fois pour le d√©truire, 3 fois pour la troisi√®me vague, et ainsi de suite. \n\n### Gestion de la transparence\n\nSi vous g√©rez √©galement la difficult√© des vagues, le taux d‚Äôopacit√© d‚Äôun alien diminue en fonction du nombre de lasers qui l‚Äôont d√©j√† touch√©, pour un minimum de 50%. Par exemple, √† la vague 3, un alien sera initialement visible √† 100%, √† 75% apr√®s le premier coup et √† 50% apr√®s le deuxi√®me ; il sera d√©truit apr√®s le troisi√®me coup.\n\n### D√©monstration\n\n\u003cp align=\"center\"\u003e\n\u003ciframe src=\"https://openprocessing.org/sketch/1592193/embed/?plusEmbedHash=YmI5ZWNkMzIwYzFiZGNhODBkOGM0NzYyN2ZmMTAyNjBiYzc5OGQ4OTk0OTY2YmJmNTUwMjRlOWZmOWU4MmNiMzQ5ODhmOTg5M2E1MTA0ZjU3OWFkMzRjZThjZTliZmU5NDBiNjcyZmIyNmVhNWQ5YmZmOTkyOWRhM2NjOTI0NzFzSkRWU29QRzRzOTZYOXArekUvTmk3OFhNWWRRRjFCbXVwNkUrZ2ZSNmp4UHlwOUlpaE55WUt5NEc0Y1VubWhNM1JlWWJhVnhaQ3N0RmJQL0xyeXJTUT09\u0026plusEmbedTitle=true\" width=\"600\" height=\"500\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\n\n## Solution\n\nL'enti√®ret√© de la solution est disponible dans le tutoriel OpenProcessing [http://oppr.org/s/cCeVZINr](http://oppr.org/s/cCeVZINr)","lastmodified":"2022-07-02T09:38:58.529044811Z","tags":null},"/tutoriels/structurer-une-solution":{"title":"Structurer une solution processing","content":"\n## Vue d'ensemble\nUne solution [processing](cours/11-bases-processing.md) contiendra\n\n-   La d√©claration de variables globales (visibles dans tous les blocs)\n-   Le `setup`\n-   Le `draw`\n-   Les fonctions de r√©action aux inputs pertinantes (`mousePressed`, `keyPressed`, etc.)\n-   Des fonctions globales, utilitaires\n-   Des classes\n\nIl est plus facile d'√©crire une classe dans un onglet sp√©cifique pour cette classe, et, si le code devient trop long, de regrouper en diff√©rents onglets (~ bloc logique) les diff√©rentes fonctions.\n\n## Etat et donn√©es\n\nL'_√©tat_ du code est l'ensemble des informations (~ variables) qui permettent, √† tout moment, de repr√©senter le dessin et de le faire √©voluer.\n\n### Constantes\n\nLes [variables](cours/01-variables-litteraux.md) **constantes** sont des valeurs qui ne changeront pas lors de l'ex√©cution du code, mais qui seront amen√©es √† √™tre utilis√©es r√©guli√®rement. On pr√©f√®re ainsi voir appara√Ætre ce genre de valeurs dans des variables constantes, pour pouvoir facilement les changer sans devoir reparcourir tout le code. \n\nLorsque ces variables sont bien nomm√©es, elles peuvent √©galement am√©liorer la lisibilit√© du code :\n\n```java\nint WON = 1;\nint PLAYING = 0;\nint LOST = -1;\n\nint status = PLAYING;\n\n// ... Some code\n\nif (status == WON) {\n  // Do something if we won\n} else if (status == LOST) {\n  // Do something else if we lost\n} else {\n  // Continue playing\n}\n```\n\n### D√©terminer les informations n√©cessaires\n\nLes autres variables sont d√©termin√©es par ce dont nous avons besoin pour avoir le comportement voulu. Par exemple, si on veut dessiner une balle qui rebondit sur les bords de l'√©cran, il faudra conna√Ætre les informations qui permettent de dessiner cette balle : ses coordonn√©es, sa taille, sa couleur, etc. Ce qu'on peut voir comme une seule information doit parfois √™tre stock√©e en plusieurs variables.\n\n\u003e ‚ö†Ô∏è Il est **difficile** de r√©ussir √† d√©terminer toutes les variables dont on a besoin d√®s le d√©but. C'est seulement en avan√ßant dans la solution et dans les fonctionnalit√©s impl√©ment√©es qu'on se rend compte qu'il manque des informations.\n\n### Evolution des donn√©es\n\nLes variables non constantes sont amen√©es √† changer lors de l'ex√©cution du code. On peut distinguer deux types d'√©volution :\n- L'√©volution naturelle (dans le `draw`)\n- L'√©volution forc√©e en r√©action aux entr√©es clavier/souris de l'utilisateur\n\n## Initialisation\n\nC'est en g√©n√©ral dans le `setup` qu'on va initialiser l'√©tat, les valeurs initiales des donn√©es. On peut aussi y configurer certains param√®tres globaux du dessin (largeur des lignes, etc.).\n\n```java\nvoid setup() {\n  size(800, 600);\n\n  // Configuration globale du dessin\n\n  // Initialisation des donn√©es\n\t\n}\n```\n\n## Boucle principale\n\nC'est du `draw` que partira la majorit√© de la logique du code : la repr√©sentation, le dessin, et l'√©volution naturelle des donn√©es. L'ordre des diff√©rentes mises √† jour de donn√©es et des dessins d√©pendra du comportement voulu.\n\n```java\nvoid draw() {\n  background(0);\n\n  // Dessiner\n\n  // Faire √©voluer les donn√©es\n\n}\n```\n\n## R√©actions aux entr√©es\n\nIl faudra d√©finir les fonctions correspondant √† toutes les entr√©es possibles pour le dessin et y ajouter la logique voulue. Cette logique est en g√©n√©ral un changement dans l'√©tat des donn√©es qui aura un impact sur l'√©volution naturelle des donn√©es dans le `draw`.\n\nOn pourrait par exemple imaginer une voiture qui roule relativement vite sur une avenue d√©gag√©e. Le mouvement est continu, on ferait donc √©voluer les informations de position dans le `draw`. Au loin, le conducteur aper√ßoit un feu de signalisation qui vient de passer orange. En *r√©action* √† ce *signal*, la position de la voiture ou sa vitesse ne va pas changer, mais le conducteur va appuyer sur le frein pour appliquer une d√©c√©laration qui fera diminuer la vitesse. Il faut donc en g√©n√©ral concevoir les fonctions de r√©action aux entr√©es comme une r√©action ponctuelle √† un signal sans directement appliquer la cons√©quence de cette r√©action.\n\n```java\nint x = 0;\nint speed = 10;\nint acceleration = 0;\n\nvoid setup() {\n  fullScreen();\n  noStroke();\n  fill(255);\n}\n\nvoid draw() {\n  background(0);\n\n  ellipse(x, height / 2, 50, 50);\n\n  speed = constrain(speed + acceleration, -15, 30);\n  x += speed;\n}\n\nvoid keyPressed() {\n  // Signal, on appuie sur l'acc√©l√©rateur ou le frein\n  // On ne modifie pas la vitesse directement\n  if (keyCode == LEFT) {\n    acceleration = -1;  \n  } else if (keyCode == RIGHT) {\n    acceleration = 1;  \n  }\n}\n\nvoid keyReleased() {\n  // Signal, on rel√¢che l'acc√©l√©rateur ou le frein\n  // On ne modifie pas la vitesse directement\n  acceleration = 0;\n}\n```\n\n## Fonctions et classes\n\nL'utilisation de [fonctions](cours/06-fonctions.md) et de [classes](cours/09-classes.md) n'est fondamentalement pas obligatoire pour mettre au point une solution, mais on se prive alors de m√©canismes pr√©cieux permettant de simplifier le code, le rendre plus lisible, d'√©viter la redondance, etc.\n\nPrenons par exemple un dessin o√π un personnage glisse sur le sol jusqu'√† rencontrer un obstacle, auquel cas il trouve une nouvelle direction \"libre\" et continue sa glissade. Le code suivant nous permet facilement de comprendre *ce que fait le dessin*. *Comment* le dessin est effectivement r√©alis√© d√©pendra de la fa√ßon dont on aura d√©fini et impl√©ment√© les diff√©rentes classes/fonctions.\n\n```java\nMyMap map;\nMyCharacter character;\n\nvoid setup() {\n  fullScreen();\n\n  map = new Map();\n  map.addRandomObstacles();\n  \n  character = new MyCharacter(width / 2, height / 2);\n  character.chooseRandomDirection();\n}\n\nvoid draw() {\n  background(0);\n\n  map.display();\n  character.display();\n\n  character.move();\n  \n  if (character.isFacingAnObstacle()) {\n    character.changeDirection();\n  }\n\n}\n```\n\nIl est parfois plus facile de concevoir directement la solution en orient√© objet (\"je vais faire des objets Balle\"). Bien souvent, lorsque l'on d√©termine les informations n√©cessaires, elles-m√™mes sont d√©duites des concepts qui peuvent directement √™tre traduits en classes.\n\n## Conseils g√©n√©raux\n- Aller √† l'essentiel, d'abord faire fonctionner ce qu'on veut puis seulement essayer d'am√©liorer ou de simplifier\n- Isoler des fonctionnalit√©s pour seulement ensuite les int√©grer au code principal\n- Avancer petit √† petit, ne pas essayer de tout faire en une fois\n- [D√©bugger](tutoriels/debugger.md), via le debugger de processing ou en affichant en console ce qu'il se passe, les valeurs, etc.\n\n## Exemple\n\nUn tutoriel processing (disponible ici) montrant comment r√©aliser le dessin d'une balle qui part du centre de l'√©cran vers une direction al√©atoire, et rebondit sur les bords, est disponible ici : [http://oppr.org/s/JADVJw4f](http://oppr.org/s/JADVJw4f)\n","lastmodified":"2022-07-02T09:38:58.529044811Z","tags":null}}