{"/":{"title":"Algorithmes et Programmation","content":"\n\n## Leçons\n\n### Théorie\n#### [01 - Variables et littéraux](cours/01-variables-litteraux.md) \n#### [02 - Expressions](cours/02-expressions.md)\n#### [03 - Tableaux et matrices](cours/03-tableaux-matrices.md)\n#### [04 - Alternatives](cours/04-alternatives.md)\n#### [05 - Boucles](cours/05-boucles.md)\n#### [06 - Fonctions](cours/06-fonctions.md)\n#### [07 - Récursivité](cours/07-recursivite.md)\n#### [08 - Classes](cours/08-classes.md)\n#### [09 - Strings](cours/09-strings.md)\n\n### Processing\n#### [10 - Géométrie](cours/10-geometrie.md)\n#### [11 - Transformations](cours/11-transformations.md)\n\n\n## Tutoriels\n### [Structurer une solution processing](tutoriels/structurer-une-solution.md)\n### [Débugger (WIP)](tutoriels/debugger.md)\n### [Jeu : Space Invaders simplifié (WIP)](tutoriels/space-invaders)\n\n","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/01-variables-litteraux":{"title":"01 - Variables et littéraux","content":"\n## Variables\n\n### Définition\n\nUne variable est un **_conteneur_** défini par\n\n-   Son **type** : le type de données qu'elle pourra contenir\n-   Son **nom** : le nom à utiliser pour récupérer la valeur qu'elle contient\n\n### Types\n\nLes types de variables dits **primitifs** sont les types inhérents au langage (ici, Java), on retrouve notamment\n\n| Type      | Valeurs                                                 |\n|:--------- |:------------------------------------------------------- |\n| `boolean` | `true` ou `false`                                       |\n| `char`    | Caractère, toujours écrit entre `''`, par exemple `'a'` |\n| `short`   | Petit nombre entier entre `-128` et `127`               |\n| `int`     | Grand nombre entier entre `-2147483648` à `2147483647`  |\n| `long`    | Très grand nombre entier                                |\n| `float`   | Nombre décimal, par exemple `3.14`                      |\n| `double`  | Nombre décimal plus précis                              |\n\n### Déclaration\n\nDéclarer une variable permet de créer une nouvelle variable qui sera désormais utilisable dans la suite du code. Pour déclarer une variable, il faut impérativement indiquer son type et son nom :\n\n```java\nint i;\n```\n\nDans ce cas-ci, la variable `i` existe maintenant en processing, mais ne contient encore aucune valeur. On peut également déclarer une nouvelle variable **et** lui donner une valeur initiale :\n\n```java\nint i = 5;\n```\n\n#### Erreurs\n\n-   Lorsque l'on veut utiliser une variable qui n'existe pas, qui n'a pas été déclarée, processing affichera une erreur du type `The variable \"j\" does not exist`\n-  Lorsque l'on déclare une variable avec le même nom qu'une autre variable, processing renverra une erreur du type `Duplicate local variable i`\n\n### Assignation\n\nL'assignation consiste à définir la (nouvelle) valeur d'une variable déclarée :\n\n```java\nint i; // Déclaration\ni = 5; // Assignation\n```\n  \n\nL'assignation est donc une ligne de code du type :\n\n\\\u003cnom\\_variable\\\u003e **=** \\\u003cvaleur\\\u003e ;\n  \nLe symbole **=** est **toujours** l'opérateur qui permet d'assigner une valeur à une variable. La comparaison de deux valeurs se fait avec le symbole **\\=\\=**.\n\nOn peut mettre à droite d'une assignation tout ce qui sera _évalué_ par Processing au **même type** que la variable à laquelle on va assigner cette valeur.\n\n#### Exemples\n\n```java\n// Déclarations\n\nint i;\nint j;\n\n// Assignations\n\ni = 5; // i va contenir 5\nj = 5 * 2; // j va contenir 5 * 2 -\u003e évalué à 10\ni = j; // i va contenir j -\u003e évalué à 10\ni = j * 2; // i va contenir j * 2 -\u003e évalué à 10 * 2 -\u003e évalué à 20\n```\n\n#### Erreurs\n\n- Lorsque l'on veut assigner à une variable une valeur d'un type incompatible, par exemple `int i = 3.14;`, processing affichera une erreur du type `Type mismatch, \"float\" does not match with \"int\"`\n\n### Evaluation\n\nL'**évaluation** est l'interprétation, par Processing, d'un morceau de code, une **[expression](cours/02-expressions.md)**, pour en déduire une **valeur.** Une expression peut être \n\n-   Une valeur (par exemple `1`, `'a'`, `true`, etc.)\n-   Une variable\n-   Un appel de fonction : le type de la valeur sera le type de retour de cette fonction, par exemple `float f = random(0, 1)`, on assigne à la variable `f` un nombre aléatoire entre 0 et 1 que nous retourne la fonction `random`\n-   Un calcul impliquant des valeurs, variables ou appels de fonction : processing respectera alors l'ordre des opérateurs/parenthèses\n\nUne expression peut donc être utilisée\n\n-   Pour une assignation\n\n```java\nint i = 5;\ni = 5 * 2;\ni = i + 1;\n```\n\n-   Dans un appel de fonction\n\n```java\nprintln(i); // On affiche ce que contient la variable i\n```\n\n## Littéraux\n\n### Définition\n\nA la différence d'une variable, un *littéral* qualifie une valeur constante utilisée directement dans du code. \n\n### Type\n\nTout comme une variable, un littéral a un type, mais celui est en général implicite et inféré directement par le langage. On retrouve différents littéraux :\n- `true` et `false`, les littéraux de type booléen\n- Les littéraux de nombres entiers comme `1`, `23094`, etc.\n- Les littéraux de nombres à virgule, comme `3.14`, `-23.45`, etc. On peut forcer le type d'un littéral de nombre à être `float` ou `double`  en utilisant `f` ou `d` après le littéral :\n\t- `1f` est de type `float`\n\t- `3.14d` est de type `double`\n- Les littéraux de type caractère (`char`) comme `'a'`, `'+'`, etc. ; n'importe quel caractère entre deux `'`\n- Les littéraux de chaînes de caractères (strings), vu dans la leçon [09 - Strings](cours/09-strings.md)\n\n### Assignation à une variable\n\nLorsque l'on utilise un littéral dans une assignation pour stocker sa valeur dans une variable, il faut donc que ce type *corresponde* à celui de la variable. \n\n\u003e **Correspondance n'est ici pas équivalence**. \n\nLe littéral `10` est de type entier, mais peut tout à fait être stocké dans une variable de type `float` puisque float peut contenir des nombres de plus grande précision. Le contraire n'est pas vrai ; par exemple, le littéral `3.14` contient un nombre à virgule qui ne peut pas être stocké dans une variable entière (`int`,  `long`) car la précision du littéral est plus grande que celle du type de la variable. Il faut alors convertir explicitement le littéral en entier via la fonction de conversion `int`, par exemple `int(3.14)`, qui ne conservera que la partie entière du nombre.","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/02-expressions":{"title":"02 - Expressions","content":"\n\n## Définition\n\nEn Java, une **expression** est une écriture possédant une ***valeur*** et un ***type*** et dans laquelle on peut retrouver :\n- Des littéraux\n- Des noms de variables\n- Des opérateurs\n- Des appels de [fonctions](cours/06-fonctions.md)\n\nLa ***valeur*** d'une expression est calculée en tenant compte des valeurs contenues dans les variables apparaissant dans l'expression et des valeurs retournées par les appels de fonction. Le ***type*** de l'expression est le type de cette valeur, du résultat.\n\nLes opérateurs possibles dans une expression dépendent de son type. Comme dans des expressions mathématiques classiques, la priorité des opérateurs est respectée pour obtenir le résultat final, et on peut utiliser des parenthèses \n\n## Expressions booléennes\n\nLes expressions booléennes sont des expressions dont le type est `boolean`, c'est-à-dire des expressions dans la valeur est `true` ou `false`. \n\n### Opérateurs \n\nLes opérateurs possibles dans les expressions booléennes sont donc les opérateurs logiques de base ainsi que les opérateurs de comparaison entre nombres.\n\nLes opérateurs logiques sont, dans l'ordre des priorités :\n\n- `!`, la négation \n- `\u0026\u0026`, le ET logique\n- `||` , le OU logique\n\n```java\nprintln(true); // Affiche true\nprintln(!true); // Affiche false\nprintln(true || false); // Affiche true\nprintln(true \u0026\u0026 false); // Affiche false\n\nprintln(true || false \u0026\u0026 false); // Affiche true car on fait d'abord le \u0026\u0026\n                                 // Ca équivaut donc à true || false -\u003e true\nprintln((true || false) \u0026\u0026 false); // Affiche false car on respecte les parenthèses\n                                   // Ca équivaut donc à true \u0026\u0026 false -\u003e false\n``` \n\nLes opérateurs de comparaison ont tous le même ordre d'importance, et sont :\n\n- `==` , l'égalité\n- `!=` , la différence\n- `\u003e` , strictement plus grand\n- `\u003e=`, plus grand ou égal\n- `\u003c`, strictement plus petit\n- `\u003c=`, plus petit ou égal\n\n```java\nprintln(1 == 1); // Affiche true\nprintln(1 != 1); // Affiche false\nprintln(2 \u003e 1); // Affiche true\nprintln(1 \u003e= 2); // Affiche false\nprintln(1 \u003c 2); // Affiche true\nprintln(2 \u003c= 1); // Affiche false\n```\n\n## Expressions mathématiques\n\nLes expressions mathématiques sont des expressions dont le résultat est de type numérique (entier ou flottant). Les opérateurs sont donc les opérateurs classiques en mathématiques, dans l'ordre des priorités :\n\n- `*` et `/` pour la multiplication et la division\n- `+` et `-` pour l'addition et la soustraction\n\n```java\nprintln(1 + 1); // Affiche 2\nprintln(3 * 3); // Affiche 9\nprintln(2 + 2 * 2); // Affiche 6\n```\n\n### Entiers et flottants\n\nIl faut bien faire attention aux types des valeurs que l'on utilise dans une expression car ce sont eux qui déterminent le type du résultat. \n\nLorsqu'une expression ne contient que des valeurs entières, le résultat sera lui-même entier, et ce même si la vraie expression mathématique correspondante ne l'est pas. Ainsi, l'expression `1 / 2` ne contient que des entiers, et le résultat sera donc le résultat de la *division entière* de 1 par 2, qui vaut donc `0`. \n\nDe façon plus générale, si une expression ne contient que des valeurs du même type, ce sera aussi le type de l'expression. Si par contre l'expression contient des valeurs de différents types, l'expression prendra le type ayant la plus grande précision (voir [01 - Variables et littéraux](cours/01-variables-litteraux.md)).\n\nAinsi, si une expression contient des valeurs de type `int` et des valeurs de type `float`, donc flottantes, l'expression sera de type `float`. Par exemple, le résultat de `1.0 / 2` est flottant, et il s'agit donc de la division normale dont le résultat `0.5`.\n\n```java\nint m = 1 / 2; // 0\nfloat n = 1.0 / 2; // 0.5\n```\n\n### Modulo\n\nOn peut également utiliser l'opérateur `%` pour le \"modulo\", le reste de la division entière. \n\n```java\nprintln(1 % 4); // Affiche 1\nprintln(10 % 4); // Affiche 2\nprintln(12 % 4); // Affiche 0\n```\n\nL'utilisation du modulo permet de transformer une suite continue en un cycle de valeurs allant de 0 à la valeur du modulo - 1 :\n\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/modulo_dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/modulo_lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n### Sucres syntaxiques\n(A prononcer avec l'accent québecois car c'est la seule bonne raison de traduire un terme anglais)\n\nLes sucres syntaxiques, ou *syntactic sugars*, sont des facilités, des raccourcis de code qu'un langage met à disposition des utilisateurs.\n\n#### Raccourcis mathématiques\n\nPour les opérations mathématiques, Java propose des raccourcis pour les calculs de la forme *x = x \\\u003copérateur\\\u003e \\\u003cexpression\\\u003e*. C'est-à-dire quand on assigne à une variable le résultat d'une opération simple entre cette variable et une autre expression. On peut éviter de répéter la variable *x* en utilisant le sucre syntaxique correspondant *x \\\u003copérateur\\\u003e= \\\u003cexpression\\\u003e*. Ceci est valable pour les 4 opérateurs mathématiques standards `+`, `-`, `*` et `/`.\n\n```java\nint i = 0;\n\ni = i + 5; // Forme normale\ni += 5; // Sucre syntaxique \n\ni = i * (45 / 3); // Forme normale\ni *= 45 / 3; // Sucre syntaxique\n```\n\n#### Incrémentation et décrémentation\n\nDe plus, lorsque le calcul est de type *x = x + 1* ou *x = x - 1*, on peut davantage simplifier la ligne de code en utilisant les opérateurs d'incrémentation `++` et de décrémentation `--`.\n\n```java\nint i = 0;\n\ni = i + 1; // Forme normale\ni++; // Incrémentation\n\ni = i - 1; // Forme normale\ni--; // Décrémentation\n```\n\n##### 🕵‍♀ Comme expression\n\nLes opérateurs `++` et `--` peuvent s'utiliser avant ou après la variable à incrémenter/décrémentér. Dans les deux cas, la valeur de la variable sera mise à jour avec le résultat de l'addition/soustraction avec 1.\n\nLa différence réside dans le fait qu'il s'agit d'une expression ; on peut donc utiliser l'incrémentation/décrémentation comme expression pour une assignation : `int y = x++`. Dans ce cas, l'ordre dans lequel Java va effecter le calcul et l'évaluation de la valeur à assigner à la deuxième variable dépend du placement de l'opérateur `++` ou `--` :\n\n- Si l'opérateur se situe *après* la variable `x` , alors Java va d'abord évaluer la valeur actuelle de cette variable. Cette valeur sera assignée à la variable `y`, puis le calcul incrémental/décrémental sera effectué et la valeur de `x` changée\n\n```java\nint x = 0;\nint y = x++;\nprintln(x); // Affiche 1\nprintln(y); // Affiche 0\n```\n\n- Si l'opération se situe *avant* la variable `x`, c'est l'inverse. C'est d'abord l'incrémentation/décrémentation qui est faite, puis cette nouvelle valeur de `x` sera assignée à `y`.\n\n```java\nint x = 0;\nint y = ++x;\nprintln(x); // Affiche 1\nprintln(y); // Affiche 1\n```","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/03-tableaux-matrices":{"title":"03 - Tableaux et matrices","content":"\n## Tableaux\n\n### Définition\n\nUn **tableau** est une collection ordonnée de variables du même type. On accède a une variable du tableau grâce au nom du tableau et à la position de la variable dans celui-ci.\n\nUn tableau est un type de données au même titre que le sont `int`, `float`, etc. Il s'agit cependant d'un type dit *référentiel* et non primitif, car la variable de type tableau contient en réalité une référence vers un une suite de blocs en mémoire contenant les variables du tableau.\n\n### Stockage en mémoire\n\nLorsqu'un programme processing s'exécute, il possède sa propre mémoire dans laquelle seront stockées toutes les variables et tout ce qu'il se déroule dans le programme (appels de fonction, etc.). Cette mémoire se compose de deux parties :\n\n- La mémoire dite statique, le *stack*, qui contient notamment les variables (locales) de type primitif et des **références** vers des données stockées dans le *heap*\n- La mémoire dite dynamique, le *heap*, qui contient notamment des tableaux et des [objets](cours/08-classes.md)\n\n\u003cimg src=\"/stic/images/stack_heap_dm.svg\" class=\"svg-dark-mode\"/\u003e\n\u003cimg src=\"/stic/images/stack_heap_lm.svg\" class=\"svg-light-mode\"/\u003e\n\n\u003e ⚠️ Le stockage en mémoire est en réalité plus complexe, l'important ici est de comprendre la différence entre une valeur et une référence. Pour plus de détails sur la gestion de la mémoire lors de l'exécution d'un programme Java, Google est votre ami.\n\n## Déclaration\n\nOn déclare un tableau comme on déclare une [variable](cours/01-variables-litteraux.md), à ceci près qu'il faut rajouter l'opérateur `[]` pour indiquer qu'il s'agit d'un tableau. On peut ajouter cet opérateur soit après le **type** de données du tableau, soit après son nom. Il s'agit de déclarations équivalentes.\n\n```java\nint[] integers;\n```\n\nou\n\n```java\nint integers[];\n```\n\nOn déclare ici une variable appelée `integers` qui est un tableau de nombres entiers.\n\n## Création\n\nIl existe deux façons de créer un tableau :\n\n1. On peut créer un tableau vide en indiquant sa taille, le nombre d'éléments qu'il contient.\n\n```java\nint[] integers = new int[6];\n```\n\n2. On peut créer un tableau en indiquant directement les valeurs qu'il contient entre `{}`. La taille du tableau sera donc le nombre d'éléments qu'on définit.\n\n```java\nint[] integers = new int[] { 1, 2, 4, 8, 16, 32 };\n```\n\nDans les deux cas, l'utilisation du mot clé `new` est obligatoire. Ce mot clé indique qu'on crée une nouvelle **référence** et est responsable de l'allocation en mémoire.\n\n## Manipulation\n\nUne fois un tableau déclaré et créé, on peut accéder à sa taille et aux différents éléments qu'il contient.\n\n### Taille du tableau\n\nLa taille d'un tableau **est déterminée à sa création et ne peut pas être changée**, on peut la récupérer grâce au champ spécial `length` du tableau, de la façon suivante :\n\n```java\nint[] integers = new int[] { 1, 2, 3 };\nprintln(integers.length); // Affiche 3\n```\n\n### Élements du tableau\n\nPour accéder à un élément particulier du tableau, il faut utiliser l'opérateur de tableau et l'indice de l'élément après le nom du tableau, par exemple `integers[1]`.\n\n\u003e ⚠️ En informatique, on commence à compter à partir de 0. Le premier élément aura donc l'indice 0, le deuxième l'indice 1, ainsi de suite.\n\nLorsque l'on accède à un élément du tableau, on récupère une variable (celle stockée dans le heap), et on peut donc s'en servir comme tel ; c'est-à-dire lui assigner une valeur, ou l'évaluer dans des expressions.\n\n```java\nint[] integers = new int[] { 1, 2, 3 };\n\n// Evalue la variable à l'indice 0 dans le tableau et affiche 1\nprintln(integers[0]); \n\n// Assigne la valeur 0 à la variable à l'indice 1 dans le tableau\nintegers[1] = 0; \n\n// Evalue la variable à l'indice 1 dans le tableau et affiche 0\nprintln(integers[0]);\n\n// Evalue la variable à l'indice 2 dans le tableau et affiche 3\nprintln(integers[2]); \n```\n\n### Parcourir le tableau\n\nPour parcourir un tableau, c'est-à-dire pour *itérer* sur chacun de ces éléments, il faudra utiliser une boucle dont les explications sont disponibles dans la leçon [06 - Boucles](cours/05-boucles.md).\n\n### Erreurs\n\n- Lorsque l'on essaie d'accéder à un élément dont l'indice est supérieur à la taille du tableau, c'est-à-dire à une position **hors** du tableau, l'exécution du code provoquera une erreur du type `ArrayIndexOutOfBoundsException` avec l'indice auquel on a voulu accéder.\n\n\n## Matrices\n\n### Tableau de tableaux\n\nUn tableau étant un type de données, il est tout à fait possible de définir un tableau *de tableaux*, c'est-à-dire un tableau dont tous les éléments sont des références vers des tableaux d'un (même) type de données. On peut ainsi avoir un tableau de tableaux d'entiers (2 dimensions), un tableau de tableaux de tableaux de booléens (3 dimensions), etc. Tous les tableaux d'une même dimension auront la même taille, puisque la taille d'un tableau est statique et définie à sa création.\n\n\u003cimg src=\"/stic/images/matrix_dm.svg\" class=\"svg-dark-mode\"/\u003e\n\u003cimg src=\"/stic/images/matrix_lm.svg\" class=\"svg-light-mode\"/\u003e\n\nUne matrice est un tableau de tableaux : un tableau à deux dimensions, comme dans Excel, par exemple. On parlera ainsi de **lignes** pour la première dimension et de **colonnes** pour la deuxième dimension.\n\n### Déclaration\n\nPour déclarer une matrice, il faut simplement déclarer un tableau dont le type d'éléments est lui-même tableau, c'est-à-dire en rajoutant `[]` après le type d'éléments de ce tableau. Par exemple, un tableau de tableaux d'entiers sera noté `int[][]`. \n\n```java\nint[][] t1; // Tableau de tableaux d'entiers\nfloat[][] t2; // Tableau de tableaux de float\nboolean[][] t3; // Tableau de tableaux de booléens\n```\n\n### Création\n\nComme pour un tableau \"classique\", à une seule dimension, une matrice peut être créée de deux façons :\n\n1. On peut créer une matrice vide en indiquant la taille du tableau (le nombre de lignes), et la taille des tableaux se trouvant dans ce tableau principal (le nombre de colonnes) dans l'opérateur `[]`, un par dimension.\n\n```java\n// Tableau contenant 3 tableaux de 10 éléments chacun\nint[][] integers = new int[3][10]; \n```\n\nOn peut donc ainsi créer des tableaux de dimension complètement arbitraire :\n\n```java\nint[][][][][] whyNot = new int[3][6][9][6][3];\n```\n\n2. On peut créer une matrice en indiquant directement les valeurs qu'elle contient entre `{}`. Les accolades délimitent **un** tableau, et pour définir le contenu de la deuxième dimension, le contenu de chaque ligne, il faut aussi utiliser `{}`. Les tailles des tableaux seront alors déterminées automatiquement.\n\n```java\nint[][] integers = new int[][] { \n  { 1, 2, 3 }, // Première ligne\n  { 4, 5, 6 }, // Deuxième ligne\n  { 7, 8, 9 }  // Troisième ligne\n};\n```\n\n### Taille de la matrice\n\nPour la taille de la matrice, on parlera plus simplement de son nombre de lignes et de colonnes, qui sont, respectivement, la taille du tableau de la première dimension et la taille des tableaux de la deuxième dimension. On peut récupérer ces informations comme on le ferait pour un tableau quelconque.\n\n```java\nint[] m = new int[] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint nbLines = m.length;\nint nbColumns = m[0].length; // m[0] = première ligne\n```\n\n### Élements de la matrice\n\nOn accède aux **lignes** d'une matrice de la même façon qu'on manipule un tableau, avec l'opérateur `[]`, et aux éléments d'une ligne en réutilisant l'opérateur `[]` sur la ligne récupérée, puisqu'il s'agit également d'un tableau.\n\n```java\nint[] m = new int[] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint[] firstLine = m[0];\nint[] secondLine = m[1];\nint firstElementOfFirstLine = firstLine[0];\nint lastElementOfThirdLine = m[2][2];\n\nprintln(m[1][1]); // Affiche 5\nm[1][1] = 10;\nprintln(m[1][1]); // Affiche 10\n```\n\nOn parlera en général de coordonnées *i* et *j* des éléments dans la matrice :\n- i est l'indice de la ligne, à utiliser dans les premiers `[]`\n- j est l'indice de la colonne, à utiliser dans les deuxièmes `[]` (les crochets qui s'appliquent donc sur la ligne, le tableau, récupérée par les premiers crochets)\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/matrix_ix_dm.svg\" class=\"svg-dark-mode w-50\"/\u003e\n\u003cimg src=\"/stic/images/matrix_ix_lm.svg\" class=\"svg-light-mode w-50\"/\u003e\n\u003c/p\u003e\n\n### Parcourir une matrice\n\nPour parcourir une matrice, c'est-à-dire pour *itérer* sur chacun de ses éléments, il faudra utiliser des boucles imbriquées dont les explications sont disponibles dans la leçon [05 - Boucles](cours/05-boucles.md).","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/04-alternatives":{"title":"04 - Alternatives","content":"\n## Définition\n\nUne alternative, ou branchement conditionnel, est un *bloc de code* dont l'exécution est **optionnelle** et dépend d'une certaine **condition**, **une [expression](cours/02-expressions.md) booléenne** dans laquelle on retrouve en général des variables utilisées avant cette alternative.\n\n## Branchement `if` simple {id=\"branchementsimple\"}\n\nOn commence toujours une alternative par le mot clé `if` suivi de la condition entre parenthèses. Le code optionnel est le bloc de code compris entre les accolades `{}` venant après le `if`.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est à égal à 0\n  println(\"i est égal à 0\");\n}\n\nprintln(\"Après le if\");\n```\n\n## Branchement avec `else`\n\nLe mot clé `else` permet d'exécuter un bloc de code optionnel, différent, lorsque la condition du `if` le précédant n'est pas remplie. Il faut encore une fois mettre ce bloc de code entre accolades `{}`.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est à égal à 0\n  println(\"i est égal à 0\");\n} else {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i n'est pas égal à 0\n  println(\"i n'est pas égal à 0\");\n}\n\nprintln(\"Après le if/else\");\n```\n\n## Branchement multiple avec `else if`\n\nIl est possible de faire un branchement multiple avec différentes conditions, chacune ayant son propre bloc de code optionnel. Ce branchement multiple commence toujours par un `if`, et chaque branche conditionnelle supplémentaire est introduite via le mot clé `else if` suivi de la condition entre parenthèses.\n\nDès que la condition d'un des branchements est respectée, le bloc de code correspondant sera exécuté, et **on finit le branchement** ; on en sort et continue l'exécution du code suivant le branchement.\n\nDans le cas d'un branchement multiple, le branchement `else`, si présent, ne sera donc exécuté que lorsqu'aucune condition de tous les `if`/`else if` n'est remplie.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est à égal à 0\n  println(\"i est égal à 0\");\n} else if (i \u003e 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est strictement supérieur à 0\n  println(\"i est plus grand que 0\");\n} else {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i n'est ni égal, ni supérieur à 0\n  println(\"i n'est pas égal ni plus grand que 0\");\n}\n\nprintln(\"Après le if/else\");\n```\n\n\u003e ⚠️ Enchaîner plusieurs branchements `if` n'est pas équivalent à un branche `if`/`else if`.  Dans le cas de `if` consécutifs, chaque branchement/condition sera évalué ; dans le cas d'un branchement multiple `if`/`else if`, l'évaluation des conditions s'arrête dès lors que la condition d'une des branches est respectée.\n\n## Branchements imbriqués\nOn parle d'*imbrication* lorsqu'on utilise un branchement conditionnel à l'intérieur d'un autre branchement conditionnel.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est à égal à 0\n  println(\"i est égal à 0\");\n} else if (i \u003e 0) {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i est strictement supérieur à 0\n  println(\"i est plus grand que 0\");\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n} else {\n  // Bloc de code conditionnel\n  // Exécuté uniquement si i n'est ni égal, ni supérieur à 0\n  println(\"i n'est pas égal ni plus grand que 0\");\n  if (i \u003c -5) {\n    println(\"i est plus petit que -5\");\n  }\n}\n\nprintln(\"Après le if/else\");\n```\n\n## Remarques\n\n### Blocs et indentation\nUn bloc de code est délimité par des accolades `{}`. Pour une meilleure lisibilité du code, il est important de penser à *indenter* chaque bloc, c'est à dire à le décaler (vers la droite) du bloc de code qui l'englobe. L'indentation est complètement optionnelle mais essentielle pour un code propre et lisible. \n\nOn peut ainsi facilement voir, dans le cas des branchements conditionnels, dans quelle branche se situe le bloc de code. Cela devient encore plus utile lorsqu'on a plusieurs `if` imbriqués.\n\n```java\nint i = int(random(-10, 10));\n\n// Peu lisible\nif (i \u003e 0) {\nprintln(\"i est plus grand que 0\");\nif (i \u003e 5) {\nprintln(\"i est plus grand que 5\");\n}\n}\n\n// Avec accolades\nif (i \u003e 0) {\n  println(\"i plus grand que 0\");\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n}\n```\n\n### Notation alternative\n\nLorsqu'un bloc de code conditionnel ne contient qu'une seule ligne de code *exécutable*, on peut se passer des accolades `{}`. \n\n```java\nint i = int(random(-10, 10));\n\n// Avec accolades\nif (i \u003e 0) {\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n}\n\n// Sans accolades\nif (i \u003e 0)\n  if (i \u003e 5)\n    println(\"i est plus grand que 5\");\n```\n\nComme on le voit ici, le `if` imbriqué et ce qu'il contient ne sont considérés que comme un seul bloc exécutable, et on peut donc se passer des accolades autour même s'il s'agit, visuellement, de plus qu'une seule ligne de code.\n\n\u003e ⚠️ Pour éviter des problèmes, je conseille d'éviter cette notation et de toujours utiliser les accolades pour délimiter les blocs.","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/05-boucles":{"title":"05 - Boucles","content":"\n## Définition\n\nUne boucle est un *bloc de code* dont l'exécution est **optionnelle** et **répétée** tant que la **condition**, **une [expression](cours/02-expressions.md) booléenne**, est respectée. \n\nLa logique est similaire à celle d'un [branchement conditionnel simple](/cours/04-alternatives.md/#branchementsimple), à la différence que dans un branchement conditionnel, on passe à la suite du code lorsqu'on finit l'exécution du bloc optionnel. Dans le cas d'une boucle, après une exécution du bloc optionnel, on revient à la condition qui est alors réévaluée pour éventuellement recommencer l'exécution du bloc de code.\n\n## Boucle `while`\n\nLa boucle de base est définie par l'utilisation du mot clé `while` suivi de la condition entre parenthèses et du bloc de code optionnel entre accolades `{}`. La structure est la même que pour le branchement simple `if`.\n\n```java\nint i = 0;\n\nwhile (i \u003c 5) {\n  println(i);\n  i += 1;\n}\n```\n\nLe code ci-dessus affichera donc successivement, dans la console :\n```console\n0\n1\n2\n3\n4\n```\n\n## Boucle `for`","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/06-fonctions":{"title":"06 - Fonctions","content":"\n## Définition\n\n## Signature\n\n// Différence fonctions void et avec type de retour\n\n## Appel\n\n// Stack d'appel, contexte, scope\n","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/07-recursivite":{"title":"07 - Récursivité","content":"\n## TODO","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/08-classes":{"title":"08 - Classes","content":"\n## TODO","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/09-strings":{"title":"09 - Strings","content":"\n## Définition\n Un **string** est un type de données particulier permettant de contenir une chaîne de caractères, du texte. Il ne s'agit pas d'un type primitif comme `int`, `float`, etc. mais d'une [classe](cours/08-classes.md) `String` existante dans le langage Java de base.\n\nComme toute variable, on déclare un string en indiquant son type, `String`, et le nom de la variable. En Java, une chaîne de caractères est délimitée par des guillemets. Ainsi, toute valeur entre `\" \"` sera évaluée par processing comme étant du type `String`.\n\n```java\nString s = \"Hello World!\";\nprintln(s); // Affiche Hello World!\n```\n\n### Objets et littéraux\n\nBien que `String` soit une classe, Java permet d'utiliser des littéraux de type `String` : des chaînes de caractères entre guillements `\"`. Ces littéraux sont stockés différemment que les objets en mémoire, de façon centrale, de sorte qu'une même chaîne de caractères utilisée plusieurs fois soit un seul littéral en mémoire.\n\n```java\nprintln(\"abc\" == \"abc\"); // Affiche true\nprintln(\"abc\" == \"bcd\"); // Affiche false\n```\n\nIl est par contre possible de créer explicitement un objet de type `String` via le constructeur en utilisant un littéral en paramètre. Il s'agit alors d'un objet à part entière qui sera stocké dans la mémoire heap, et deux objets `String` qui contiennent la même chaîne de caractères seront différents.\n\n```java\nString s1 = \"Hello\";\nString s2 = new String(\"Hello\");\nprintln(s1 == \"Hello\"); // Affiche true\nprintln(s2 == \"Hello\"); // Affiche false\n```\n\n\n## Manipulation\n\n### Concaténation\n\nLa **concaténation** est une opération qui permet de combiner deux chaînes de caractères via l'opérateur `+`. Les deux chaînes de caractères seront alors mises \"bout à bout\" pour n'en former qu'une.\n\n```java\nString s1 = \"Hello \";\nString s2 = \"World\";\nString s3 = s1 + s2;\nprintln(s); // Affiche Hello World\n```\n\nComme toute opération simple, on peut l'utiliser plusieurs fois dans une même expression, ce qui permet de construire facilement des chaînes de caractères en combinant des variables de type `String`  et des littéraux.\n\n```java\nString s1 = \"Hello\";\nString s2 = \"World\";\nprintln(s1 + \" \" + s2 + \"!\");\n```\n\n#### Concaténation avec un autre type\n\nOn peut concaténer une chaîne de caractères avec une valeur d'un autre type, cette valeur sera alors convertie automatiquement par processing en une chaîne de caractères correspondant à son contenu.\n\n```java\nString s = \"Number \";\nint i = 5;\nprintln(s + i); // Affiche Number 5\n```\n\n\n### Comparaison\n\nComme on peut avoir des objets ou des littéraux `String`, et que les comparaisons classiques avec `==` et `!=` ne se comporteront pas forcément de la façon à laquelle on s'attend, comme expliqué plus haut, il est préférable de se servir des méthodes `compareTo` et `equals`.\n\n#### `compareTo`\n\nLa méthode `compareTo` disponible sur un `String` permet de comparer la chaîne de caractères de ce `String` avec celle passée en paramètre. La méthode renvoie un nombre entier :\n- Positif si le premier `String` est \"plus grand\" que le second, dans l'ordre croissant\n- Négatif si le premier `String` est \"plus petit\" que le second, dans l'ordre croissant\n- 0 si les deux `String` contiennent la même chaîne de caractères.\n\n```java\nString abc = \"abc\";\nString bcd = \"bcd\";\nprintln(abc.compareTo(bcd)); // Affiche -1\nprintln(bcd.compareTo(abc)); // Affiche 1\nprintln(abc.compareTo(\"abc\")); // Affiche 0\n```\n\n#### `equals`\n\nLa méthode `equals` disponible sur un `String` permet de savoir si ce `String` contient la même chaîne de caractères qu'un autre `String`, utilisé en paramètre. Cette méthode renvoie donc le booléen `true` si les deux `String` contiennent la même chaîne de caractères, ou `false` dans le cas contraire.\n\n```java\nString abc = \"abc\";\nString bcd = \"bcd\";\nprintln(abc.equals(bcd)); // Affiche false\nprintln(abc.equals(\"abc\")); // Affiche true\n```\n\n### Méthodes utiles\n\n#### `length`\n\nOn peut récupérer la taille d'une chaîne de caractères en appelant la fonction `length` sur cette chaîne de caractères.\n\n```java\nString s1 = \"Hello\";\nString s2 = \":D\";\nprintln(s1.length()); // Affiche 5\nprintln(s2.length()); // Affiche 2\n```\n\n#### `split`\n\nLa méthode `split` permet de scinder une chaîne de caractères sur base d'un séparateur, une chaîne de caractères à passer en paramètre. Le `split` renvoie un tableau de `String` correspondant aux différentes parties de la chaîne initiale qui étaient séparées par le séparateur. Par exemple, utiliser `split(\" \")` permet de couper une phrase sur les espaces et de récupérer un tableau de mots.\n\n```java\nString s = \"Hello World!\";\nString[] parts = s.split(\" \");\nprintln(parts.length); // Affiche 2\nprintln(parts[0]); // Affiche Hello\nprintln(parts[1]); // Affiche World!\n```\n\n#### `charAt`\n\nLa méthode `charAt` permet de récupérer le caractère (type `char`) se trouvant à l'indice passé en paramètre.\n\n```java\nString s = \"Hello World!\";\nchar h = s.charAt(0);\nchar d  = s.charAt(10);\nprintln(h); // Affiche H\nprintln(d); // Affiche d\n```\n\n#### `substring`\n\nLa méthode `substring` permet de récupérer une partie de la chaîne de caractères initiale. On peut appeler cette méthode de deux façons :\n\n- Avec un seul paramètre de type entier, qui est l'indice du caractère à partir duquel on veut la sous-chaîne de caractères, qui ira jusqu'à la fin de la chaîne de caractères initiale\n```java\nString s = \"Hello World!\";\nString world = s.substring(6);\nprintln(world); // Affiche World!\n```\n- Avec deux paramètres de type entier ; le premier est toujours l'indice du premier caractère de la sous-chaîne voulue, et le deuxième est l'indice du caractère (non-compris) de fin de la sous-chaîne\n```java\nString s = \"Hello World!\";\nString hello = s.substring(0, 5);\nprintln(hello); // Affiche Hello\n```\n","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/10-geometrie":{"title":"10 - Géométrie","content":"\n## TODO","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/11-transformations":{"title":"11 - Transformations","content":"\n## TODO","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/tutoriels/debugger":{"title":"Débugger (et pas déboguer)","content":"\nTODO","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/tutoriels/space-invaders/_index.md":{"title":"Space Invaders simplifié","content":"\n## [Consignes](tutoriels/space-invaders/consignes.md)","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/tutoriels/space-invaders/consignes":{"title":"Space Invaders simplifié","content":"\n## Introduction\n\nSpace Invaders est un jeu d’arcade créé en 1978. Il s’agit du tout premier jeu \"shooter' fixe. Dans ce jeu, le joueur incarne un vaisseau qui se déplace latéralement et tente de repousser une vague d’envahisseurs à l’aide d’un canon laser. Les aliens se rapprochent lentement mais sûrement du vaisseau et tirent également des lasers vers le vaisseau. Les lasers se déplacent verticalement et disparaissent quand ils touchent un ennemi ou atteignent le bord de l’écran de jeu. Il y a des obstacles entre le vaisseau et les envahisseurs qui sont progressivement détruits par les lasers.\n\n![[tutoriels/space-invaders/images/SpaceInvadersOriginal2.png]]\n\n## Version minimale\n\n### Vie et fin de jeu \nDans cette version, les aliens sont inoffensifs et le joueur ne perd jamais. Quand une vague d’aliens est entièrement détruite, une nouvelle vague arrive. \n\n### Ennemis\n\nUne vague d’aliens a les dimensions suivantes : 5 lignes de 10 aliens. Ils ne se déplacent pas et ne tirent pas. \n\n### Destruction\n\nAu contact d’un laser, l’alien touché et le laser sont détruits immédiatement. Si un laser atteint le haut de l’écran sans avoir touché un alien, il disparaît. \n\n### Contrôles\n\nLes mouvements latéraux du vaisseau sont contrôlés par les touches `FLÈCHE-GAUCHE` et `FLÈCHE-DROITE`. La touche `ESPACE` permet de tirer des lasers. \n\n### Dimensions\n\nVous pouvez utiliser les dimensions suivantes : \n- Les dimensions de la fenêtre sont de 1000x800 pixels\n- Les aliens et le vaisseau sont des rectangles de 50x50 pixels\n- Les lasers sont des rectangles de 5x30 pixels \n\n### Démonstration\n\u003cp align=\"center\"\u003e\n\u003ciframe src=\"https://openprocessing.org/sketch/1592175/embed/?plusEmbedHash=YTc3Mzc1ODI5ODMzYzhkMTdkYzAyM2U4Yjk1MDc4YWJiZTEyMzc2ZjVmZTRmMTQ4NTQ1MGY5NDdmN2VlNTdlNGMwMWI1ZDNjMzc2NjkyZGEyMThiMWIxZGNmODYyZjEyNmM3ODE3YWUyMjZmMDEyMGVhN2NiYTgwYWNkN2U3Y2RrdGg2VWk4NXkxVWNWVitBZitsbXozUTdOVFQ5UERTd0c2dmpZM0VybXloKzFUMUxDb1dvTU9JWWpBWnlEUVdoSlFscFl5SW1TWXRyeWN2ZWhWVEVBUT09\u0026plusEmbedTitle=true\" width=\"600\" height=\"500\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\n\n## Version améliorée\n\n### Fin de jeu\n\nLes aliens se rapprochent lentement mais sûrement du vaisseau. Si le joueur ne parvient pas à détruire l’entièreté de la vague avant que les aliens atteignent le bas de l’écran, le jeu est perdu. \n\n### Gestion des couleurs\n\nChaque alien peut, aléatoirement, avoir une des couleurs suivantes : `color(240, 20, 20)`, `color(200, 20, 200)`, `color(20, 200, 20)`, `color(20, 100, 250)`, `color(240, 200, 0)`. \n\n### Gestion de la difficulté\n\nLorsque la vague d’aliens est détruite, un nouvelle vague arrive. Chaque vague d’aliens est plus résistante que la précédente : à chaque nouvelle vague, il faut un coup de laser en plus pour détruire un alien. A la deuxième vague, il faudra donc toucher un alien 2 fois pour le détruire, 3 fois pour la troisième vague, et ainsi de suite. \n\n### Gestion de la transparence\n\nSi vous gérez également la difficulté des vagues, le taux d’opacité d’un alien diminue en fonction du nombre de lasers qui l’ont déjà touché, pour un minimum de 50%. Par exemple, à la vague 3, un alien sera initialement visible à 100%, à 75% après le premier coup et à 50% après le deuxième ; il sera détruit après le troisième coup.\n\n### Démonstration\n\n\u003cp align=\"center\"\u003e\n\u003ciframe src=\"https://openprocessing.org/sketch/1592193/embed/?plusEmbedHash=YmI5ZWNkMzIwYzFiZGNhODBkOGM0NzYyN2ZmMTAyNjBiYzc5OGQ4OTk0OTY2YmJmNTUwMjRlOWZmOWU4MmNiMzQ5ODhmOTg5M2E1MTA0ZjU3OWFkMzRjZThjZTliZmU5NDBiNjcyZmIyNmVhNWQ5YmZmOTkyOWRhM2NjOTI0NzFzSkRWU29QRzRzOTZYOXArekUvTmk3OFhNWWRRRjFCbXVwNkUrZ2ZSNmp4UHlwOUlpaE55WUt5NEc0Y1VubWhNM1JlWWJhVnhaQ3N0RmJQL0xyeXJTUT09\u0026plusEmbedTitle=true\" width=\"600\" height=\"500\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/tutoriels/structurer-une-solution":{"title":"Structurer une solution processing","content":"\n## Vue d'ensemble\nUne solution processing contiendra\n\n-   La déclaration de variables globales (visibles dans tous les blocs)\n-   Le `setup`\n-   Le `draw`\n-   Les fonctions de réaction aux inputs pertinantes (`mousePressed`, `keyPressed`, etc.)\n-   Des fonctions globales, utilitaires\n-   Des classes\n\nIl est plus facile d'écrire une classe dans un onglet spécifique pour cette classe, et, si le code devient trop long, de regrouper en différents onglets (~ bloc logique) les différentes fonctions.\n\n## Etat et données\n\nL'_état_ du code est l'ensemble des informations (~ variables) qui permettent, à tout moment, de représenter le dessin et de le faire évoluer.\n\n### Constantes\n\nLes variables **constantes** sont des valeurs qui ne changeront pas lors de l'exécution du code, mais qui seront amenées à être utilisées régulièrement. On préfère ainsi voir apparaître ce genre de valeurs dans des variables constantes, pour pouvoir facilement les changer sans devoir reparcourir tout le code. \n\nLorsque ces variables sont bien nommées, elles peuvent également améliorer la lisibilité du code :\n\n```java\nint WON = 1;\nint PLAYING = 0;\nint LOST = -1;\n\nint status = PLAYING;\n\n// ... Some code\n\nif (status == WON) {\n  // Do something if we won\n} else if (status == LOST) {\n  // Do something else if we lost\n} else {\n  // Continue playing\n}\n```\n\n### Déterminer les informations nécessaires\n\nLes autres variables sont déterminées par ce dont nous avons besoin pour avoir le comportement voulu. Par exemple, si on veut dessiner une balle qui rebondit sur les bords de l'écran, il faudra connaître les informations qui permettent de dessiner cette balle : ses coordonnées, sa taille, sa couleur, etc. Ce qu'on peut voir comme une seule information doit parfois être stockée en plusieurs variables.\n\n\u003e ⚠️ Il est **difficile** de réussir à déterminer toutes les variables dont on a besoin dès le début. C'est seulement en avançant dans la solution et dans les fonctionnalités implémentées qu'on se rend compte qu'il manque des informations.\n\n### Evolution des données\n\nLes variables non constantes sont amenées à changer lors de l'exécution du code. On peut distinguer deux types d'évolution :\n- L'évolution naturelle (dans le `draw`)\n- L'évolution forcée en réaction aux entrées clavier/souris de l'utilisateur\n\n## Initialisation `setup`\n\nTout dessin processing doit définir la fonction `setup` dans laquelle il convient d'initialiser l'état, les valeurs initiales des données. On peut aussi y configurer certains paramètres globaux du dessin (largeur des lignes, etc.)\n\n```java\nvoid setup() {\n  size(800, 600);\n\n  // Some global drawing parameters\n\n  // Data initialization\n\t\n}\n```\n\n## Boucle principale `draw`\n\nLa \"boucle principale\" est une boucle implicite qui permet de passer à l'étape suivante du code. En processing, cette boucle principale est la fonction `draw`, et une étape est une *frame* du dessin. C'est donc de cette fonction que partira la majorité de la logique du code : la représentation, le dessin, et l'évolution naturelle des données. L'ordre des différentes mises à jour de données et des dessins dépendra du comportement voulu\n\n```java\nvoid draw() {\n  background(0); // Hide previous frame if needed\n\n  // Update state\n\n  // Draw state\n\n}\n```\n\n## Réactions aux entrées\n\nLes différentes entrées possibles en processing sont accessibles via des fonctions qui seront appelées quand l'évènement correspondant survient, entre deux appels de `draw`. Il ne faut définir chaque fonction qu'une seule fois\n\n\u003e ⚠️ Les réactions aux entrées ne fonctionnent que pour les dessins animés, c'est-à-dire les dessins pour lesquels on a défini le `draw`\n\n### Clavier\n\nPour une entrée clavier, il y aura toujours deux événèments :\n- `void keyPressed()` quand on appuie sur la touche du clavier\n- `void keyReleased()` quand on relâche la touche\n\nAttention, maintenir une touche du clavier enfoncée peut provoquer plusieurs appels consécutifs à `keyPressed` mais ce comportement et la fréquence à laquelle l'évènement est produit dépendent du système d'exploitation. Par conséquent, utiliser `keyPressed` pour bouger des parties du dessin (comme un personnage) causera des mouvements saccadés, moins fluides que si l'évolution des coordonnées était réalisée dans le `draw`. \n\n### Souris\n\nPour une entrée souris, il y aura toujours les évènements :\n- `void mousePressed()` quand on appuie sur la touche de la souris\n- `void mouseReleased()` quand on relâche la touche\n- `void mouseClicked()` quand on a appuyé et relâché une touche\n\n## Fonctions\n\nEcrire des fonctions permet de ne définir qu'une seule fois un bloc de code qui sera amené à être utilisé plusieurs fois. On peut également écrire des fonctions simplement pour améliorer la lisibilité (à condition de bien nommer les fonctions) ou pour alléger un long bloc de code.\n\n```java\nint x1 = 0; int y1 = 0;\nint x2 = 10; int y2 = 20;\n\nvoid setup() {\n  size(500, 500);\n\n  fill(int(random(256)));\n  ellipse(x1, y1, 20, 20);\n\t\n  fill(int(random(256)));\n  ellipse(x2, y2, 20, 20);\n}\n```\n\nDevient\n\n```java\nint x1 = 0; int y1 = 0;\nint x2 = 10; int y2 = 20;\n\nvoid setup() {\n  size(500, 500);\n  drawCircleWithRandomColor(x1, y1);\n  drawCircleWithRandomColor(x2, y2);\n}\n\nvoid drawCircleWithRandomColor(float x, float y) {\n  fill(int(random(256)));\n  ellipse(x, y, 20, 20);\n}\n```\n\n## Classes\n\nLes classes permettent de définir des concepts complexes et d'y regrouper les différentes informations (= attributs) et comportements (= méthodes) de ces concepts. Elles permettent, comme les fonctions, d'améliorer la structure et la lisibilité du code. \n\nIl n'est pas nécessaire de faire des classes (ou des fonctions), mais il est parfois plus facile de concevoir directement la solution en orienté objet (\"je vais faire des objets Balle\"). Bien souvent, lorsque l'on détermine les informations nécessaires, elles-mêmes sont déduites des concepts qui peuvent directement être traduits en classes.\n\n```java\nclass CircleWithRandomColor {\n  int x, y;\n  int diameter;\n  int c;\n\n  CircleWithRandomColor(int x, int y, int diameter) {\n    this.x = x;\n    this.y = y;\n    this.diameter = diameter;\n    this.c = int(random(256));\t  \n  }\n\n  void display() {\n    ellipseMode(DIAMETER);\n    fill(c);\n    ellipse(x, y, diameter, diameter);\n  }\n}\n```\n\n## Conseils généraux\n- Aller à l'essentiel, d'abord faire fonctionner ce qu'on veut puis seulement essayer d'améliorer ou de simplifier\n- Isoler des fonctionnalités pour seulement ensuite les intégrer au code principal\n- Avancer petit à petit, ne pas essayer de tout faire en une fois\n- [Débugger](tutoriels/debugger.md), via le debugger de processing ou en affichant en console ce qu'il se passe, les valeurs, etc.\n\n## Exemple\n\nCi-dessous un tutoriel processing (disponible ici) montrant comment réaliser le dessin d'une balle qui part du centre de l'écran vers une direction aléatoire, et rebondit sur les bords\n\n// TODO","lastmodified":"2022-06-26T13:12:20.478559674Z","tags":null}}