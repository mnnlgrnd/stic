{"/":{"title":"Algorithmes et Programmation","content":"\n\n## Le√ßons\n\n### Th√©orie\n#### [01 - Variables et litt√©raux](cours/01-variables-litteraux.md) \n#### [02 - Expressions](cours/02-expressions.md)\n#### [03 - Tableaux et matrices](cours/03-tableaux-matrices.md)\n#### [04 - Alternatives](cours/04-alternatives.md)\n#### [05 - Boucles](cours/05-boucles.md)\n#### [06 - Fonctions](cours/06-fonctions.md)\n#### [07 - R√©cursivit√©](cours/07-recursivite.md)\n#### [08 - Classes](cours/08-classes.md)\n#### [09 - Strings](cours/09-strings.md)\n\n### Processing\n#### [10 - G√©om√©trie](cours/10-geometrie.md)\n#### [11 - Transformations](cours/11-transformations.md)\n\n\n## Tutoriels\n### [Structurer une solution processing](tutoriels/structurer-une-solution.md)\n### [D√©bugger (WIP)](tutoriels/debugger.md)\n### [Jeu : Space Invaders simplifi√© (WIP)](tutoriels/space-invaders)\n\n","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/01-variables-litteraux":{"title":"01 - Variables et litt√©raux","content":"\n## Variables\n\n### D√©finition\n\nUne variable est un **_conteneur_** d√©fini par\n\n-   Son **type** : le type de donn√©es qu'elle pourra contenir\n-   Son **nom** : le nom √† utiliser pour r√©cup√©rer la valeur qu'elle contient\n\n### Types\n\nLes types de variables dits **primitifs** sont les types inh√©rents au langage (ici, Java), on retrouve notamment\n\n| Type      | Valeurs                                                 |\n|:--------- |:------------------------------------------------------- |\n| `boolean` | `true` ou `false`                                       |\n| `char`    | Caract√®re, toujours √©crit entre `''`, par exemple `'a'` |\n| `short`   | Petit nombre entier entre `-128` et `127`               |\n| `int`     | Grand nombre entier entre `-2147483648` √† `2147483647`  |\n| `long`    | Tr√®s grand nombre entier                                |\n| `float`   | Nombre d√©cimal, par exemple `3.14`                      |\n| `double`  | Nombre d√©cimal plus pr√©cis                              |\n\n### D√©claration\n\nD√©clarer une variable permet de cr√©er une nouvelle variable qui sera d√©sormais utilisable dans la suite du code. Pour d√©clarer une variable, il faut imp√©rativement indiquer son type et son nom :\n\n```java\nint i;\n```\n\nDans ce cas-ci, la variable `i` existe maintenant en processing, mais ne contient encore aucune valeur. On peut √©galement d√©clarer une nouvelle variable **et** lui donner une valeur initiale :\n\n```java\nint i = 5;\n```\n\n#### Erreurs\n\n-   Lorsque l'on veut utiliser une variable qui n'existe pas, qui n'a pas √©t√© d√©clar√©e, processing affichera une erreur du type `The variable \"j\" does not exist`\n-  Lorsque l'on d√©clare une variable avec le m√™me nom qu'une autre variable, processing renverra une erreur du type `Duplicate local variable i`\n\n### Assignation\n\nL'assignation consiste √† d√©finir la (nouvelle) valeur d'une variable d√©clar√©e :\n\n```java\nint i; // D√©claration\ni = 5; // Assignation\n```\n  \n\nL'assignation est donc une ligne de code du type :\n\n\\\u003cnom\\_variable\\\u003e **=** \\\u003cvaleur\\\u003e ;\n  \nLe symbole **=** est **toujours** l'op√©rateur qui permet d'assigner une valeur √† une variable. La comparaison de deux valeurs se fait avec le symbole **\\=\\=**.\n\nOn peut mettre √† droite d'une assignation tout ce qui sera _√©valu√©_ par Processing au **m√™me type** que la variable √† laquelle on va assigner cette valeur.\n\n#### Exemples\n\n```java\n// D√©clarations\n\nint i;\nint j;\n\n// Assignations\n\ni = 5; // i va contenir 5\nj = 5 * 2; // j va contenir 5 * 2 -\u003e √©valu√© √† 10\ni = j; // i va contenir j -\u003e √©valu√© √† 10\ni = j * 2; // i va contenir j * 2 -\u003e √©valu√© √† 10 * 2 -\u003e √©valu√© √† 20\n```\n\n#### Erreurs\n\n- Lorsque l'on veut assigner √† une variable une valeur d'un type incompatible, par exemple `int i = 3.14;`, processing affichera une erreur du type `Type mismatch, \"float\" does not match with \"int\"`\n\n### Evaluation\n\nL'**√©valuation** est l'interpr√©tation, par Processing, d'un morceau de code, une **[expression](cours/02-expressions.md)**, pour en d√©duire une **valeur.** Une expression peut √™tre \n\n-   Une valeur (par exemple `1`, `'a'`, `true`, etc.)\n-   Une variable\n-   Un appel de fonction : le type de la valeur sera le type de retour de cette fonction, par exemple `float f = random(0, 1)`, on assigne √† la variable `f` un nombre al√©atoire entre 0 et 1 que nous retourne la fonction `random`\n-   Un calcul impliquant des valeurs, variables ou appels de fonction : processing respectera alors l'ordre des op√©rateurs/parenth√®ses\n\nUne expression peut donc √™tre utilis√©e\n\n-   Pour une assignation\n\n```java\nint i = 5;\ni = 5 * 2;\ni = i + 1;\n```\n\n-   Dans un appel de fonction\n\n```java\nprintln(i); // On affiche ce que contient la variable i\n```\n\n## Litt√©raux\n\n### D√©finition\n\nA la diff√©rence d'une variable, un *litt√©ral* qualifie une valeur constante utilis√©e directement dans du code. \n\n### Type\n\nTout comme une variable, un litt√©ral a un type, mais celui est en g√©n√©ral implicite et inf√©r√© directement par le langage. On retrouve diff√©rents litt√©raux :\n- `true` et `false`, les litt√©raux de type bool√©en\n- Les litt√©raux de nombres entiers comme `1`, `23094`, etc.\n- Les litt√©raux de nombres √† virgule, comme `3.14`, `-23.45`, etc. On peut forcer le type d'un litt√©ral de nombre √† √™tre `float` ou `double`  en utilisant `f` ou `d` apr√®s le litt√©ral :\n\t- `1f` est de type `float`\n\t- `3.14d` est de type `double`\n- Les litt√©raux de type caract√®re (`char`) comme `'a'`, `'+'`, etc. ; n'importe quel caract√®re entre deux `'`\n- Les litt√©raux de cha√Ænes de caract√®res (strings), vu dans la le√ßon [09 - Strings](cours/09-strings.md)\n\n### Assignation √† une variable\n\nLorsque l'on utilise un litt√©ral dans une assignation pour stocker sa valeur dans une variable, il faut donc que ce type *corresponde* √† celui de la variable. \n\n\u003e **Correspondance n'est ici pas √©quivalence**. \n\nLe litt√©ral `10` est de type entier, mais peut tout √† fait √™tre stock√© dans une variable de type `float` puisque float peut contenir des nombres de plus grande pr√©cision. Le contraire n'est pas vrai ; par exemple, le litt√©ral `3.14` contient un nombre √† virgule qui ne peut pas √™tre stock√© dans une variable enti√®re (`int`,  `long`) car la pr√©cision du litt√©ral est plus grande que celle du type de la variable. Il faut alors convertir explicitement le litt√©ral en entier via la fonction de conversion `int`, par exemple `int(3.14)`, qui ne conservera que la partie enti√®re du nombre.","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/02-expressions":{"title":"02 - Expressions","content":"\n\n## D√©finition\n\nEn Java, une **expression** est une √©criture poss√©dant une ***valeur*** et un ***type*** et dans laquelle on peut retrouver :\n- Des litt√©raux\n- Des noms de variables\n- Des op√©rateurs\n- Des appels de [fonctions](cours/06-fonctions.md)\n\nLa ***valeur*** d'une expression est calcul√©e en tenant compte des valeurs contenues dans les variables apparaissant dans l'expression et des valeurs retourn√©es par les appels de fonction. Le ***type*** de l'expression est le type de cette valeur, du r√©sultat.\n\nLes op√©rateurs possibles dans une expression d√©pendent de son type. Comme dans des expressions math√©matiques classiques, la priorit√© des op√©rateurs est respect√©e pour obtenir le r√©sultat final, et on peut utiliser des parenth√®ses \n\n## Expressions bool√©ennes\n\nLes expressions bool√©ennes sont des expressions dont le type est `boolean`, c'est-√†-dire des expressions dans la valeur est `true` ou `false`. \n\n### Op√©rateurs \n\nLes op√©rateurs possibles dans les expressions bool√©ennes sont donc les op√©rateurs logiques de base ainsi que les op√©rateurs de comparaison entre nombres.\n\nLes op√©rateurs logiques sont, dans l'ordre des priorit√©s :\n\n- `!`, la n√©gation \n- `\u0026\u0026`, le ET logique\n- `||` , le OU logique\n\n```java\nprintln(true); // Affiche true\nprintln(!true); // Affiche false\nprintln(true || false); // Affiche true\nprintln(true \u0026\u0026 false); // Affiche false\n\nprintln(true || false \u0026\u0026 false); // Affiche true car on fait d'abord le \u0026\u0026\n                                 // Ca √©quivaut donc √† true || false -\u003e true\nprintln((true || false) \u0026\u0026 false); // Affiche false car on respecte les parenth√®ses\n                                   // Ca √©quivaut donc √† true \u0026\u0026 false -\u003e false\n``` \n\nLes op√©rateurs de comparaison ont tous le m√™me ordre d'importance, et sont :\n\n- `==` , l'√©galit√©\n- `!=` , la diff√©rence\n- `\u003e` , strictement plus grand\n- `\u003e=`, plus grand ou √©gal\n- `\u003c`, strictement plus petit\n- `\u003c=`, plus petit ou √©gal\n\n```java\nprintln(1 == 1); // Affiche true\nprintln(1 != 1); // Affiche false\nprintln(2 \u003e 1); // Affiche true\nprintln(1 \u003e= 2); // Affiche false\nprintln(1 \u003c 2); // Affiche true\nprintln(2 \u003c= 1); // Affiche false\n```\n\n## Expressions math√©matiques\n\nLes expressions math√©matiques sont des expressions dont le r√©sultat est de type num√©rique (entier ou flottant). Les op√©rateurs sont donc les op√©rateurs classiques en math√©matiques, dans l'ordre des priorit√©s :\n\n- `*` et `/` pour la multiplication et la division\n- `+` et `-` pour l'addition et la soustraction\n\n```java\nprintln(1 + 1); // Affiche 2\nprintln(3 * 3); // Affiche 9\nprintln(2 + 2 * 2); // Affiche 6\n```\n\n### Entiers et flottants\n\nIl faut bien faire attention aux types des valeurs que l'on utilise dans une expression car ce sont eux qui d√©terminent le type du r√©sultat. \n\nLorsqu'une expression ne contient que des valeurs enti√®res, le r√©sultat sera lui-m√™me entier, et ce m√™me si la vraie expression math√©matique correspondante ne l'est pas. Ainsi, l'expression `1 / 2` ne contient que des entiers, et le r√©sultat sera donc le r√©sultat de la *division enti√®re* de 1 par 2, qui vaut donc `0`. \n\nDe fa√ßon plus g√©n√©rale, si une expression ne contient que des valeurs du m√™me type, ce sera aussi le type de l'expression. Si par contre l'expression contient des valeurs de diff√©rents types, l'expression prendra le type ayant la plus grande pr√©cision (voir [01 - Variables et litt√©raux](cours/01-variables-litteraux.md)).\n\nAinsi, si une expression contient des valeurs de type `int` et des valeurs de type `float`, donc flottantes, l'expression sera de type `float`. Par exemple, le r√©sultat de `1.0 / 2` est flottant, et il s'agit donc de la division normale dont le r√©sultat `0.5`.\n\n```java\nint m = 1 / 2; // 0\nfloat n = 1.0 / 2; // 0.5\n```\n\n### Modulo\n\nOn peut √©galement utiliser l'op√©rateur `%` pour le \"modulo\", le reste de la division enti√®re. \n\n```java\nprintln(1 % 4); // Affiche 1\nprintln(10 % 4); // Affiche 2\nprintln(12 % 4); // Affiche 0\n```\n\nL'utilisation du modulo permet de transformer une suite continue en un cycle de valeurs allant de 0 √† la valeur du modulo - 1 :\n\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/modulo_dm.svg\" class=\"svg-dark-mode w-75\"/\u003e\n\u003cimg src=\"/stic/images/modulo_lm.svg\" class=\"svg-light-mode w-75\"/\u003e\n\u003c/p\u003e\n\n### Sucres syntaxiques\n(A prononcer avec l'accent qu√©becois car c'est la seule bonne raison de traduire un terme anglais)\n\nLes sucres syntaxiques, ou *syntactic sugars*, sont des facilit√©s, des raccourcis de code qu'un langage met √† disposition des utilisateurs.\n\n#### Raccourcis math√©matiques\n\nPour les op√©rations math√©matiques, Java propose des raccourcis pour les calculs de la forme *x = x \\\u003cop√©rateur\\\u003e \\\u003cexpression\\\u003e*. C'est-√†-dire quand on assigne √† une variable le r√©sultat d'une op√©ration simple entre cette variable et une autre expression. On peut √©viter de r√©p√©ter la variable *x* en utilisant le sucre syntaxique correspondant *x \\\u003cop√©rateur\\\u003e= \\\u003cexpression\\\u003e*. Ceci est valable pour les 4 op√©rateurs math√©matiques standards `+`, `-`, `*` et `/`.\n\n```java\nint i = 0;\n\ni = i + 5; // Forme normale\ni += 5; // Sucre syntaxique \n\ni = i * (45 / 3); // Forme normale\ni *= 45 / 3; // Sucre syntaxique\n```\n\n#### Incr√©mentation et d√©cr√©mentation\n\nDe plus, lorsque le calcul est de type *x = x + 1* ou *x = x - 1*, on peut davantage simplifier la ligne de code en utilisant les op√©rateurs d'incr√©mentation `++` et de d√©cr√©mentation `--`.\n\n```java\nint i = 0;\n\ni = i + 1; // Forme normale\ni++; // Incr√©mentation\n\ni = i - 1; // Forme normale\ni--; // D√©cr√©mentation\n```\n\n##### üïµ‚Äç‚ôÄ Comme expression\n\nLes op√©rateurs `++` et `--` peuvent s'utiliser avant ou apr√®s la variable √† incr√©menter/d√©cr√©ment√©r. Dans les deux cas, la valeur de la variable sera mise √† jour avec le r√©sultat de l'addition/soustraction avec 1.\n\nLa diff√©rence r√©side dans le fait qu'il s'agit d'une expression ; on peut donc utiliser l'incr√©mentation/d√©cr√©mentation comme expression pour une assignation : `int y = x++`. Dans ce cas, l'ordre dans lequel Java va effecter le calcul et l'√©valuation de la valeur √† assigner √† la deuxi√®me variable d√©pend du placement de l'op√©rateur `++` ou `--` :\n\n- Si l'op√©rateur se situe *apr√®s* la variable `x` , alors Java va d'abord √©valuer la valeur actuelle de cette variable. Cette valeur sera assign√©e √† la variable `y`, puis le calcul incr√©mental/d√©cr√©mental sera effectu√© et la valeur de `x` chang√©e\n\n```java\nint x = 0;\nint y = x++;\nprintln(x); // Affiche 1\nprintln(y); // Affiche 0\n```\n\n- Si l'op√©ration se situe *avant* la variable `x`, c'est l'inverse. C'est d'abord l'incr√©mentation/d√©cr√©mentation qui est faite, puis cette nouvelle valeur de `x` sera assign√©e √† `y`.\n\n```java\nint x = 0;\nint y = ++x;\nprintln(x); // Affiche 1\nprintln(y); // Affiche 1\n```","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/03-tableaux-matrices":{"title":"03 - Tableaux et matrices","content":"\n## Tableaux\n\n### D√©finition\n\nUn **tableau** est une collection ordonn√©e de variables du m√™me type. On acc√®de a une variable du tableau gr√¢ce au nom du tableau et √† la position de la variable dans celui-ci.\n\nUn tableau est un type de donn√©es au m√™me titre que le sont `int`, `float`, etc. Il s'agit cependant d'un type dit *r√©f√©rentiel* et non primitif, car la variable de type tableau contient en r√©alit√© une r√©f√©rence vers un une suite de blocs en m√©moire contenant les variables du tableau.\n\n### Stockage en m√©moire\n\nLorsqu'un programme processing s'ex√©cute, il poss√®de sa propre m√©moire dans laquelle seront stock√©es toutes les variables et tout ce qu'il se d√©roule dans le programme (appels de fonction, etc.). Cette m√©moire se compose de deux parties :\n\n- La m√©moire dite statique, le *stack*, qui contient notamment les variables (locales) de type primitif et des **r√©f√©rences** vers des donn√©es stock√©es dans le *heap*\n- La m√©moire dite dynamique, le *heap*, qui contient notamment des tableaux et des [objets](cours/08-classes.md)\n\n\u003cimg src=\"/stic/images/stack_heap_dm.svg\" class=\"svg-dark-mode\"/\u003e\n\u003cimg src=\"/stic/images/stack_heap_lm.svg\" class=\"svg-light-mode\"/\u003e\n\n\u003e ‚ö†Ô∏è Le stockage en m√©moire est en r√©alit√© plus complexe, l'important ici est de comprendre la diff√©rence entre une valeur et une r√©f√©rence. Pour plus de d√©tails sur la gestion de la m√©moire lors de l'ex√©cution d'un programme Java, Google est votre ami.\n\n## D√©claration\n\nOn d√©clare un tableau comme on d√©clare une [variable](cours/01-variables-litteraux.md), √† ceci pr√®s qu'il faut rajouter l'op√©rateur `[]` pour indiquer qu'il s'agit d'un tableau. On peut ajouter cet op√©rateur soit apr√®s le **type** de donn√©es du tableau, soit apr√®s son nom. Il s'agit de d√©clarations √©quivalentes.\n\n```java\nint[] integers;\n```\n\nou\n\n```java\nint integers[];\n```\n\nOn d√©clare ici une variable appel√©e `integers` qui est un tableau de nombres entiers.\n\n## Cr√©ation\n\nIl existe deux fa√ßons de cr√©er un tableau :\n\n1. On peut cr√©er un tableau vide en indiquant sa taille, le nombre d'√©l√©ments qu'il contient.\n\n```java\nint[] integers = new int[6];\n```\n\n2. On peut cr√©er un tableau en indiquant directement les valeurs qu'il contient entre `{}`. La taille du tableau sera donc le nombre d'√©l√©ments qu'on d√©finit.\n\n```java\nint[] integers = new int[] { 1, 2, 4, 8, 16, 32 };\n```\n\nDans les deux cas, l'utilisation du mot cl√© `new` est obligatoire. Ce mot cl√© indique qu'on cr√©e une nouvelle **r√©f√©rence** et est responsable de l'allocation en m√©moire.\n\n## Manipulation\n\nUne fois un tableau d√©clar√© et cr√©√©, on peut acc√©der √† sa taille et aux diff√©rents √©l√©ments qu'il contient.\n\n### Taille du tableau\n\nLa taille d'un tableau **est d√©termin√©e √† sa cr√©ation et ne peut pas √™tre chang√©e**, on peut la r√©cup√©rer gr√¢ce au champ sp√©cial `length` du tableau, de la fa√ßon suivante :\n\n```java\nint[] integers = new int[] { 1, 2, 3 };\nprintln(integers.length); // Affiche 3\n```\n\n### √âlements du tableau\n\nPour acc√©der √† un √©l√©ment particulier du tableau, il faut utiliser l'op√©rateur de tableau et l'indice de l'√©l√©ment apr√®s le nom du tableau, par exemple `integers[1]`.\n\n\u003e ‚ö†Ô∏è En informatique, on commence √† compter √† partir de 0. Le premier √©l√©ment aura donc l'indice 0, le deuxi√®me l'indice 1, ainsi de suite.\n\nLorsque l'on acc√®de √† un √©l√©ment du tableau, on r√©cup√®re une variable (celle stock√©e dans le heap), et on peut donc s'en servir comme tel ; c'est-√†-dire lui assigner une valeur, ou l'√©valuer dans des expressions.\n\n```java\nint[] integers = new int[] { 1, 2, 3 };\n\n// Evalue la variable √† l'indice 0 dans le tableau et affiche 1\nprintln(integers[0]); \n\n// Assigne la valeur 0 √† la variable √† l'indice 1 dans le tableau\nintegers[1] = 0; \n\n// Evalue la variable √† l'indice 1 dans le tableau et affiche 0\nprintln(integers[0]);\n\n// Evalue la variable √† l'indice 2 dans le tableau et affiche 3\nprintln(integers[2]); \n```\n\n### Parcourir le tableau\n\nPour parcourir un tableau, c'est-√†-dire pour *it√©rer* sur chacun de ces √©l√©ments, il faudra utiliser une boucle dont les explications sont disponibles dans la le√ßon [06 - Boucles](cours/05-boucles.md).\n\n### Erreurs\n\n- Lorsque l'on essaie d'acc√©der √† un √©l√©ment dont l'indice est sup√©rieur √† la taille du tableau, c'est-√†-dire √† une position **hors** du tableau, l'ex√©cution du code provoquera une erreur du type `ArrayIndexOutOfBoundsException` avec l'indice auquel on a voulu acc√©der.\n\n\n## Matrices\n\n### Tableau de tableaux\n\nUn tableau √©tant un type de donn√©es, il est tout √† fait possible de d√©finir un tableau *de tableaux*, c'est-√†-dire un tableau dont tous les √©l√©ments sont des r√©f√©rences vers des tableaux d'un (m√™me) type de donn√©es. On peut ainsi avoir un tableau de tableaux d'entiers (2 dimensions), un tableau de tableaux de tableaux de bool√©ens (3 dimensions), etc. Tous les tableaux d'une m√™me dimension auront la m√™me taille, puisque la taille d'un tableau est statique et d√©finie √† sa cr√©ation.\n\n\u003cimg src=\"/stic/images/matrix_dm.svg\" class=\"svg-dark-mode\"/\u003e\n\u003cimg src=\"/stic/images/matrix_lm.svg\" class=\"svg-light-mode\"/\u003e\n\nUne matrice est un tableau de tableaux : un tableau √† deux dimensions, comme dans Excel, par exemple. On parlera ainsi de **lignes** pour la premi√®re dimension et de **colonnes** pour la deuxi√®me dimension.\n\n### D√©claration\n\nPour d√©clarer une matrice, il faut simplement d√©clarer un tableau dont le type d'√©l√©ments est lui-m√™me tableau, c'est-√†-dire en rajoutant `[]` apr√®s le type d'√©l√©ments de ce tableau. Par exemple, un tableau de tableaux d'entiers sera not√© `int[][]`. \n\n```java\nint[][] t1; // Tableau de tableaux d'entiers\nfloat[][] t2; // Tableau de tableaux de float\nboolean[][] t3; // Tableau de tableaux de bool√©ens\n```\n\n### Cr√©ation\n\nComme pour un tableau \"classique\", √† une seule dimension, une matrice peut √™tre cr√©√©e de deux fa√ßons :\n\n1. On peut cr√©er une matrice vide en indiquant la taille du tableau (le nombre de lignes), et la taille des tableaux se trouvant dans ce tableau principal (le nombre de colonnes) dans l'op√©rateur `[]`, un par dimension.\n\n```java\n// Tableau contenant 3 tableaux de 10 √©l√©ments chacun\nint[][] integers = new int[3][10]; \n```\n\nOn peut donc ainsi cr√©er des tableaux de dimension compl√®tement arbitraire :\n\n```java\nint[][][][][] whyNot = new int[3][6][9][6][3];\n```\n\n2. On peut cr√©er une matrice en indiquant directement les valeurs qu'elle contient entre `{}`. Les accolades d√©limitent **un** tableau, et pour d√©finir le contenu de la deuxi√®me dimension, le contenu de chaque ligne, il faut aussi utiliser `{}`. Les tailles des tableaux seront alors d√©termin√©es automatiquement.\n\n```java\nint[][] integers = new int[][] { \n  { 1, 2, 3 }, // Premi√®re ligne\n  { 4, 5, 6 }, // Deuxi√®me ligne\n  { 7, 8, 9 }  // Troisi√®me ligne\n};\n```\n\n### Taille de la matrice\n\nPour la taille de la matrice, on parlera plus simplement de son nombre de lignes et de colonnes, qui sont, respectivement, la taille du tableau de la premi√®re dimension et la taille des tableaux de la deuxi√®me dimension. On peut r√©cup√©rer ces informations comme on le ferait pour un tableau quelconque.\n\n```java\nint[] m = new int[] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint nbLines = m.length;\nint nbColumns = m[0].length; // m[0] = premi√®re ligne\n```\n\n### √âlements de la matrice\n\nOn acc√®de aux **lignes** d'une matrice de la m√™me fa√ßon qu'on manipule un tableau, avec l'op√©rateur `[]`, et aux √©l√©ments d'une ligne en r√©utilisant l'op√©rateur `[]` sur la ligne r√©cup√©r√©e, puisqu'il s'agit √©galement d'un tableau.\n\n```java\nint[] m = new int[] { \n  { 1, 2, 3 }, \n  { 4, 5, 6 }, \n  { 7, 8, 9 } \n};\n\nint[] firstLine = m[0];\nint[] secondLine = m[1];\nint firstElementOfFirstLine = firstLine[0];\nint lastElementOfThirdLine = m[2][2];\n\nprintln(m[1][1]); // Affiche 5\nm[1][1] = 10;\nprintln(m[1][1]); // Affiche 10\n```\n\nOn parlera en g√©n√©ral de coordonn√©es *i* et *j* des √©l√©ments dans la matrice :\n- i est l'indice de la ligne, √† utiliser dans les premiers `[]`\n- j est l'indice de la colonne, √† utiliser dans les deuxi√®mes `[]` (les crochets qui s'appliquent donc sur la ligne, le tableau, r√©cup√©r√©e par les premiers crochets)\n\n\u003cp align=\"center\"\u003e\n\u003cimg src=\"/stic/images/matrix_ix_dm.svg\" class=\"svg-dark-mode w-50\"/\u003e\n\u003cimg src=\"/stic/images/matrix_ix_lm.svg\" class=\"svg-light-mode w-50\"/\u003e\n\u003c/p\u003e\n\n### Parcourir une matrice\n\nPour parcourir une matrice, c'est-√†-dire pour *it√©rer* sur chacun de ses √©l√©ments, il faudra utiliser des boucles imbriqu√©es dont les explications sont disponibles dans la le√ßon [05 - Boucles](cours/05-boucles.md).","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/04-alternatives":{"title":"04 - Alternatives","content":"\n## D√©finition\n\nUne alternative, ou branchement conditionnel, est un *bloc de code* dont l'ex√©cution est **optionnelle** et d√©pend d'une certaine **condition**, **une [expression](cours/02-expressions.md) bool√©enne** dans laquelle on retrouve en g√©n√©ral des variables utilis√©es avant cette alternative.\n\n## Branchement `if` simple {id=\"branchementsimple\"}\n\nOn commence toujours une alternative par le mot cl√© `if` suivi de la condition entre parenth√®ses. Le code optionnel est le bloc de code compris entre les accolades `{}` venant apr√®s le `if`.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est √† √©gal √† 0\n  println(\"i est √©gal √† 0\");\n}\n\nprintln(\"Apr√®s le if\");\n```\n\n## Branchement avec `else`\n\nLe mot cl√© `else` permet d'ex√©cuter un bloc de code optionnel, diff√©rent, lorsque la condition du `if` le pr√©c√©dant n'est pas remplie. Il faut encore une fois mettre ce bloc de code entre accolades `{}`.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est √† √©gal √† 0\n  println(\"i est √©gal √† 0\");\n} else {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i n'est pas √©gal √† 0\n  println(\"i n'est pas √©gal √† 0\");\n}\n\nprintln(\"Apr√®s le if/else\");\n```\n\n## Branchement multiple avec `else if`\n\nIl est possible de faire un branchement multiple avec diff√©rentes conditions, chacune ayant son propre bloc de code optionnel. Ce branchement multiple commence toujours par un `if`, et chaque branche conditionnelle suppl√©mentaire est introduite via le mot cl√© `else if` suivi de la condition entre parenth√®ses.\n\nD√®s que la condition d'un des branchements est respect√©e, le bloc de code correspondant sera ex√©cut√©, et **on finit le branchement** ; on en sort et continue l'ex√©cution du code suivant le branchement.\n\nDans le cas d'un branchement multiple, le branchement `else`, si pr√©sent, ne sera donc ex√©cut√© que lorsqu'aucune condition de tous les `if`/`else if` n'est remplie.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est √† √©gal √† 0\n  println(\"i est √©gal √† 0\");\n} else if (i \u003e 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est strictement sup√©rieur √† 0\n  println(\"i est plus grand que 0\");\n} else {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i n'est ni √©gal, ni sup√©rieur √† 0\n  println(\"i n'est pas √©gal ni plus grand que 0\");\n}\n\nprintln(\"Apr√®s le if/else\");\n```\n\n\u003e ‚ö†Ô∏è Encha√Æner plusieurs branchements `if` n'est pas √©quivalent √† un branche `if`/`else if`.  Dans le cas de `if` cons√©cutifs, chaque branchement/condition sera √©valu√© ; dans le cas d'un branchement multiple `if`/`else if`, l'√©valuation des conditions s'arr√™te d√®s lors que la condition d'une des branches est respect√©e.\n\n## Branchements imbriqu√©s\nOn parle d'*imbrication* lorsqu'on utilise un branchement conditionnel √† l'int√©rieur d'un autre branchement conditionnel.\n\n```java\nint i = int(random(-10, 10));\n\nif (i == 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est √† √©gal √† 0\n  println(\"i est √©gal √† 0\");\n} else if (i \u003e 0) {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i est strictement sup√©rieur √† 0\n  println(\"i est plus grand que 0\");\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n} else {\n  // Bloc de code conditionnel\n  // Ex√©cut√© uniquement si i n'est ni √©gal, ni sup√©rieur √† 0\n  println(\"i n'est pas √©gal ni plus grand que 0\");\n  if (i \u003c -5) {\n    println(\"i est plus petit que -5\");\n  }\n}\n\nprintln(\"Apr√®s le if/else\");\n```\n\n## Remarques\n\n### Blocs et indentation\nUn bloc de code est d√©limit√© par des accolades `{}`. Pour une meilleure lisibilit√© du code, il est important de penser √† *indenter* chaque bloc, c'est √† dire √† le d√©caler (vers la droite) du bloc de code qui l'englobe. L'indentation est compl√®tement optionnelle mais essentielle pour un code propre et lisible. \n\nOn peut ainsi facilement voir, dans le cas des branchements conditionnels, dans quelle branche se situe le bloc de code. Cela devient encore plus utile lorsqu'on a plusieurs `if` imbriqu√©s.\n\n```java\nint i = int(random(-10, 10));\n\n// Peu lisible\nif (i \u003e 0) {\nprintln(\"i est plus grand que 0\");\nif (i \u003e 5) {\nprintln(\"i est plus grand que 5\");\n}\n}\n\n// Avec accolades\nif (i \u003e 0) {\n  println(\"i plus grand que 0\");\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n}\n```\n\n### Notation alternative\n\nLorsqu'un bloc de code conditionnel ne contient qu'une seule ligne de code *ex√©cutable*, on peut se passer des accolades `{}`. \n\n```java\nint i = int(random(-10, 10));\n\n// Avec accolades\nif (i \u003e 0) {\n  if (i \u003e 5) {\n    println(\"i est plus grand que 5\");\n  }\n}\n\n// Sans accolades\nif (i \u003e 0)\n  if (i \u003e 5)\n    println(\"i est plus grand que 5\");\n```\n\nComme on le voit ici, le `if` imbriqu√© et ce qu'il contient ne sont consid√©r√©s que comme un seul bloc ex√©cutable, et on peut donc se passer des accolades autour m√™me s'il s'agit, visuellement, de plus qu'une seule ligne de code.\n\n\u003e ‚ö†Ô∏è Pour √©viter des probl√®mes, je conseille d'√©viter cette notation et de toujours utiliser les accolades pour d√©limiter les blocs.","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/05-boucles":{"title":"05 - Boucles","content":"\n## D√©finition\n\nUne boucle est un *bloc de code* dont l'ex√©cution est **optionnelle** et **r√©p√©t√©e** tant que la **condition**, **une [expression](cours/02-expressions.md) bool√©enne**, est respect√©e. \n\nLa logique est similaire √† celle d'un [branchement conditionnel simple](/cours/04-alternatives.md/#branchementsimple), √† la diff√©rence que dans un branchement conditionnel, on passe √† la suite du code lorsqu'on finit l'ex√©cution du bloc optionnel. Dans le cas d'une boucle, apr√®s une ex√©cution du bloc optionnel, on revient √† la condition qui est alors r√©√©valu√©e pour √©ventuellement recommencer l'ex√©cution du bloc de code.\n\n## Boucle `while`\n\nLa boucle de base est d√©finie par l'utilisation du mot cl√© `while` suivi de la condition entre parenth√®ses et du bloc de code optionnel entre accolades `{}`. La structure est la m√™me que pour le branchement simple `if`.\n\n```java\nint i = 0;\n\nwhile (i \u003c 5) {\n  println(i);\n  i += 1;\n}\n```\n\nLe code ci-dessus affichera donc successivement, dans la console :\n```console\n0\n1\n2\n3\n4\n```\n\n## Boucle `for`","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/06-fonctions":{"title":"06 - Fonctions","content":"\n## D√©finition\n\n## Signature\n\n// Diff√©rence fonctions void et avec type de retour\n\n## Appel\n\n// Stack d'appel, contexte, scope\n","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/07-recursivite":{"title":"07 - R√©cursivit√©","content":"\n## TODO","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/08-classes":{"title":"08 - Classes","content":"\n## TODO","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/09-strings":{"title":"09 - Strings","content":"\n## D√©finition\n Un **string** est un type de donn√©es particulier permettant de contenir une cha√Æne de caract√®res, du texte. Il ne s'agit pas d'un type primitif comme `int`, `float`, etc. mais d'une [classe](cours/08-classes.md) `String` existante dans le langage Java de base.\n\nComme toute variable, on d√©clare un string en indiquant son type, `String`, et le nom de la variable. En Java, une cha√Æne de caract√®res est d√©limit√©e par des guillemets. Ainsi, toute valeur entre `\" \"` sera √©valu√©e par processing comme √©tant du type `String`.\n\n```java\nString s = \"Hello World!\";\nprintln(s); // Affiche Hello World!\n```\n\n### Objets et litt√©raux\n\nBien que `String` soit une classe, Java permet d'utiliser des litt√©raux de type `String` : des cha√Ænes de caract√®res entre guillements `\"`. Ces litt√©raux sont stock√©s diff√©remment que les objets en m√©moire, de fa√ßon centrale, de sorte qu'une m√™me cha√Æne de caract√®res utilis√©e plusieurs fois soit un seul litt√©ral en m√©moire.\n\n```java\nprintln(\"abc\" == \"abc\"); // Affiche true\nprintln(\"abc\" == \"bcd\"); // Affiche false\n```\n\nIl est par contre possible de cr√©er explicitement un objet de type `String` via le constructeur en utilisant un litt√©ral en param√®tre. Il s'agit alors d'un objet √† part enti√®re qui sera stock√© dans la m√©moire heap, et deux objets `String` qui contiennent la m√™me cha√Æne de caract√®res seront diff√©rents.\n\n```java\nString s1 = \"Hello\";\nString s2 = new String(\"Hello\");\nprintln(s1 == \"Hello\"); // Affiche true\nprintln(s2 == \"Hello\"); // Affiche false\n```\n\n\n## Manipulation\n\n### Concat√©nation\n\nLa **concat√©nation** est une op√©ration qui permet de combiner deux cha√Ænes de caract√®res via l'op√©rateur `+`. Les deux cha√Ænes de caract√®res seront alors mises \"bout √† bout\" pour n'en former qu'une.\n\n```java\nString s1 = \"Hello \";\nString s2 = \"World\";\nString s3 = s1 + s2;\nprintln(s); // Affiche Hello World\n```\n\nComme toute op√©ration simple, on peut l'utiliser plusieurs fois dans une m√™me expression, ce qui permet de construire facilement des cha√Ænes de caract√®res en combinant des variables de type `String`  et des litt√©raux.\n\n```java\nString s1 = \"Hello\";\nString s2 = \"World\";\nprintln(s1 + \" \" + s2 + \"!\");\n```\n\n#### Concat√©nation avec un autre type\n\nOn peut concat√©ner une cha√Æne de caract√®res avec une valeur d'un autre type, cette valeur sera alors convertie automatiquement par processing en une cha√Æne de caract√®res correspondant √† son contenu.\n\n```java\nString s = \"Number \";\nint i = 5;\nprintln(s + i); // Affiche Number 5\n```\n\n\n### Comparaison\n\nComme on peut avoir des objets ou des litt√©raux `String`, et que les comparaisons classiques avec `==` et `!=` ne se comporteront pas forc√©ment de la fa√ßon √† laquelle on s'attend, comme expliqu√© plus haut, il est pr√©f√©rable de se servir des m√©thodes `compareTo` et `equals`.\n\n#### `compareTo`\n\nLa m√©thode `compareTo` disponible sur un `String` permet de comparer la cha√Æne de caract√®res de ce `String` avec celle pass√©e en param√®tre. La m√©thode renvoie un nombre entier :\n- Positif si le premier `String` est \"plus grand\" que le second, dans l'ordre croissant\n- N√©gatif si le premier `String` est \"plus petit\" que le second, dans l'ordre croissant\n- 0 si les deux `String` contiennent la m√™me cha√Æne de caract√®res.\n\n```java\nString abc = \"abc\";\nString bcd = \"bcd\";\nprintln(abc.compareTo(bcd)); // Affiche -1\nprintln(bcd.compareTo(abc)); // Affiche 1\nprintln(abc.compareTo(\"abc\")); // Affiche 0\n```\n\n#### `equals`\n\nLa m√©thode `equals` disponible sur un `String` permet de savoir si ce `String` contient la m√™me cha√Æne de caract√®res qu'un autre `String`, utilis√© en param√®tre. Cette m√©thode renvoie donc le bool√©en `true` si les deux `String` contiennent la m√™me cha√Æne de caract√®res, ou `false` dans le cas contraire.\n\n```java\nString abc = \"abc\";\nString bcd = \"bcd\";\nprintln(abc.equals(bcd)); // Affiche false\nprintln(abc.equals(\"abc\")); // Affiche true\n```\n\n### M√©thodes utiles\n\n#### `length`\n\nOn peut r√©cup√©rer la taille d'une cha√Æne de caract√®res en appelant la fonction `length` sur cette cha√Æne de caract√®res.\n\n```java\nString s1 = \"Hello\";\nString s2 = \":D\";\nprintln(s1.length()); // Affiche 5\nprintln(s2.length()); // Affiche 2\n```\n\n#### `split`\n\nLa m√©thode `split` permet de scinder une cha√Æne de caract√®res sur base d'un s√©parateur, une cha√Æne de caract√®res √† passer en param√®tre. Le `split` renvoie un tableau de `String` correspondant aux diff√©rentes parties de la cha√Æne initiale qui √©taient s√©par√©es par le s√©parateur. Par exemple, utiliser `split(\" \")` permet de couper une phrase sur les espaces et de r√©cup√©rer un tableau de mots.\n\n```java\nString s = \"Hello World!\";\nString[] parts = s.split(\" \");\nprintln(parts.length); // Affiche 2\nprintln(parts[0]); // Affiche Hello\nprintln(parts[1]); // Affiche World!\n```\n\n#### `charAt`\n\nLa m√©thode `charAt` permet de r√©cup√©rer le caract√®re (type `char`) se trouvant √† l'indice pass√© en param√®tre.\n\n```java\nString s = \"Hello World!\";\nchar h = s.charAt(0);\nchar d  = s.charAt(10);\nprintln(h); // Affiche H\nprintln(d); // Affiche d\n```\n\n#### `substring`\n\nLa m√©thode `substring` permet de r√©cup√©rer une partie de la cha√Æne de caract√®res initiale. On peut appeler cette m√©thode de deux fa√ßons :\n\n- Avec un seul param√®tre de type entier, qui est l'indice du caract√®re √† partir duquel on veut la sous-cha√Æne de caract√®res, qui ira jusqu'√† la fin de la cha√Æne de caract√®res initiale\n```java\nString s = \"Hello World!\";\nString world = s.substring(6);\nprintln(world); // Affiche World!\n```\n- Avec deux param√®tres de type entier ; le premier est toujours l'indice du premier caract√®re de la sous-cha√Æne voulue, et le deuxi√®me est l'indice du caract√®re (non-compris) de fin de la sous-cha√Æne\n```java\nString s = \"Hello World!\";\nString hello = s.substring(0, 5);\nprintln(hello); // Affiche Hello\n```\n","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/10-geometrie":{"title":"10 - G√©om√©trie","content":"\n## TODO","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/cours/11-transformations":{"title":"11 - Transformations","content":"\n## TODO","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/tutoriels/debugger":{"title":"D√©bugger (et pas d√©boguer)","content":"\nTODO","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/tutoriels/space-invaders/_index.md":{"title":"Space Invaders simplifi√©","content":"\n## [Consignes](tutoriels/space-invaders/consignes.md)","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/tutoriels/space-invaders/consignes":{"title":"Space Invaders simplifi√©","content":"\n## Introduction\n\nSpace Invaders est un jeu d‚Äôarcade cr√©√© en 1978. Il s‚Äôagit du tout premier jeu \"shooter' fixe. Dans ce jeu, le joueur incarne un vaisseau qui se d√©place lat√©ralement et tente de repousser une vague d‚Äôenvahisseurs √† l‚Äôaide d‚Äôun canon laser. Les aliens se rapprochent lentement mais s√ªrement du vaisseau et tirent √©galement des lasers vers le vaisseau. Les lasers se d√©placent verticalement et disparaissent quand ils touchent un ennemi ou atteignent le bord de l‚Äô√©cran de jeu. Il y a des obstacles entre le vaisseau et les envahisseurs qui sont progressivement d√©truits par les lasers.\n\n![[tutoriels/space-invaders/images/SpaceInvadersOriginal2.png]]\n\n## Version minimale\n\n### Vie et fin de jeu \nDans cette version, les aliens sont inoffensifs et le joueur ne perd jamais. Quand une vague d‚Äôaliens est enti√®rement d√©truite, une nouvelle vague arrive. \n\n### Ennemis\n\nUne vague d‚Äôaliens a les dimensions suivantes : 5 lignes de 10 aliens. Ils ne se d√©placent pas et ne tirent pas. \n\n### Destruction\n\nAu contact d‚Äôun laser, l‚Äôalien touch√© et le laser sont d√©truits imm√©diatement. Si un laser atteint le haut de l‚Äô√©cran sans avoir touch√© un alien, il dispara√Æt. \n\n### Contr√¥les\n\nLes mouvements lat√©raux du vaisseau sont contr√¥l√©s par les touches `FL√àCHE-GAUCHE` et `FL√àCHE-DROITE`. La touche `ESPACE` permet de tirer des lasers. \n\n### Dimensions\n\nVous pouvez utiliser les dimensions suivantes : \n- Les dimensions de la fen√™tre sont de 1000x800 pixels\n- Les aliens et le vaisseau sont des rectangles de 50x50 pixels\n- Les lasers sont des rectangles de 5x30 pixels \n\n### D√©monstration\n\u003cp align=\"center\"\u003e\n\u003ciframe src=\"https://openprocessing.org/sketch/1592175/embed/?plusEmbedHash=YTc3Mzc1ODI5ODMzYzhkMTdkYzAyM2U4Yjk1MDc4YWJiZTEyMzc2ZjVmZTRmMTQ4NTQ1MGY5NDdmN2VlNTdlNGMwMWI1ZDNjMzc2NjkyZGEyMThiMWIxZGNmODYyZjEyNmM3ODE3YWUyMjZmMDEyMGVhN2NiYTgwYWNkN2U3Y2RrdGg2VWk4NXkxVWNWVitBZitsbXozUTdOVFQ5UERTd0c2dmpZM0VybXloKzFUMUxDb1dvTU9JWWpBWnlEUVdoSlFscFl5SW1TWXRyeWN2ZWhWVEVBUT09\u0026plusEmbedTitle=true\" width=\"600\" height=\"500\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e\n\n## Version am√©lior√©e\n\n### Fin de jeu\n\nLes aliens se rapprochent lentement mais s√ªrement du vaisseau. Si le joueur ne parvient pas √† d√©truire l‚Äôenti√®ret√© de la vague avant que les aliens atteignent le bas de l‚Äô√©cran, le jeu est perdu. \n\n### Gestion des couleurs\n\nChaque alien peut, al√©atoirement, avoir une des couleurs suivantes : `color(240, 20, 20)`, `color(200, 20, 200)`, `color(20, 200, 20)`, `color(20, 100, 250)`, `color(240, 200, 0)`. \n\n### Gestion de la difficult√©\n\nLorsque la vague d‚Äôaliens est d√©truite, un nouvelle vague arrive. Chaque vague d‚Äôaliens est plus r√©sistante que la pr√©c√©dente : √† chaque nouvelle vague, il faut un coup de laser en plus pour d√©truire un alien. A la deuxi√®me vague, il faudra donc toucher un alien 2 fois pour le d√©truire, 3 fois pour la troisi√®me vague, et ainsi de suite. \n\n### Gestion de la transparence\n\nSi vous g√©rez √©galement la difficult√© des vagues, le taux d‚Äôopacit√© d‚Äôun alien diminue en fonction du nombre de lasers qui l‚Äôont d√©j√† touch√©, pour un minimum de 50%. Par exemple, √† la vague 3, un alien sera initialement visible √† 100%, √† 75% apr√®s le premier coup et √† 50% apr√®s le deuxi√®me ; il sera d√©truit apr√®s le troisi√®me coup.\n\n### D√©monstration\n\n\u003cp align=\"center\"\u003e\n\u003ciframe src=\"https://openprocessing.org/sketch/1592193/embed/?plusEmbedHash=YmI5ZWNkMzIwYzFiZGNhODBkOGM0NzYyN2ZmMTAyNjBiYzc5OGQ4OTk0OTY2YmJmNTUwMjRlOWZmOWU4MmNiMzQ5ODhmOTg5M2E1MTA0ZjU3OWFkMzRjZThjZTliZmU5NDBiNjcyZmIyNmVhNWQ5YmZmOTkyOWRhM2NjOTI0NzFzSkRWU29QRzRzOTZYOXArekUvTmk3OFhNWWRRRjFCbXVwNkUrZ2ZSNmp4UHlwOUlpaE55WUt5NEc0Y1VubWhNM1JlWWJhVnhaQ3N0RmJQL0xyeXJTUT09\u0026plusEmbedTitle=true\" width=\"600\" height=\"500\"\u003e\u003c/iframe\u003e\n\u003c/p\u003e","lastmodified":"2022-06-26T13:12:20.470559491Z","tags":null},"/tutoriels/structurer-une-solution":{"title":"Structurer une solution processing","content":"\n## Vue d'ensemble\nUne solution processing contiendra\n\n-   La d√©claration de variables globales (visibles dans tous les blocs)\n-   Le `setup`\n-   Le `draw`\n-   Les fonctions de r√©action aux inputs pertinantes (`mousePressed`, `keyPressed`, etc.)\n-   Des fonctions globales, utilitaires\n-   Des classes\n\nIl est plus facile d'√©crire une classe dans un onglet sp√©cifique pour cette classe, et, si le code devient trop long, de regrouper en diff√©rents onglets (~ bloc logique) les diff√©rentes fonctions.\n\n## Etat et donn√©es\n\nL'_√©tat_ du code est l'ensemble des informations (~ variables) qui permettent, √† tout moment, de repr√©senter le dessin et de le faire √©voluer.\n\n### Constantes\n\nLes variables **constantes** sont des valeurs qui ne changeront pas lors de l'ex√©cution du code, mais qui seront amen√©es √† √™tre utilis√©es r√©guli√®rement. On pr√©f√®re ainsi voir appara√Ætre ce genre de valeurs dans des variables constantes, pour pouvoir facilement les changer sans devoir reparcourir tout le code. \n\nLorsque ces variables sont bien nomm√©es, elles peuvent √©galement am√©liorer la lisibilit√© du code :\n\n```java\nint WON = 1;\nint PLAYING = 0;\nint LOST = -1;\n\nint status = PLAYING;\n\n// ... Some code\n\nif (status == WON) {\n  // Do something if we won\n} else if (status == LOST) {\n  // Do something else if we lost\n} else {\n  // Continue playing\n}\n```\n\n### D√©terminer les informations n√©cessaires\n\nLes autres variables sont d√©termin√©es par ce dont nous avons besoin pour avoir le comportement voulu. Par exemple, si on veut dessiner une balle qui rebondit sur les bords de l'√©cran, il faudra conna√Ætre les informations qui permettent de dessiner cette balle : ses coordonn√©es, sa taille, sa couleur, etc. Ce qu'on peut voir comme une seule information doit parfois √™tre stock√©e en plusieurs variables.\n\n\u003e ‚ö†Ô∏è Il est **difficile** de r√©ussir √† d√©terminer toutes les variables dont on a besoin d√®s le d√©but. C'est seulement en avan√ßant dans la solution et dans les fonctionnalit√©s impl√©ment√©es qu'on se rend compte qu'il manque des informations.\n\n### Evolution des donn√©es\n\nLes variables non constantes sont amen√©es √† changer lors de l'ex√©cution du code. On peut distinguer deux types d'√©volution :\n- L'√©volution naturelle (dans le `draw`)\n- L'√©volution forc√©e en r√©action aux entr√©es clavier/souris de l'utilisateur\n\n## Initialisation `setup`\n\nTout dessin processing doit d√©finir la fonction `setup` dans laquelle il convient d'initialiser l'√©tat, les valeurs initiales des donn√©es. On peut aussi y configurer certains param√®tres globaux du dessin (largeur des lignes, etc.)\n\n```java\nvoid setup() {\n  size(800, 600);\n\n  // Some global drawing parameters\n\n  // Data initialization\n\t\n}\n```\n\n## Boucle principale `draw`\n\nLa \"boucle principale\" est une boucle implicite qui permet de passer √† l'√©tape suivante du code. En processing, cette boucle principale est la fonction `draw`, et une √©tape est une *frame* du dessin. C'est donc de cette fonction que partira la majorit√© de la logique du code : la repr√©sentation, le dessin, et l'√©volution naturelle des donn√©es. L'ordre des diff√©rentes mises √† jour de donn√©es et des dessins d√©pendra du comportement voulu\n\n```java\nvoid draw() {\n  background(0); // Hide previous frame if needed\n\n  // Update state\n\n  // Draw state\n\n}\n```\n\n## R√©actions aux entr√©es\n\nLes diff√©rentes entr√©es possibles en processing sont accessibles via des fonctions qui seront appel√©es quand l'√©v√®nement correspondant survient, entre deux appels de `draw`. Il ne faut d√©finir chaque fonction qu'une seule fois\n\n\u003e ‚ö†Ô∏è Les r√©actions aux entr√©es ne fonctionnent que pour les dessins anim√©s, c'est-√†-dire les dessins pour lesquels on a d√©fini le `draw`\n\n### Clavier\n\nPour une entr√©e clavier, il y aura toujours deux √©v√©n√®ments :\n- `void keyPressed()` quand on appuie sur la touche du clavier\n- `void keyReleased()` quand on rel√¢che la touche\n\nAttention, maintenir une touche du clavier enfonc√©e peut provoquer plusieurs appels cons√©cutifs √† `keyPressed` mais ce comportement et la fr√©quence √† laquelle l'√©v√®nement est produit d√©pendent du syst√®me d'exploitation. Par cons√©quent, utiliser `keyPressed` pour bouger des parties du dessin (comme un personnage) causera des mouvements saccad√©s, moins fluides que si l'√©volution des coordonn√©es √©tait r√©alis√©e dans le `draw`. \n\n### Souris\n\nPour une entr√©e souris, il y aura toujours les √©v√®nements :\n- `void mousePressed()` quand on appuie sur la touche de la souris\n- `void mouseReleased()` quand on rel√¢che la touche\n- `void mouseClicked()` quand on a appuy√© et rel√¢ch√© une touche\n\n## Fonctions\n\nEcrire des fonctions permet de ne d√©finir qu'une seule fois un bloc de code qui sera amen√© √† √™tre utilis√© plusieurs fois. On peut √©galement √©crire des fonctions simplement pour am√©liorer la lisibilit√© (√† condition de bien nommer les fonctions) ou pour all√©ger un long bloc de code.\n\n```java\nint x1 = 0; int y1 = 0;\nint x2 = 10; int y2 = 20;\n\nvoid setup() {\n  size(500, 500);\n\n  fill(int(random(256)));\n  ellipse(x1, y1, 20, 20);\n\t\n  fill(int(random(256)));\n  ellipse(x2, y2, 20, 20);\n}\n```\n\nDevient\n\n```java\nint x1 = 0; int y1 = 0;\nint x2 = 10; int y2 = 20;\n\nvoid setup() {\n  size(500, 500);\n  drawCircleWithRandomColor(x1, y1);\n  drawCircleWithRandomColor(x2, y2);\n}\n\nvoid drawCircleWithRandomColor(float x, float y) {\n  fill(int(random(256)));\n  ellipse(x, y, 20, 20);\n}\n```\n\n## Classes\n\nLes classes permettent de d√©finir des concepts complexes et d'y regrouper les diff√©rentes informations (= attributs) et comportements (= m√©thodes) de ces concepts. Elles permettent, comme les fonctions, d'am√©liorer la structure et la lisibilit√© du code. \n\nIl n'est pas n√©cessaire de faire des classes (ou des fonctions), mais il est parfois plus facile de concevoir directement la solution en orient√© objet (\"je vais faire des objets Balle\"). Bien souvent, lorsque l'on d√©termine les informations n√©cessaires, elles-m√™mes sont d√©duites des concepts qui peuvent directement √™tre traduits en classes.\n\n```java\nclass CircleWithRandomColor {\n  int x, y;\n  int diameter;\n  int c;\n\n  CircleWithRandomColor(int x, int y, int diameter) {\n    this.x = x;\n    this.y = y;\n    this.diameter = diameter;\n    this.c = int(random(256));\t  \n  }\n\n  void display() {\n    ellipseMode(DIAMETER);\n    fill(c);\n    ellipse(x, y, diameter, diameter);\n  }\n}\n```\n\n## Conseils g√©n√©raux\n- Aller √† l'essentiel, d'abord faire fonctionner ce qu'on veut puis seulement essayer d'am√©liorer ou de simplifier\n- Isoler des fonctionnalit√©s pour seulement ensuite les int√©grer au code principal\n- Avancer petit √† petit, ne pas essayer de tout faire en une fois\n- [D√©bugger](tutoriels/debugger.md), via le debugger de processing ou en affichant en console ce qu'il se passe, les valeurs, etc.\n\n## Exemple\n\nCi-dessous un tutoriel processing (disponible ici) montrant comment r√©aliser le dessin d'une balle qui part du centre de l'√©cran vers une direction al√©atoire, et rebondit sur les bords\n\n// TODO","lastmodified":"2022-06-26T13:12:20.478559674Z","tags":null}}